<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Debugger de Par√°grafo Justificado v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Arimo:ital,wght@0,400;0,700;1,400;1,700&family=Tinos:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark light;
    }

    body {
      margin: 0;
      padding: 0;
      background: #0f172a;
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1rem 1.5rem;
      background: #020617;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 0.03em;
    }

    .header-badges {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    header span.label {
      font-size: 0.75rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #94a3b8;
    }

    .zoom-warning {
      font-size: 0.7rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: rgba(251, 191, 36, 0.2);
      border: 1px solid rgba(251, 191, 36, 0.6);
      color: #fbbf24;
      display: none;
    }

    .zoom-warning.visible {
      display: inline-block;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.4fr);
      gap: 1px;
      background: #020617;
      min-height: 0;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: auto auto;
      }
    }

    section {
      padding: 1rem 1.25rem;
      background: radial-gradient(circle at top left, rgba(148, 163, 184, 0.15), #020617 55%);
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    h2 {
      margin: 0;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #9ca3af;
    }

    .section-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .section-header small {
      font-size: 0.75rem;
      color: #6b7280;
    }

    textarea {
      width: 100%;
      min-height: 140px;
      resize: vertical;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      padding: 0.75rem 0.85rem;
      font-size: 0.9rem;
      line-height: 1.5;
      outline: none;
    }

    textarea:focus {
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.3);
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: space-between;
      margin-top: 0.5rem;
    }

    .controls-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    label.inline {
      font-size: 0.8rem;
      color: #9ca3af;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    input[type="range"] {
      accent-color: #38bdf8;
    }

    select, input[type="number"] {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.5);
      color: #e5e7eb;
      border-radius: 999px;
      padding: 0.2rem 0.6rem;
      font-size: 0.8rem;
      outline: none;
    }

    button {
      border-radius: 999px;
      background: linear-gradient(135deg, #0ea5e9, #22c55e);
      border: none;
      color: white;
      font-size: 0.85rem;
      font-weight: 600;
      padding: 0.45rem 1rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
      box-shadow: 0 10px 25px rgba(15, 118, 110, 0.4);
      white-space: nowrap;
    }

    button span.icon {
      font-size: 1rem;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 4px 15px rgba(15, 118, 110, 0.4);
    }

    button.secondary {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
    }

    .preview-shell {
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: radial-gradient(circle at top, rgba(148, 163, 184, 0.15), rgba(15, 23, 42, 0.95));
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      min-height: 200px;
    }

    .preview-meta {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 0.75rem;
      color: #9ca3af;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .preview-container {
      position: relative;
      border-radius: 0.7rem;
      background: #f9fafb;
      color: #111827;
      padding: 1rem;
      min-height: 120px;
      overflow: hidden;
    }

    .preview-container p {
      margin: 0;
    }

    #preview {
      text-align: justify;
      font-size: 16px;
    }

    .hint {
      font-size: 0.75rem;
      color: #64748b;
    }

    .results-grid {
      display: grid;
      grid-template-rows: auto auto minmax(0, 1fr);
      gap: 0.75rem;
      min-height: 0;
    }

    .results-summary {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .pill {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      font-size: 0.75rem;
    }

    .pill.auto {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.6);
      color: #22c55e;
    }

    .lines-output {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 0.6rem 0.75rem;
      font-size: 0.78rem;
      max-height: 120px;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
    }

    .table-shell {
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.9);
      padding: 0.4rem 0.3rem 0.3rem;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .table-shell h3 {
      margin: 0 0 0.25rem;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      padding: 0 0.4rem;
    }

    .table-container {
      flex: 1;
      min-height: 0;
      max-height: 260px;
      overflow: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.74rem;
      table-layout: fixed;
    }

    thead {
      position: sticky;
      top: 0;
      background: rgba(15, 23, 42, 1);
      z-index: 1;
    }

    th, td {
      padding: 0.25rem 0.4rem;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    th {
      font-weight: 500;
      color: #9ca3af;
    }

    tr:nth-child(even) td {
      background: rgba(15, 23, 42, 0.7);
    }

    .char-cell {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .char-cell span {
      padding: 0.05rem 0.3rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      border: 1px solid rgba(148, 163, 184, 0.4);
      display: inline-block;
    }

    .footnote {
      margin-top: 0.25rem;
      font-size: 0.7rem;
      color: #6b7280;
      padding: 0 0.3rem;
    }

    .advanced-panel {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 0.5rem;
      padding: 0.5rem 0.75rem;
      margin-top: 0.25rem;
    }

    .advanced-panel summary {
      cursor: pointer;
      font-size: 0.75rem;
      color: #9ca3af;
      user-select: none;
    }

    .advanced-panel[open] summary {
      margin-bottom: 0.5rem;
    }

    .advanced-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    .info-box {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid rgba(59, 130, 246, 0.4);
      border-radius: 0.5rem;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      color: #93c5fd;
      margin-top: 0.5rem;
    }

    .info-box code {
      background: rgba(0,0,0,0.3);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Debugger de Par√°grafo Justificado v2</h1>
    <div class="header-badges">
      <span class="label">Layout inspector</span>
      <span class="zoom-warning" id="zoomWarning">‚ö†Ô∏è Zoom: <span id="zoomLevel">100</span>%</span>
    </div>
  </header>

  <main>
    <section aria-label="Entrada de texto e op√ß√µes">
      <div class="section-header">
        <h2>Texto</h2>
        <small>Digite, cole ou edite o par√°grafo que voc√™ quer inspecionar.</small>
      </div>

      <textarea id="sourceText"></textarea>

      <div class="controls-row">
        <div class="controls-group">
          <label class="inline">
            Tamanho
            <input type="range" id="fontSize" min="10" max="32" value="16" />
            <span id="fontSizeValue">16px</span>
          </label>

          <label class="inline">
            Alinhamento
            <select id="textAlign">
              <option value="justify" selected>justify</option>
              <option value="left">left</option>
              <option value="right">right</option>
              <option value="center">center</option>
            </select>
          </label>

          <label class="inline">
            Fonte
            <select id="fontFamily">
              <option value="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif">Sistema</option>
              <option value="Georgia, 'Times New Roman', serif">Serif</option>
              <option value="'Tinos', Georgia, 'Times New Roman', serif">Tinos (Google)</option>
              <option value="'Arimo', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif">Arimo (Google)</option>
              <option value="'Times New Roman', Times, serif">Times</option>
              <option value="'Courier New', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace">Mono</option>
            </select>
          </label>

          <label class="inline">
            Dire√ß√£o
            <select id="textDirection">
              <option value="ltr" selected>LTR</option>
              <option value="rtl">RTL</option>
            </select>
          </label>
        </div>

        <div class="controls-group">
          <label class="inline">
            <input type="checkbox" id="showOverlay" checked />
            Overlay
          </label>
          <button id="analyzeBtn" type="button">
            <span class="icon">üîç</span>
            Analisar layout
          </button>
          <button id="exportBtn" type="button" class="secondary">
            <span class="icon">üì¶</span>
            Exportar JSON
          </button>
        </div>
      </div>

      <!-- Painel Avan√ßado para resolver os 3 problemas -->
      <details class="advanced-panel">
        <summary>‚öôÔ∏è Configura√ß√µes Avan√ßadas (Precis√£o, Multi-Rect, Threshold)</summary>
        <div class="advanced-controls">
          <!-- PROBLEMA 1: Subpixel Precision -->
          <label class="inline">
            Precis√£o
            <select id="precisionMode">
              <option value="full">Completa (subpixel)</option>
              <option value="rounded" selected>Arredondada (2 decimais)</option>
              <option value="integer">Inteiro (px)</option>
            </select>
          </label>

          <label class="inline">
            Coords
            <select id="coordMode">
              <option value="viewport" selected>Viewport (absolutas)</option>
              <option value="relative">Relativas ao container</option>
            </select>
          </label>

          <!-- PROBLEMA 2: Multi-Rect Handling -->
          <label class="inline">
            Estrat√©gia Rect
            <select id="rectStrategy">
              <option value="widest" selected>Mais largo</option>
              <option value="first">Primeiro</option>
              <option value="largest">Maior √°rea</option>
              <option value="union">Uni√£o (bounding box)</option>
              <option value="all">Todos (m√∫ltiplos)</option>
            </select>
          </label>

          <!-- PROBLEMA 3: Line Threshold Sensitivity -->
          <label class="inline">
            Threshold
            <select id="thresholdMode">
              <option value="auto" selected>Auto (baseado em line-height)</option>
              <option value="manual">Manual</option>
              <option value="adaptive">Adaptativo (clustering)</option>
            </select>
          </label>

          <label class="inline" id="manualThresholdLabel" style="display:none;">
            Valor
            <input type="number" id="lineThreshold" value="2" min="0" max="20" step="0.5" style="width:3.5rem" />px
          </label>
        </div>

        <div class="info-box" id="thresholdInfo">
          ‚ÑπÔ∏è <strong>Auto-threshold</strong>: Calculado como <code>lineHeight √ó 0.3</code>. 
          Valor atual: <span id="calculatedThreshold">--</span>px
        </div>
      </details>

      <p class="hint">Dica: Para texto RTL ou fontes ex√≥ticas, ajuste a estrat√©gia de rect e o threshold nas configura√ß√µes avan√ßadas.</p>
    </section>

    <section aria-label="Preview e resultados">
      <div class="section-header">
        <h2>Preview &amp; resultados</h2>
        <small>O overlay reflete o layout final renderizado pelo browser.</small>
      </div>

      <div class="preview-shell">
        <div class="preview-meta">
          <span class="pill">Preview do par√°grafo</span>
          <span class="pill auto" id="autoThresholdBadge" style="display:none;">Auto: <span id="autoThresholdValue">--</span>px</span>
          <span class="hint">O texto abaixo √© o que est√° sendo medido.</span>
        </div>
        <div class="preview-container">
          <p id="preview"></p>
        </div>
      </div>

      <div class="results-grid">
        <div class="results-summary">
          <div>
            <span id="summaryLines">0 linhas</span> ¬∑ 
            <span id="summaryGlyphs">0 glifos</span> ¬∑ 
            <span id="summaryRects">0 rects</span>
          </div>
          <div class="hint">Espa√ßos aparecem como <code>‚ê£</code> na tabela.</div>
        </div>

        <div class="lines-output" id="linesOutput"></div>

        <div class="table-shell">
          <h3>Glifos medidos</h3>
          <div class="table-container">
            <table>
              <thead>
                <tr>
                  <th>#</th>
                  <th>Char</th>
                  <th>Linha</th>
                  <th>X</th>
                  <th>Y</th>
                  <th>Largura</th>
                  <th>Altura</th>
                  <th>Rects</th>
                </tr>
              </thead>
              <tbody id="glyphTableBody"></tbody>
            </table>
          </div>
          <div class="footnote">
            Os valores de X/Y dependem do modo de coordenadas selecionado.
            <span id="coordModeNote">(Viewport)</span>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // =========================================
    // CORE DE DEBUG v2 - COM SOLU√á√ïES PARA:
    // 1. Subpixel Precision
    // 2. Multi-Rect Handling
    // 3. Line Threshold Sensitivity
    // =========================================

    (function () {
      // -------------------------
      // SOLU√á√ÉO 1: Detec√ß√£o de Zoom
      // -------------------------
      function getZoomLevel() {
        // M√©todo 1: devicePixelRatio vs zoom visual
        const dpr = window.devicePixelRatio || 1;
        
        // M√©todo 2: comparar tamanho computado com esperado
        const testEl = document.createElement('div');
        testEl.style.cssText = 'position:absolute;width:100px;height:100px;top:-9999px;left:-9999px;';
        document.body.appendChild(testEl);
        const computedWidth = testEl.getBoundingClientRect().width;
        document.body.removeChild(testEl);
        
        // Zoom aproximado baseado no DPR e tamanho renderizado
        const zoomFromSize = computedWidth / 100;
        
        // Retorna o mais prov√°vel
        return Math.round(zoomFromSize * 100);
      }

      function monitorZoom(callback) {
        let lastZoom = getZoomLevel();
        
        const check = () => {
          const currentZoom = getZoomLevel();
          if (currentZoom !== lastZoom) {
            lastZoom = currentZoom;
            callback(currentZoom);
          }
        };

        window.addEventListener('resize', check);
        
        // Tamb√©m verifica periodicamente (alguns zooms n√£o disparam resize)
        setInterval(check, 1000);
        
        return lastZoom;
      }

      // -------------------------
      // SOLU√á√ÉO 2: Estrat√©gias de Multi-Rect
      // -------------------------
      const RectStrategies = {
        // Estrat√©gia original: escolhe o mais largo
        widest: function(rects) {
          if (!rects.length) return null;
          let chosen = rects[0];
          for (let i = 1; i < rects.length; i++) {
            if (rects[i].width > chosen.width) {
              chosen = rects[i];
            }
          }
          return [chosen];
        },

        // Primeiro rect (√∫til para LTR simples)
        first: function(rects) {
          return rects.length ? [rects[0]] : null;
        },

        // Maior √°rea (melhor para glifos fragmentados)
        largest: function(rects) {
          if (!rects.length) return null;
          let chosen = rects[0];
          let maxArea = chosen.width * chosen.height;
          for (let i = 1; i < rects.length; i++) {
            const area = rects[i].width * rects[i].height;
            if (area > maxArea) {
              chosen = rects[i];
              maxArea = area;
            }
          }
          return [chosen];
        },

        // Uni√£o: bounding box de todos os rects
        union: function(rects) {
          if (!rects.length) return null;
          
          let minX = Infinity, minY = Infinity;
          let maxX = -Infinity, maxY = -Infinity;
          
          for (const r of rects) {
            minX = Math.min(minX, r.left);
            minY = Math.min(minY, r.top);
            maxX = Math.max(maxX, r.right);
            maxY = Math.max(maxY, r.bottom);
          }
          
          return [{
            left: minX,
            top: minY,
            right: maxX,
            bottom: maxY,
            width: maxX - minX,
            height: maxY - minY,
            x: minX,
            y: minY
          }];
        },

        // Todos: retorna todos os rects (para an√°lise completa)
        all: function(rects) {
          return rects.length ? Array.from(rects) : null;
        }
      };

      // -------------------------
      // SOLU√á√ÉO 3: Threshold Adaptativo
      // -------------------------
      const ThresholdStrategies = {
        // Manual: usa valor fixo
        manual: function(glyphs, manualValue) {
          return { 
            threshold: manualValue, 
            method: 'manual',
            confidence: 1.0 
          };
        },

        // Auto: baseado em line-height computada
        auto: function(glyphs, _, paragraph) {
          if (!paragraph) return { threshold: 2, method: 'auto-fallback', confidence: 0.5 };
          
          const style = window.getComputedStyle(paragraph);
          const lineHeight = parseFloat(style.lineHeight);
          const fontSize = parseFloat(style.fontSize);
          
          // Se lineHeight √© 'normal', estima como 1.2 √ó fontSize
          const effectiveLineHeight = isNaN(lineHeight) ? fontSize * 1.2 : lineHeight;
          
          // Threshold = 30% da line-height (permite varia√ß√£o de baseline)
          const threshold = effectiveLineHeight * 0.3;
          
          return { 
            threshold: Math.max(1, threshold),
            method: 'auto',
            lineHeight: effectiveLineHeight,
            fontSize: fontSize,
            confidence: 0.9
          };
        },

        // Adaptativo: usa clustering baseado em gaps naturais de Y
        adaptive: function(glyphs) {
          if (glyphs.length < 2) {
            return { threshold: 2, method: 'adaptive-fallback', confidence: 0.5 };
          }

          // Ordena por Y
          const sortedY = glyphs.map(g => g.y).sort((a, b) => a - b);
          
          // Calcula gaps entre valores Y consecutivos
          const gaps = [];
          for (let i = 1; i < sortedY.length; i++) {
            gaps.push(sortedY[i] - sortedY[i - 1]);
          }
          
          // Filtra gaps muito pequenos (mesmo glifo) e muito grandes (outliers)
          const avgHeight = glyphs.reduce((s, g) => s + g.height, 0) / glyphs.length;
          const significantGaps = gaps.filter(g => g > avgHeight * 0.1 && g < avgHeight * 3);
          
          if (!significantGaps.length) {
            return { threshold: avgHeight * 0.3, method: 'adaptive-height', confidence: 0.7 };
          }

          // Encontra o gap que melhor separa "mesma linha" de "nova linha"
          // usando o "cotovelo" na distribui√ß√£o
          significantGaps.sort((a, b) => a - b);
          
          let bestThreshold = significantGaps[0];
          let maxJump = 0;
          
          for (let i = 1; i < significantGaps.length; i++) {
            const jump = significantGaps[i] - significantGaps[i - 1];
            if (jump > maxJump) {
              maxJump = jump;
              // Threshold = ponto m√©dio do maior salto
              bestThreshold = (significantGaps[i - 1] + significantGaps[i]) / 2;
            }
          }
          
          return { 
            threshold: Math.max(1, bestThreshold),
            method: 'adaptive',
            gapsAnalyzed: significantGaps.length,
            confidence: 0.85
          };
        }
      };

      // -------------------------
      // Utilit√°rios de Precis√£o
      // -------------------------
      function formatNumber(n, precision) {
        switch (precision) {
          case 'full': return n;
          case 'integer': return Math.round(n);
          case 'rounded':
          default: return Math.round(n * 100) / 100;
        }
      }

      // -------------------------
      // Fun√ß√µes Auxiliares
      // -------------------------
      function getTextNodes(root) {
        const walker = document.createTreeWalker(
          root,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node) {
              if (!node.nodeValue || !node.nodeValue.trim()) {
                return NodeFilter.FILTER_REJECT;
              }
              return NodeFilter.FILTER_ACCEPT;
            },
          }
        );

        const nodes = [];
        while (walker.nextNode()) {
          nodes.push(walker.currentNode);
        }
        return nodes;
      }

      function segmentText(text) {
        if (window.Intl && typeof Intl.Segmenter === "function") {
          const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
          const it = seg.segment(text);
          const result = [];
          for (const s of it) {
            result.push({
              segment: s.segment,
              start: s.index,
              end: s.index + s.segment.length,
            });
          }
          return result;
        }

        const result = [];
        for (let i = 0; i < text.length; i++) {
          result.push({ segment: text[i], start: i, end: i + 1 });
        }
        return result;
      }

      function isRTL(element) {
        const style = window.getComputedStyle(element);
        return style.direction === 'rtl';
      }

      // -------------------------
      // Overlay Melhorado
      // -------------------------
      function attachOverlay(paragraph, glyphs, lines, options) {
        if (window.__paragraphDebugOverlay && window.__paragraphDebugOverlay.parentNode) {
          window.__paragraphDebugOverlay.parentNode.removeChild(window.__paragraphDebugOverlay);
        }

        const paraRect = paragraph.getBoundingClientRect();
        const scrollX = window.scrollX || window.pageXOffset || 0;
        const scrollY = window.scrollY || window.pageYOffset || 0;

        const overlay = document.createElement("div");
        overlay.style.position = "absolute";
        overlay.style.left = paraRect.left + scrollX + "px";
        overlay.style.top = paraRect.top + scrollY + "px";
        overlay.style.width = paraRect.width + "px";
        overlay.style.height = paraRect.height + "px";
        overlay.style.pointerEvents = "none";
        overlay.style.zIndex = 999999;
        overlay.style.boxSizing = "border-box";
        overlay.style.outline = "1px dashed rgba(15,23,42,0.3)";

        const overlayLeft = paraRect.left + scrollX;
        const overlayTop = paraRect.top + scrollY;

        // Desenha glifos
        glyphs.forEach((g) => {
          // Se estrat√©gia "all", pode ter m√∫ltiplos rects por glifo
          const rectsToRender = g.allRects || [g];
          
          rectsToRender.forEach((rect, i) => {
            const box = document.createElement("div");
            box.style.position = "absolute";
            const innerLeft = (rect.pageX || g.pageX) - overlayLeft;
            const innerTop = (rect.pageY || g.pageY) - overlayTop;
            box.style.left = innerLeft + "px";
            box.style.top = innerTop + "px";
            box.style.width = (rect.width || g.width) + "px";
            box.style.height = (rect.height || g.height) + "px";
            
            // Cor diferente para m√∫ltiplos rects
            const color = rectsToRender.length > 1 
              ? `rgba(${100 + i * 50}, 113, 113, 0.7)` 
              : "rgba(248,113,113,0.7)";
            box.style.border = `1px solid ${color}`;
            box.style.boxSizing = "border-box";
            box.style.pointerEvents = "none";
            box.title = `${g.text} (idx ${g.globalIndex}, linha ${g.line}${rectsToRender.length > 1 ? `, rect ${i+1}/${rectsToRender.length}` : ''})`;
            overlay.appendChild(box);
          });
        });

        // Desenha linhas
        lines.forEach((line) => {
          const lineBox = document.createElement("div");
          lineBox.style.position = "absolute";
          const innerLeft = line.xPage - overlayLeft;
          const innerTop = line.yPage - overlayTop;
          lineBox.style.left = innerLeft + "px";
          lineBox.style.top = innerTop + "px";
          lineBox.style.width = line.width + "px";
          lineBox.style.height = line.height + "px";
          lineBox.style.border = "1px dashed rgba(59,130,246,0.8)";
          lineBox.style.boxSizing = "border-box";
          lineBox.style.pointerEvents = "none";
          lineBox.style.fontSize = "10px";
          lineBox.style.lineHeight = "10px";
          lineBox.style.color = "rgba(59,130,246,0.8)";
          lineBox.style.textAlign = "right";
          lineBox.style.paddingRight = "2px";
          lineBox.textContent = `L${line.line}`;
          overlay.appendChild(lineBox);
        });

        document.body.appendChild(overlay);
        window.__paragraphDebugOverlay = overlay;
        return overlay;
      }

      function clearOverlay() {
        if (window.__paragraphDebugOverlay && window.__paragraphDebugOverlay.parentNode) {
          window.__paragraphDebugOverlay.parentNode.removeChild(window.__paragraphDebugOverlay);
        }
        window.__paragraphDebugOverlay = null;
      }

      // -------------------------
      // Fun√ß√£o Principal MELHORADA
      // -------------------------
      function debugJustifiedParagraph(paragraph, options) {
        if (!paragraph || !(paragraph instanceof HTMLElement)) {
          throw new Error("Passe um elemento <p> v√°lido para debugJustifiedParagraph(paragraph, options)");
        }

        const opts = Object.assign({ 
          overlay: false, 
          lineThreshold: 2,
          // Novas op√ß√µes
          thresholdMode: 'auto',      // 'manual', 'auto', 'adaptive'
          rectStrategy: 'widest',      // 'widest', 'first', 'largest', 'union', 'all'
          precision: 'rounded',        // 'full', 'rounded', 'integer'
          coordMode: 'viewport'        // 'viewport', 'relative'
        }, options || {});

        const textNodes = getTextNodes(paragraph);
        if (!textNodes.length) {
          return { glyphs: [], lines: [], overlay: null, meta: {} };
        }

        const range = document.createRange();
        const glyphs = [];
        let globalIndex = 0;
        let totalRects = 0;

        // Detecta RTL para ordena√ß√£o correta
        const rtl = isRTL(paragraph);
        const paraRect = paragraph.getBoundingClientRect();
        
        const scrollX = window.scrollX || window.pageXOffset || 0;
        const scrollY = window.scrollY || window.pageYOffset || 0;

        textNodes.forEach((node, nodeIndex) => {
          const text = node.data;
          const segments = segmentText(text);

          segments.forEach((seg) => {
            range.setStart(node, seg.start);
            range.setEnd(node, seg.end);

            const rects = range.getClientRects();
            if (!rects.length) return;

            totalRects += rects.length;

            // SOLU√á√ÉO 2: Aplica estrat√©gia de sele√ß√£o de rects
            const strategy = RectStrategies[opts.rectStrategy] || RectStrategies.widest;
            const selectedRects = strategy(rects);
            
            if (!selectedRects || !selectedRects.length) return;

            // Usa o primeiro rect selecionado como principal
            const chosen = selectedRects[0];

            // SOLU√á√ÉO 1: Calcula coordenadas conforme modo
            let x, y, pageX, pageY;
            
            if (opts.coordMode === 'relative') {
              x = chosen.left - paraRect.left;
              y = chosen.top - paraRect.top;
              pageX = x;
              pageY = y;
            } else {
              x = chosen.left;
              y = chosen.top;
              pageX = chosen.left + scrollX;
              pageY = chosen.top + scrollY;
            }

            const glyphData = {
              globalIndex: globalIndex++,
              nodeIndex,
              node,
              text: seg.segment,
              startOffset: seg.start,
              endOffset: seg.end,
              x: formatNumber(x, opts.precision),
              y: formatNumber(y, opts.precision),
              width: formatNumber(chosen.width, opts.precision),
              height: formatNumber(chosen.height, opts.precision),
              pageX: formatNumber(pageX, opts.precision),
              pageY: formatNumber(pageY, opts.precision),
              line: null,
              rectCount: rects.length,
              // Armazena todos os rects se estrat√©gia "all"
              allRects: opts.rectStrategy === 'all' ? selectedRects.map(r => ({
                x: formatNumber(opts.coordMode === 'relative' ? r.left - paraRect.left : r.left, opts.precision),
                y: formatNumber(opts.coordMode === 'relative' ? r.top - paraRect.top : r.top, opts.precision),
                width: formatNumber(r.width, opts.precision),
                height: formatNumber(r.height, opts.precision),
                pageX: formatNumber(r.left + scrollX, opts.precision),
                pageY: formatNumber(r.top + scrollY, opts.precision)
              })) : null,
              // Dados brutos para an√°lise
              _rawY: chosen.top
            };

            glyphs.push(glyphData);
          });
        });

        range.detach?.();

        if (!glyphs.length) {
          return { glyphs: [], lines: [], overlay: null, meta: {} };
        }

        // Ordena: para RTL, inverte a ordena√ß√£o X
        glyphs.sort((a, b) => {
          const yDiff = a._rawY - b._rawY;
          if (Math.abs(yDiff) > 1) return yDiff;
          return rtl ? (b.x - a.x) : (a.x - b.x);
        });

        // SOLU√á√ÉO 3: Calcula threshold conforme modo
        const thresholdStrategy = ThresholdStrategies[opts.thresholdMode] || ThresholdStrategies.auto;
        const thresholdResult = thresholdStrategy(glyphs, opts.lineThreshold, paragraph);
        const threshold = thresholdResult.threshold;

        // Atribui linhas
        let line = 0;
        let currentTop = glyphs[0]._rawY;

        glyphs.forEach((g) => {
          if (Math.abs(g._rawY - currentTop) > threshold) {
            line++;
            currentTop = g._rawY;
          }
          g.line = line;
        });

        // Agrupa por linha
        const byLine = new Map();
        glyphs.forEach((g) => {
          if (!byLine.has(g.line)) byLine.set(g.line, []);
          byLine.get(g.line).push(g);
        });

        const lines = [];
        byLine.forEach((items, lineNumber) => {
          items.sort((a, b) => rtl ? (b.x - a.x) : (a.x - b.x));
          const first = items[0];
          const last = items[items.length - 1];
          const maxHeight = items.reduce((m, g) => Math.max(m, g.height), 0);

          lines.push({
            line: lineNumber,
            text: items.map((g) => g.text).join(""),
            x: first.x,
            y: first.y,
            width: last.x + last.width - first.x,
            height: maxHeight,
            xPage: first.pageX,
            yPage: first.pageY,
            glyphs: items,
          });
        });

        lines.sort((a, b) => a.line - b.line);

        // Limpa dados internos dos glifos
        glyphs.forEach(g => delete g._rawY);

        let overlay = null;
        if (opts.overlay) {
          overlay = attachOverlay(paragraph, glyphs, lines, opts);
        }

        // Metadados sobre a an√°lise
        const meta = {
          threshold: thresholdResult,
          rectStrategy: opts.rectStrategy,
          coordMode: opts.coordMode,
          precision: opts.precision,
          totalRects,
          rtl,
          zoomLevel: getZoomLevel()
        };

        return { glyphs, lines, overlay, meta };
      }

      // Exporta fun√ß√µes
      window.debugJustifiedParagraph = debugJustifiedParagraph;
      window.clearParagraphDebugOverlay = clearOverlay;
      window.getZoomLevel = getZoomLevel;
      window.monitorZoom = monitorZoom;
    })();

    // =========================================
    // UI / APP WIRING
    // =========================================

    (function () {
      const sourceText = document.getElementById("sourceText");
      const preview = document.getElementById("preview");
      const fontSizeInput = document.getElementById("fontSize");
      const fontSizeValue = document.getElementById("fontSizeValue");
      const textAlignSelect = document.getElementById("textAlign");
      const fontFamilySelect = document.getElementById("fontFamily");
      const textDirectionSelect = document.getElementById("textDirection");
      const showOverlayInput = document.getElementById("showOverlay");
      const analyzeBtn = document.getElementById("analyzeBtn");
      const linesOutput = document.getElementById("linesOutput");
      const glyphTableBody = document.getElementById("glyphTableBody");
      const summaryLines = document.getElementById("summaryLines");
      const summaryGlyphs = document.getElementById("summaryGlyphs");
      const summaryRects = document.getElementById("summaryRects");
      const exportBtn = document.getElementById("exportBtn");
      
      // Novos controles avan√ßados
      const precisionModeSelect = document.getElementById("precisionMode");
      const coordModeSelect = document.getElementById("coordMode");
      const rectStrategySelect = document.getElementById("rectStrategy");
      const thresholdModeSelect = document.getElementById("thresholdMode");
      const lineThresholdInput = document.getElementById("lineThreshold");
      const manualThresholdLabel = document.getElementById("manualThresholdLabel");
      const thresholdInfo = document.getElementById("thresholdInfo");
      const calculatedThreshold = document.getElementById("calculatedThreshold");
      const autoThresholdBadge = document.getElementById("autoThresholdBadge");
      const autoThresholdValue = document.getElementById("autoThresholdValue");
      const coordModeNote = document.getElementById("coordModeNote");
      const zoomWarning = document.getElementById("zoomWarning");
      const zoomLevelSpan = document.getElementById("zoomLevel");

      let lastGlyphs = [];
      let lastLines = [];
      let lastMeta = {};

      const defaultText =
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. " +
        "Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. " +
        "Cras elementum ultrices diam. Maecenas ligula massa, varius a, semper congue, euismod non, mi.";

      // Monitora zoom
      const initialZoom = window.monitorZoom((newZoom) => {
        zoomLevelSpan.textContent = newZoom;
        zoomWarning.classList.toggle('visible', newZoom !== 100);
      });
      
      zoomLevelSpan.textContent = initialZoom;
      zoomWarning.classList.toggle('visible', initialZoom !== 100);

      function setPreviewFromTextarea() {
        preview.textContent = sourceText.value || "";
      }

      function applyStyles() {
        const size = parseFloat(fontSizeInput.value) || 16;
        preview.style.fontSize = size + "px";
        fontSizeValue.textContent = size + "px";
        preview.style.textAlign = textAlignSelect.value;
        preview.style.fontFamily = fontFamilySelect.value;
        preview.style.direction = textDirectionSelect.value;
      }

      function updateThresholdUI() {
        const mode = thresholdModeSelect.value;
        manualThresholdLabel.style.display = mode === 'manual' ? '' : 'none';
        thresholdInfo.style.display = mode === 'auto' ? '' : 'none';
        autoThresholdBadge.style.display = mode !== 'manual' ? '' : 'none';
      }

      function updateCoordModeUI() {
        const mode = coordModeSelect.value;
        coordModeNote.textContent = mode === 'viewport' ? '(Viewport)' : '(Relativas ao container)';
      }

      function formatLinesSummary(lines) {
        if (!lines.length) return "Nenhuma linha detectada.";
        return lines
          .map((line) => {
            const txt = line.text.replace(/\s/g, " ");
            const display = txt.length > 60 ? txt.slice(0, 57) + "‚Ä¶" : txt;
            return `L${line.line}: "${display}"`;
          })
          .join("\n");
      }

      function analyze() {
        window.clearParagraphDebugOverlay?.();

        setPreviewFromTextarea();
        applyStyles();

        if (!preview.textContent || !preview.textContent.trim()) {
          linesOutput.textContent = "Nada para medir. Digite algum texto.";
          glyphTableBody.innerHTML = "";
          summaryLines.textContent = "0 linhas";
          summaryGlyphs.textContent = "0 glifos";
          summaryRects.textContent = "0 rects";
          lastGlyphs = [];
          lastLines = [];
          lastMeta = {};
          return;
        }

        const options = {
          overlay: showOverlayInput.checked,
          lineThreshold: parseFloat(lineThresholdInput.value) || 2,
          thresholdMode: thresholdModeSelect.value,
          rectStrategy: rectStrategySelect.value,
          precision: precisionModeSelect.value,
          coordMode: coordModeSelect.value
        };

        const { glyphs, lines, meta } = window.debugJustifiedParagraph(preview, options);

        lastGlyphs = glyphs;
        lastLines = lines;
        lastMeta = meta;

        // Atualiza UI com info de threshold
        if (meta.threshold) {
          const t = meta.threshold.threshold;
          calculatedThreshold.textContent = t.toFixed(2);
          autoThresholdValue.textContent = t.toFixed(1);
        }

        summaryLines.textContent = `${lines.length} linha${lines.length === 1 ? "" : "s"}`;
        summaryGlyphs.textContent = `${glyphs.length} glifo${glyphs.length === 1 ? "" : "s"}`;
        summaryRects.textContent = `${meta.totalRects || 0} rects`;

        linesOutput.textContent = formatLinesSummary(lines);

        glyphTableBody.innerHTML = "";
        const frag = document.createDocumentFragment();

        glyphs.forEach((g) => {
          const tr = document.createElement("tr");

          const tdIdx = document.createElement("td");
          tdIdx.textContent = g.globalIndex;

          const tdChar = document.createElement("td");
          tdChar.className = "char-cell";
          const span = document.createElement("span");
          let displayChar = g.text;
          if (displayChar === " ") displayChar = "‚ê£";
          if (displayChar === "\n") displayChar = "‚Üµ";
          if (!displayChar) displayChar = "‚àÖ";
          span.textContent = displayChar;
          tdChar.appendChild(span);

          const tdLine = document.createElement("td");
          tdLine.textContent = g.line;

          const tdX = document.createElement("td");
          const tdY = document.createElement("td");
          const tdW = document.createElement("td");
          const tdH = document.createElement("td");
          const tdRects = document.createElement("td");

          // Formata conforme precis√£o
          const precision = precisionModeSelect.value;
          const formatVal = (v) => {
            if (precision === 'integer') return Math.round(v);
            if (precision === 'full') return v;
            return typeof v === 'number' ? v.toFixed(2) : v;
          };

          tdX.textContent = formatVal(g.x);
          tdY.textContent = formatVal(g.y);
          tdW.textContent = formatVal(g.width);
          tdH.textContent = formatVal(g.height);
          tdRects.textContent = g.rectCount || 1;

          tr.appendChild(tdIdx);
          tr.appendChild(tdChar);
          tr.appendChild(tdLine);
          tr.appendChild(tdX);
          tr.appendChild(tdY);
          tr.appendChild(tdW);
          tr.appendChild(tdH);
          tr.appendChild(tdRects);

          frag.appendChild(tr);
        });

        glyphTableBody.appendChild(frag);
      }

      function exportJson() {
        if (!lastGlyphs.length && !lastLines.length) {
          alert("Nenhum dado para exportar. Clique em \"Analisar layout\" primeiro.");
          return;
        }

        const meta = {
          text: sourceText.value,
          fontSize: parseFloat(fontSizeInput.value) || 16,
          textAlign: textAlignSelect.value,
          fontFamily: fontFamilySelect.value,
          direction: textDirectionSelect.value,
          // Configura√ß√µes avan√ßadas
          precision: precisionModeSelect.value,
          coordMode: coordModeSelect.value,
          rectStrategy: rectStrategySelect.value,
          thresholdMode: thresholdModeSelect.value,
          lineThreshold: lastMeta.threshold ? lastMeta.threshold.threshold : parseFloat(lineThresholdInput.value),
          thresholdMethod: lastMeta.threshold ? lastMeta.threshold.method : 'manual',
          // Stats
          overlay: showOverlayInput.checked,
          glyphCount: lastGlyphs.length,
          lineCount: lastLines.length,
          totalRects: lastMeta.totalRects || 0,
          rtl: lastMeta.rtl || false,
          zoomLevel: lastMeta.zoomLevel || 100,
          generatedAt: new Date().toISOString(),
        };

        const exportGlyphs = lastGlyphs.map((g) => ({
          index: g.globalIndex,
          text: g.text,
          line: g.line,
          x: g.x,
          y: g.y,
          width: g.width,
          height: g.height,
          pageX: g.pageX,
          pageY: g.pageY,
          nodeIndex: g.nodeIndex,
          startOffset: g.startOffset,
          endOffset: g.endOffset,
          rectCount: g.rectCount,
          allRects: g.allRects || null
        }));

        const exportLines = lastLines.map((line) => ({
          line: line.line,
          text: line.text,
          x: line.x,
          y: line.y,
          width: line.width,
          height: line.height,
          glyphIndices: line.glyphs ? line.glyphs.map((g) => g.globalIndex) : [],
        }));

        const payload = {
          meta,
          lines: exportLines,
          glyphs: exportGlyphs,
        };

        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        const ts = new Date().toISOString().replace(/[:.]/g, "-");
        a.download = `glyph-debug-${ts}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // Inicializa√ß√£o
      sourceText.value = defaultText;
      setPreviewFromTextarea();
      applyStyles();
      updateThresholdUI();
      updateCoordModeUI();

      // Event listeners b√°sicos
      fontSizeInput.addEventListener("input", () => {
        applyStyles();
        analyze();
      });

      textAlignSelect.addEventListener("change", analyze);
      fontFamilySelect.addEventListener("change", analyze);
      textDirectionSelect.addEventListener("change", analyze);
      showOverlayInput.addEventListener("change", analyze);

      sourceText.addEventListener("input", setPreviewFromTextarea);

      analyzeBtn.addEventListener("click", analyze);
      exportBtn.addEventListener("click", exportJson);

      // Event listeners avan√ßados
      thresholdModeSelect.addEventListener("change", () => {
        updateThresholdUI();
        analyze();
      });

      lineThresholdInput.addEventListener("change", analyze);
      precisionModeSelect.addEventListener("change", analyze);
      
      coordModeSelect.addEventListener("change", () => {
        updateCoordModeUI();
        analyze();
      });
      
      rectStrategySelect.addEventListener("change", analyze);

      // An√°lise inicial
      window.addEventListener("load", () => {
        setTimeout(analyze, 50);
      });
    })();
  </script>
</body>
</html>