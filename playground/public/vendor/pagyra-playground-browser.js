var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/linkedom/commonjs/perf_hooks.cjs
var require_perf_hooks = __commonJS({
  "node_modules/linkedom/commonjs/perf_hooks.cjs"(exports) {
    try {
      const { performance: performance3 } = __require("perf_hooks");
      exports.performance = performance3;
    } catch (fallback) {
      exports.performance = { now() {
        return +/* @__PURE__ */ new Date();
      } };
    }
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/cssom/lib/StyleSheet.js
var require_StyleSheet = __commonJS({
  "node_modules/cssom/lib/StyleSheet.js"(exports) {
    var CSSOM = {};
    CSSOM.StyleSheet = function StyleSheet() {
      this.parentStyleSheet = null;
    };
    exports.StyleSheet = CSSOM.StyleSheet;
  }
});

// node_modules/cssom/lib/CSSRule.js
var require_CSSRule = __commonJS({
  "node_modules/cssom/lib/CSSRule.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSRule = function CSSRule() {
      this.parentRule = null;
      this.parentStyleSheet = null;
    };
    CSSOM.CSSRule.UNKNOWN_RULE = 0;
    CSSOM.CSSRule.STYLE_RULE = 1;
    CSSOM.CSSRule.CHARSET_RULE = 2;
    CSSOM.CSSRule.IMPORT_RULE = 3;
    CSSOM.CSSRule.MEDIA_RULE = 4;
    CSSOM.CSSRule.FONT_FACE_RULE = 5;
    CSSOM.CSSRule.PAGE_RULE = 6;
    CSSOM.CSSRule.KEYFRAMES_RULE = 7;
    CSSOM.CSSRule.KEYFRAME_RULE = 8;
    CSSOM.CSSRule.MARGIN_RULE = 9;
    CSSOM.CSSRule.NAMESPACE_RULE = 10;
    CSSOM.CSSRule.COUNTER_STYLE_RULE = 11;
    CSSOM.CSSRule.SUPPORTS_RULE = 12;
    CSSOM.CSSRule.DOCUMENT_RULE = 13;
    CSSOM.CSSRule.FONT_FEATURE_VALUES_RULE = 14;
    CSSOM.CSSRule.VIEWPORT_RULE = 15;
    CSSOM.CSSRule.REGION_STYLE_RULE = 16;
    CSSOM.CSSRule.prototype = {
      constructor: CSSOM.CSSRule
      //FIXME
    };
    exports.CSSRule = CSSOM.CSSRule;
  }
});

// node_modules/cssom/lib/CSSStyleRule.js
var require_CSSStyleRule = __commonJS({
  "node_modules/cssom/lib/CSSStyleRule.js"(exports) {
    var CSSOM = {
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSStyleRule = function CSSStyleRule() {
      CSSOM.CSSRule.call(this);
      this.selectorText = "";
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSStyleRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSStyleRule.prototype.constructor = CSSOM.CSSStyleRule;
    CSSOM.CSSStyleRule.prototype.type = 1;
    Object.defineProperty(CSSOM.CSSStyleRule.prototype, "cssText", {
      get: function() {
        var text;
        if (this.selectorText) {
          text = this.selectorText + " {" + this.style.cssText + "}";
        } else {
          text = "";
        }
        return text;
      },
      set: function(cssText) {
        var rule = CSSOM.CSSStyleRule.parse(cssText);
        this.style = rule.style;
        this.selectorText = rule.selectorText;
      }
    });
    CSSOM.CSSStyleRule.parse = function(ruleText) {
      var i = 0;
      var state = "selector";
      var index;
      var j = i;
      var buffer = "";
      var SIGNIFICANT_WHITESPACE = {
        "selector": true,
        "value": true
      };
      var styleRule = new CSSOM.CSSStyleRule();
      var name, priority = "";
      for (var character; character = ruleText.charAt(i); i++) {
        switch (character) {
          case " ":
          case "	":
          case "\r":
          case "\n":
          case "\f":
            if (SIGNIFICANT_WHITESPACE[state]) {
              switch (ruleText.charAt(i - 1)) {
                case " ":
                case "	":
                case "\r":
                case "\n":
                case "\f":
                  break;
                default:
                  buffer += " ";
                  break;
              }
            }
            break;
          case '"':
            j = i + 1;
            index = ruleText.indexOf('"', j) + 1;
            if (!index) {
              throw '" is missing';
            }
            buffer += ruleText.slice(i, index);
            i = index - 1;
            break;
          case "'":
            j = i + 1;
            index = ruleText.indexOf("'", j) + 1;
            if (!index) {
              throw "' is missing";
            }
            buffer += ruleText.slice(i, index);
            i = index - 1;
            break;
          case "/":
            if (ruleText.charAt(i + 1) === "*") {
              i += 2;
              index = ruleText.indexOf("*/", i);
              if (index === -1) {
                throw new SyntaxError("Missing */");
              } else {
                i = index + 1;
              }
            } else {
              buffer += character;
            }
            break;
          case "{":
            if (state === "selector") {
              styleRule.selectorText = buffer.trim();
              buffer = "";
              state = "name";
            }
            break;
          case ":":
            if (state === "name") {
              name = buffer.trim();
              buffer = "";
              state = "value";
            } else {
              buffer += character;
            }
            break;
          case "!":
            if (state === "value" && ruleText.indexOf("!important", i) === i) {
              priority = "important";
              i += "important".length;
            } else {
              buffer += character;
            }
            break;
          case ";":
            if (state === "value") {
              styleRule.style.setProperty(name, buffer.trim(), priority);
              priority = "";
              buffer = "";
              state = "name";
            } else {
              buffer += character;
            }
            break;
          case "}":
            if (state === "value") {
              styleRule.style.setProperty(name, buffer.trim(), priority);
              priority = "";
              buffer = "";
            } else if (state === "name") {
              break;
            } else {
              buffer += character;
            }
            state = "selector";
            break;
          default:
            buffer += character;
            break;
        }
      }
      return styleRule;
    };
    exports.CSSStyleRule = CSSOM.CSSStyleRule;
  }
});

// node_modules/cssom/lib/CSSStyleSheet.js
var require_CSSStyleSheet = __commonJS({
  "node_modules/cssom/lib/CSSStyleSheet.js"(exports) {
    var CSSOM = {
      StyleSheet: require_StyleSheet().StyleSheet,
      CSSStyleRule: require_CSSStyleRule().CSSStyleRule
    };
    CSSOM.CSSStyleSheet = function CSSStyleSheet() {
      CSSOM.StyleSheet.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSStyleSheet.prototype = new CSSOM.StyleSheet();
    CSSOM.CSSStyleSheet.prototype.constructor = CSSOM.CSSStyleSheet;
    CSSOM.CSSStyleSheet.prototype.insertRule = function(rule, index) {
      if (index < 0 || index > this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      var cssRule = CSSOM.parse(rule).cssRules[0];
      cssRule.parentStyleSheet = this;
      this.cssRules.splice(index, 0, cssRule);
      return index;
    };
    CSSOM.CSSStyleSheet.prototype.deleteRule = function(index) {
      if (index < 0 || index >= this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      this.cssRules.splice(index, 1);
    };
    CSSOM.CSSStyleSheet.prototype.toString = function() {
      var result = "";
      var rules = this.cssRules;
      for (var i = 0; i < rules.length; i++) {
        result += rules[i].cssText + "\n";
      }
      return result;
    };
    exports.CSSStyleSheet = CSSOM.CSSStyleSheet;
    CSSOM.parse = require_parse().parse;
  }
});

// node_modules/cssom/lib/MediaList.js
var require_MediaList = __commonJS({
  "node_modules/cssom/lib/MediaList.js"(exports) {
    var CSSOM = {};
    CSSOM.MediaList = function MediaList() {
      this.length = 0;
    };
    CSSOM.MediaList.prototype = {
      constructor: CSSOM.MediaList,
      /**
       * @return {string}
       */
      get mediaText() {
        return Array.prototype.join.call(this, ", ");
      },
      /**
       * @param {string} value
       */
      set mediaText(value) {
        var values = value.split(",");
        var length = this.length = values.length;
        for (var i = 0; i < length; i++) {
          this[i] = values[i].trim();
        }
      },
      /**
       * @param {string} medium
       */
      appendMedium: function(medium) {
        if (Array.prototype.indexOf.call(this, medium) === -1) {
          this[this.length] = medium;
          this.length++;
        }
      },
      /**
       * @param {string} medium
       */
      deleteMedium: function(medium) {
        var index = Array.prototype.indexOf.call(this, medium);
        if (index !== -1) {
          Array.prototype.splice.call(this, index, 1);
        }
      }
    };
    exports.MediaList = CSSOM.MediaList;
  }
});

// node_modules/cssom/lib/CSSImportRule.js
var require_CSSImportRule = __commonJS({
  "node_modules/cssom/lib/CSSImportRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleSheet: require_CSSStyleSheet().CSSStyleSheet,
      MediaList: require_MediaList().MediaList
    };
    CSSOM.CSSImportRule = function CSSImportRule() {
      CSSOM.CSSRule.call(this);
      this.href = "";
      this.media = new CSSOM.MediaList();
      this.styleSheet = new CSSOM.CSSStyleSheet();
    };
    CSSOM.CSSImportRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSImportRule.prototype.constructor = CSSOM.CSSImportRule;
    CSSOM.CSSImportRule.prototype.type = 3;
    Object.defineProperty(CSSOM.CSSImportRule.prototype, "cssText", {
      get: function() {
        var mediaText = this.media.mediaText;
        return "@import url(" + this.href + ")" + (mediaText ? " " + mediaText : "") + ";";
      },
      set: function(cssText) {
        var i = 0;
        var state = "";
        var buffer = "";
        var index;
        for (var character; character = cssText.charAt(i); i++) {
          switch (character) {
            case " ":
            case "	":
            case "\r":
            case "\n":
            case "\f":
              if (state === "after-import") {
                state = "url";
              } else {
                buffer += character;
              }
              break;
            case "@":
              if (!state && cssText.indexOf("@import", i) === i) {
                state = "after-import";
                i += "import".length;
                buffer = "";
              }
              break;
            case "u":
              if (state === "url" && cssText.indexOf("url(", i) === i) {
                index = cssText.indexOf(")", i + 1);
                if (index === -1) {
                  throw i + ': ")" not found';
                }
                i += "url(".length;
                var url = cssText.slice(i, index);
                if (url[0] === url[url.length - 1]) {
                  if (url[0] === '"' || url[0] === "'") {
                    url = url.slice(1, -1);
                  }
                }
                this.href = url;
                i = index;
                state = "media";
              }
              break;
            case '"':
              if (state === "url") {
                index = cssText.indexOf('"', i + 1);
                if (!index) {
                  throw i + `: '"' not found`;
                }
                this.href = cssText.slice(i + 1, index);
                i = index;
                state = "media";
              }
              break;
            case "'":
              if (state === "url") {
                index = cssText.indexOf("'", i + 1);
                if (!index) {
                  throw i + `: "'" not found`;
                }
                this.href = cssText.slice(i + 1, index);
                i = index;
                state = "media";
              }
              break;
            case ";":
              if (state === "media") {
                if (buffer) {
                  this.media.mediaText = buffer.trim();
                }
              }
              break;
            default:
              if (state === "media") {
                buffer += character;
              }
              break;
          }
        }
      }
    });
    exports.CSSImportRule = CSSOM.CSSImportRule;
  }
});

// node_modules/cssom/lib/CSSGroupingRule.js
var require_CSSGroupingRule = __commonJS({
  "node_modules/cssom/lib/CSSGroupingRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSGroupingRule = function CSSGroupingRule() {
      CSSOM.CSSRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSGroupingRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSGroupingRule.prototype.constructor = CSSOM.CSSGroupingRule;
    CSSOM.CSSGroupingRule.prototype.insertRule = function insertRule(rule, index) {
      if (index < 0 || index > this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      var cssRule = CSSOM.parse(rule).cssRules[0];
      cssRule.parentRule = this;
      this.cssRules.splice(index, 0, cssRule);
      return index;
    };
    CSSOM.CSSGroupingRule.prototype.deleteRule = function deleteRule(index) {
      if (index < 0 || index >= this.cssRules.length) {
        throw new RangeError("INDEX_SIZE_ERR");
      }
      this.cssRules.splice(index, 1)[0].parentRule = null;
    };
    exports.CSSGroupingRule = CSSOM.CSSGroupingRule;
  }
});

// node_modules/cssom/lib/CSSConditionRule.js
var require_CSSConditionRule = __commonJS({
  "node_modules/cssom/lib/CSSConditionRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule
    };
    CSSOM.CSSConditionRule = function CSSConditionRule() {
      CSSOM.CSSGroupingRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSConditionRule.prototype = new CSSOM.CSSGroupingRule();
    CSSOM.CSSConditionRule.prototype.constructor = CSSOM.CSSConditionRule;
    CSSOM.CSSConditionRule.prototype.conditionText = "";
    CSSOM.CSSConditionRule.prototype.cssText = "";
    exports.CSSConditionRule = CSSOM.CSSConditionRule;
  }
});

// node_modules/cssom/lib/CSSMediaRule.js
var require_CSSMediaRule = __commonJS({
  "node_modules/cssom/lib/CSSMediaRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule,
      MediaList: require_MediaList().MediaList
    };
    CSSOM.CSSMediaRule = function CSSMediaRule() {
      CSSOM.CSSConditionRule.call(this);
      this.media = new CSSOM.MediaList();
    };
    CSSOM.CSSMediaRule.prototype = new CSSOM.CSSConditionRule();
    CSSOM.CSSMediaRule.prototype.constructor = CSSOM.CSSMediaRule;
    CSSOM.CSSMediaRule.prototype.type = 4;
    Object.defineProperties(CSSOM.CSSMediaRule.prototype, {
      "conditionText": {
        get: function() {
          return this.media.mediaText;
        },
        set: function(value) {
          this.media.mediaText = value;
        },
        configurable: true,
        enumerable: true
      },
      "cssText": {
        get: function() {
          var cssTexts = [];
          for (var i = 0, length = this.cssRules.length; i < length; i++) {
            cssTexts.push(this.cssRules[i].cssText);
          }
          return "@media " + this.media.mediaText + " {" + cssTexts.join("") + "}";
        },
        configurable: true,
        enumerable: true
      }
    });
    exports.CSSMediaRule = CSSOM.CSSMediaRule;
  }
});

// node_modules/cssom/lib/CSSSupportsRule.js
var require_CSSSupportsRule = __commonJS({
  "node_modules/cssom/lib/CSSSupportsRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule
    };
    CSSOM.CSSSupportsRule = function CSSSupportsRule() {
      CSSOM.CSSConditionRule.call(this);
    };
    CSSOM.CSSSupportsRule.prototype = new CSSOM.CSSConditionRule();
    CSSOM.CSSSupportsRule.prototype.constructor = CSSOM.CSSSupportsRule;
    CSSOM.CSSSupportsRule.prototype.type = 12;
    Object.defineProperty(CSSOM.CSSSupportsRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i = 0, length = this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
        }
        return "@supports " + this.conditionText + " {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSSupportsRule = CSSOM.CSSSupportsRule;
  }
});

// node_modules/cssom/lib/CSSFontFaceRule.js
var require_CSSFontFaceRule = __commonJS({
  "node_modules/cssom/lib/CSSFontFaceRule.js"(exports) {
    var CSSOM = {
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSFontFaceRule = function CSSFontFaceRule() {
      CSSOM.CSSRule.call(this);
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSFontFaceRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSFontFaceRule.prototype.constructor = CSSOM.CSSFontFaceRule;
    CSSOM.CSSFontFaceRule.prototype.type = 5;
    Object.defineProperty(CSSOM.CSSFontFaceRule.prototype, "cssText", {
      get: function() {
        return "@font-face {" + this.style.cssText + "}";
      }
    });
    exports.CSSFontFaceRule = CSSOM.CSSFontFaceRule;
  }
});

// node_modules/cssom/lib/CSSHostRule.js
var require_CSSHostRule = __commonJS({
  "node_modules/cssom/lib/CSSHostRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSHostRule = function CSSHostRule() {
      CSSOM.CSSRule.call(this);
      this.cssRules = [];
    };
    CSSOM.CSSHostRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSHostRule.prototype.constructor = CSSOM.CSSHostRule;
    CSSOM.CSSHostRule.prototype.type = 1001;
    Object.defineProperty(CSSOM.CSSHostRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i = 0, length = this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
        }
        return "@host {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSHostRule = CSSOM.CSSHostRule;
  }
});

// node_modules/cssom/lib/CSSKeyframeRule.js
var require_CSSKeyframeRule = __commonJS({
  "node_modules/cssom/lib/CSSKeyframeRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration
    };
    CSSOM.CSSKeyframeRule = function CSSKeyframeRule() {
      CSSOM.CSSRule.call(this);
      this.keyText = "";
      this.style = new CSSOM.CSSStyleDeclaration();
      this.style.parentRule = this;
    };
    CSSOM.CSSKeyframeRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSKeyframeRule.prototype.constructor = CSSOM.CSSKeyframeRule;
    CSSOM.CSSKeyframeRule.prototype.type = 8;
    Object.defineProperty(CSSOM.CSSKeyframeRule.prototype, "cssText", {
      get: function() {
        return this.keyText + " {" + this.style.cssText + "} ";
      }
    });
    exports.CSSKeyframeRule = CSSOM.CSSKeyframeRule;
  }
});

// node_modules/cssom/lib/CSSKeyframesRule.js
var require_CSSKeyframesRule = __commonJS({
  "node_modules/cssom/lib/CSSKeyframesRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule
    };
    CSSOM.CSSKeyframesRule = function CSSKeyframesRule() {
      CSSOM.CSSRule.call(this);
      this.name = "";
      this.cssRules = [];
    };
    CSSOM.CSSKeyframesRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSKeyframesRule.prototype.constructor = CSSOM.CSSKeyframesRule;
    CSSOM.CSSKeyframesRule.prototype.type = 7;
    Object.defineProperty(CSSOM.CSSKeyframesRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i = 0, length = this.cssRules.length; i < length; i++) {
          cssTexts.push("  " + this.cssRules[i].cssText);
        }
        return "@" + (this._vendorPrefix || "") + "keyframes " + this.name + " { \n" + cssTexts.join("\n") + "\n}";
      }
    });
    exports.CSSKeyframesRule = CSSOM.CSSKeyframesRule;
  }
});

// node_modules/cssom/lib/CSSValue.js
var require_CSSValue = __commonJS({
  "node_modules/cssom/lib/CSSValue.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSValue = function CSSValue() {
    };
    CSSOM.CSSValue.prototype = {
      constructor: CSSOM.CSSValue,
      // @see: http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSValue
      set cssText(text) {
        var name = this._getConstructorName();
        throw new Error('DOMException: property "cssText" of "' + name + '" is readonly and can not be replaced with "' + text + '"!');
      },
      get cssText() {
        var name = this._getConstructorName();
        throw new Error('getter "cssText" of "' + name + '" is not implemented!');
      },
      _getConstructorName: function() {
        var s = this.constructor.toString(), c = s.match(/function\s([^\(]+)/), name = c[1];
        return name;
      }
    };
    exports.CSSValue = CSSOM.CSSValue;
  }
});

// node_modules/cssom/lib/CSSValueExpression.js
var require_CSSValueExpression = __commonJS({
  "node_modules/cssom/lib/CSSValueExpression.js"(exports) {
    var CSSOM = {
      CSSValue: require_CSSValue().CSSValue
    };
    CSSOM.CSSValueExpression = function CSSValueExpression(token, idx) {
      this._token = token;
      this._idx = idx;
    };
    CSSOM.CSSValueExpression.prototype = new CSSOM.CSSValue();
    CSSOM.CSSValueExpression.prototype.constructor = CSSOM.CSSValueExpression;
    CSSOM.CSSValueExpression.prototype.parse = function() {
      var token = this._token, idx = this._idx;
      var character = "", expression = "", error = "", info, paren = [];
      for (; ; ++idx) {
        character = token.charAt(idx);
        if (character === "") {
          error = "css expression error: unfinished expression!";
          break;
        }
        switch (character) {
          case "(":
            paren.push(character);
            expression += character;
            break;
          case ")":
            paren.pop(character);
            expression += character;
            break;
          case "/":
            if (info = this._parseJSComment(token, idx)) {
              if (info.error) {
                error = "css expression error: unfinished comment in expression!";
              } else {
                idx = info.idx;
              }
            } else if (info = this._parseJSRexExp(token, idx)) {
              idx = info.idx;
              expression += info.text;
            } else {
              expression += character;
            }
            break;
          case "'":
          case '"':
            info = this._parseJSString(token, idx, character);
            if (info) {
              idx = info.idx;
              expression += info.text;
            } else {
              expression += character;
            }
            break;
          default:
            expression += character;
            break;
        }
        if (error) {
          break;
        }
        if (paren.length === 0) {
          break;
        }
      }
      var ret;
      if (error) {
        ret = {
          error
        };
      } else {
        ret = {
          idx,
          expression
        };
      }
      return ret;
    };
    CSSOM.CSSValueExpression.prototype._parseJSComment = function(token, idx) {
      var nextChar = token.charAt(idx + 1), text;
      if (nextChar === "/" || nextChar === "*") {
        var startIdx = idx, endIdx, commentEndChar;
        if (nextChar === "/") {
          commentEndChar = "\n";
        } else if (nextChar === "*") {
          commentEndChar = "*/";
        }
        endIdx = token.indexOf(commentEndChar, startIdx + 1 + 1);
        if (endIdx !== -1) {
          endIdx = endIdx + commentEndChar.length - 1;
          text = token.substring(idx, endIdx + 1);
          return {
            idx: endIdx,
            text
          };
        } else {
          var error = "css expression error: unfinished comment in expression!";
          return {
            error
          };
        }
      } else {
        return false;
      }
    };
    CSSOM.CSSValueExpression.prototype._parseJSString = function(token, idx, sep) {
      var endIdx = this._findMatchedIdx(token, idx, sep), text;
      if (endIdx === -1) {
        return false;
      } else {
        text = token.substring(idx, endIdx + sep.length);
        return {
          idx: endIdx,
          text
        };
      }
    };
    CSSOM.CSSValueExpression.prototype._parseJSRexExp = function(token, idx) {
      var before2 = token.substring(0, idx).replace(/\s+$/, ""), legalRegx = [
        /^$/,
        /\($/,
        /\[$/,
        /\!$/,
        /\+$/,
        /\-$/,
        /\*$/,
        /\/\s+/,
        /\%$/,
        /\=$/,
        /\>$/,
        /<$/,
        /\&$/,
        /\|$/,
        /\^$/,
        /\~$/,
        /\?$/,
        /\,$/,
        /delete$/,
        /in$/,
        /instanceof$/,
        /new$/,
        /typeof$/,
        /void$/
      ];
      var isLegal = legalRegx.some(function(reg) {
        return reg.test(before2);
      });
      if (!isLegal) {
        return false;
      } else {
        var sep = "/";
        return this._parseJSString(token, idx, sep);
      }
    };
    CSSOM.CSSValueExpression.prototype._findMatchedIdx = function(token, idx, sep) {
      var startIdx = idx, endIdx;
      var NOT_FOUND = -1;
      while (true) {
        endIdx = token.indexOf(sep, startIdx + 1);
        if (endIdx === -1) {
          endIdx = NOT_FOUND;
          break;
        } else {
          var text = token.substring(idx + 1, endIdx), matched = text.match(/\\+$/);
          if (!matched || matched[0] % 2 === 0) {
            break;
          } else {
            startIdx = endIdx;
          }
        }
      }
      var nextNewLineIdx = token.indexOf("\n", idx + 1);
      if (nextNewLineIdx < endIdx) {
        endIdx = NOT_FOUND;
      }
      return endIdx;
    };
    exports.CSSValueExpression = CSSOM.CSSValueExpression;
  }
});

// node_modules/cssom/lib/MatcherList.js
var require_MatcherList = __commonJS({
  "node_modules/cssom/lib/MatcherList.js"(exports) {
    var CSSOM = {};
    CSSOM.MatcherList = function MatcherList() {
      this.length = 0;
    };
    CSSOM.MatcherList.prototype = {
      constructor: CSSOM.MatcherList,
      /**
       * @return {string}
       */
      get matcherText() {
        return Array.prototype.join.call(this, ", ");
      },
      /**
       * @param {string} value
       */
      set matcherText(value) {
        var values = value.split(",");
        var length = this.length = values.length;
        for (var i = 0; i < length; i++) {
          this[i] = values[i].trim();
        }
      },
      /**
       * @param {string} matcher
       */
      appendMatcher: function(matcher) {
        if (Array.prototype.indexOf.call(this, matcher) === -1) {
          this[this.length] = matcher;
          this.length++;
        }
      },
      /**
       * @param {string} matcher
       */
      deleteMatcher: function(matcher) {
        var index = Array.prototype.indexOf.call(this, matcher);
        if (index !== -1) {
          Array.prototype.splice.call(this, index, 1);
        }
      }
    };
    exports.MatcherList = CSSOM.MatcherList;
  }
});

// node_modules/cssom/lib/CSSDocumentRule.js
var require_CSSDocumentRule = __commonJS({
  "node_modules/cssom/lib/CSSDocumentRule.js"(exports) {
    var CSSOM = {
      CSSRule: require_CSSRule().CSSRule,
      MatcherList: require_MatcherList().MatcherList
    };
    CSSOM.CSSDocumentRule = function CSSDocumentRule() {
      CSSOM.CSSRule.call(this);
      this.matcher = new CSSOM.MatcherList();
      this.cssRules = [];
    };
    CSSOM.CSSDocumentRule.prototype = new CSSOM.CSSRule();
    CSSOM.CSSDocumentRule.prototype.constructor = CSSOM.CSSDocumentRule;
    CSSOM.CSSDocumentRule.prototype.type = 10;
    Object.defineProperty(CSSOM.CSSDocumentRule.prototype, "cssText", {
      get: function() {
        var cssTexts = [];
        for (var i = 0, length = this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
        }
        return "@-moz-document " + this.matcher.matcherText + " {" + cssTexts.join("") + "}";
      }
    });
    exports.CSSDocumentRule = CSSOM.CSSDocumentRule;
  }
});

// node_modules/cssom/lib/parse.js
var require_parse = __commonJS({
  "node_modules/cssom/lib/parse.js"(exports) {
    var CSSOM = {};
    CSSOM.parse = function parse6(token) {
      var i = 0;
      var state = "before-selector";
      var index;
      var buffer = "";
      var valueParenthesisDepth = 0;
      var SIGNIFICANT_WHITESPACE = {
        "selector": true,
        "value": true,
        "value-parenthesis": true,
        "atRule": true,
        "importRule-begin": true,
        "importRule": true,
        "atBlock": true,
        "conditionBlock": true,
        "documentRule-begin": true
      };
      var styleSheet = new CSSOM.CSSStyleSheet();
      var currentScope = styleSheet;
      var parentRule;
      var ancestorRules = [];
      var hasAncestors = false;
      var prevScope;
      var name, priority = "", styleRule, mediaRule, supportsRule, importRule, fontFaceRule, keyframesRule, documentRule, hostRule;
      var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;
      var parseError = function(message) {
        var lines = token.substring(0, i).split("\n");
        var lineCount = lines.length;
        var charCount = lines.pop().length + 1;
        var error = new Error(message + " (line " + lineCount + ", char " + charCount + ")");
        error.line = lineCount;
        error["char"] = charCount;
        error.styleSheet = styleSheet;
        throw error;
      };
      for (var character; character = token.charAt(i); i++) {
        switch (character) {
          case " ":
          case "	":
          case "\r":
          case "\n":
          case "\f":
            if (SIGNIFICANT_WHITESPACE[state]) {
              buffer += character;
            }
            break;
          case '"':
            index = i + 1;
            do {
              index = token.indexOf('"', index) + 1;
              if (!index) {
                parseError('Unmatched "');
              }
            } while (token[index - 2] === "\\");
            buffer += token.slice(i, index);
            i = index - 1;
            switch (state) {
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            break;
          case "'":
            index = i + 1;
            do {
              index = token.indexOf("'", index) + 1;
              if (!index) {
                parseError("Unmatched '");
              }
            } while (token[index - 2] === "\\");
            buffer += token.slice(i, index);
            i = index - 1;
            switch (state) {
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            break;
          case "/":
            if (token.charAt(i + 1) === "*") {
              i += 2;
              index = token.indexOf("*/", i);
              if (index === -1) {
                parseError("Missing */");
              } else {
                i = index + 1;
              }
            } else {
              buffer += character;
            }
            if (state === "importRule-begin") {
              buffer += " ";
              state = "importRule";
            }
            break;
          case "@":
            if (token.indexOf("@-moz-document", i) === i) {
              state = "documentRule-begin";
              documentRule = new CSSOM.CSSDocumentRule();
              documentRule.__starts = i;
              i += "-moz-document".length;
              buffer = "";
              break;
            } else if (token.indexOf("@media", i) === i) {
              state = "atBlock";
              mediaRule = new CSSOM.CSSMediaRule();
              mediaRule.__starts = i;
              i += "media".length;
              buffer = "";
              break;
            } else if (token.indexOf("@supports", i) === i) {
              state = "conditionBlock";
              supportsRule = new CSSOM.CSSSupportsRule();
              supportsRule.__starts = i;
              i += "supports".length;
              buffer = "";
              break;
            } else if (token.indexOf("@host", i) === i) {
              state = "hostRule-begin";
              i += "host".length;
              hostRule = new CSSOM.CSSHostRule();
              hostRule.__starts = i;
              buffer = "";
              break;
            } else if (token.indexOf("@import", i) === i) {
              state = "importRule-begin";
              i += "import".length;
              buffer += "@import";
              break;
            } else if (token.indexOf("@font-face", i) === i) {
              state = "fontFaceRule-begin";
              i += "font-face".length;
              fontFaceRule = new CSSOM.CSSFontFaceRule();
              fontFaceRule.__starts = i;
              buffer = "";
              break;
            } else {
              atKeyframesRegExp.lastIndex = i;
              var matchKeyframes = atKeyframesRegExp.exec(token);
              if (matchKeyframes && matchKeyframes.index === i) {
                state = "keyframesRule-begin";
                keyframesRule = new CSSOM.CSSKeyframesRule();
                keyframesRule.__starts = i;
                keyframesRule._vendorPrefix = matchKeyframes[1];
                i += matchKeyframes[0].length - 1;
                buffer = "";
                break;
              } else if (state === "selector") {
                state = "atRule";
              }
            }
            buffer += character;
            break;
          case "{":
            if (state === "selector" || state === "atRule") {
              styleRule.selectorText = buffer.trim();
              styleRule.style.__starts = i;
              buffer = "";
              state = "before-name";
            } else if (state === "atBlock") {
              mediaRule.media.mediaText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = mediaRule;
              mediaRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "conditionBlock") {
              supportsRule.conditionText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = supportsRule;
              supportsRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "hostRule-begin") {
              if (parentRule) {
                ancestorRules.push(parentRule);
              }
              currentScope = parentRule = hostRule;
              hostRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            } else if (state === "fontFaceRule-begin") {
              if (parentRule) {
                fontFaceRule.parentRule = parentRule;
              }
              fontFaceRule.parentStyleSheet = styleSheet;
              styleRule = fontFaceRule;
              buffer = "";
              state = "before-name";
            } else if (state === "keyframesRule-begin") {
              keyframesRule.name = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
                keyframesRule.parentRule = parentRule;
              }
              keyframesRule.parentStyleSheet = styleSheet;
              currentScope = parentRule = keyframesRule;
              buffer = "";
              state = "keyframeRule-begin";
            } else if (state === "keyframeRule-begin") {
              styleRule = new CSSOM.CSSKeyframeRule();
              styleRule.keyText = buffer.trim();
              styleRule.__starts = i;
              buffer = "";
              state = "before-name";
            } else if (state === "documentRule-begin") {
              documentRule.matcher.matcherText = buffer.trim();
              if (parentRule) {
                ancestorRules.push(parentRule);
                documentRule.parentRule = parentRule;
              }
              currentScope = parentRule = documentRule;
              documentRule.parentStyleSheet = styleSheet;
              buffer = "";
              state = "before-selector";
            }
            break;
          case ":":
            if (state === "name") {
              name = buffer.trim();
              buffer = "";
              state = "before-value";
            } else {
              buffer += character;
            }
            break;
          case "(":
            if (state === "value") {
              if (buffer.trim() === "expression") {
                var info = new CSSOM.CSSValueExpression(token, i).parse();
                if (info.error) {
                  parseError(info.error);
                } else {
                  buffer += info.expression;
                  i = info.idx;
                }
              } else {
                state = "value-parenthesis";
                valueParenthesisDepth = 1;
                buffer += character;
              }
            } else if (state === "value-parenthesis") {
              valueParenthesisDepth++;
              buffer += character;
            } else {
              buffer += character;
            }
            break;
          case ")":
            if (state === "value-parenthesis") {
              valueParenthesisDepth--;
              if (valueParenthesisDepth === 0) state = "value";
            }
            buffer += character;
            break;
          case "!":
            if (state === "value" && token.indexOf("!important", i) === i) {
              priority = "important";
              i += "important".length;
            } else {
              buffer += character;
            }
            break;
          case ";":
            switch (state) {
              case "value":
                styleRule.style.setProperty(name, buffer.trim(), priority);
                priority = "";
                buffer = "";
                state = "before-name";
                break;
              case "atRule":
                buffer = "";
                state = "before-selector";
                break;
              case "importRule":
                importRule = new CSSOM.CSSImportRule();
                importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
                importRule.cssText = buffer + character;
                styleSheet.cssRules.push(importRule);
                buffer = "";
                state = "before-selector";
                break;
              default:
                buffer += character;
                break;
            }
            break;
          case "}":
            switch (state) {
              case "value":
                styleRule.style.setProperty(name, buffer.trim(), priority);
                priority = "";
              case "before-name":
              case "name":
                styleRule.__ends = i + 1;
                if (parentRule) {
                  styleRule.parentRule = parentRule;
                }
                styleRule.parentStyleSheet = styleSheet;
                currentScope.cssRules.push(styleRule);
                buffer = "";
                if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
                  state = "keyframeRule-begin";
                } else {
                  state = "before-selector";
                }
                break;
              case "keyframeRule-begin":
              case "before-selector":
              case "selector":
                if (!parentRule) {
                  parseError("Unexpected }");
                }
                hasAncestors = ancestorRules.length > 0;
                while (ancestorRules.length > 0) {
                  parentRule = ancestorRules.pop();
                  if (parentRule.constructor.name === "CSSMediaRule" || parentRule.constructor.name === "CSSSupportsRule") {
                    prevScope = currentScope;
                    currentScope = parentRule;
                    currentScope.cssRules.push(prevScope);
                    break;
                  }
                  if (ancestorRules.length === 0) {
                    hasAncestors = false;
                  }
                }
                if (!hasAncestors) {
                  currentScope.__ends = i + 1;
                  styleSheet.cssRules.push(currentScope);
                  currentScope = styleSheet;
                  parentRule = null;
                }
                buffer = "";
                state = "before-selector";
                break;
            }
            break;
          default:
            switch (state) {
              case "before-selector":
                state = "selector";
                styleRule = new CSSOM.CSSStyleRule();
                styleRule.__starts = i;
                break;
              case "before-name":
                state = "name";
                break;
              case "before-value":
                state = "value";
                break;
              case "importRule-begin":
                state = "importRule";
                break;
            }
            buffer += character;
            break;
        }
      }
      return styleSheet;
    };
    exports.parse = CSSOM.parse;
    CSSOM.CSSStyleSheet = require_CSSStyleSheet().CSSStyleSheet;
    CSSOM.CSSStyleRule = require_CSSStyleRule().CSSStyleRule;
    CSSOM.CSSImportRule = require_CSSImportRule().CSSImportRule;
    CSSOM.CSSGroupingRule = require_CSSGroupingRule().CSSGroupingRule;
    CSSOM.CSSMediaRule = require_CSSMediaRule().CSSMediaRule;
    CSSOM.CSSConditionRule = require_CSSConditionRule().CSSConditionRule;
    CSSOM.CSSSupportsRule = require_CSSSupportsRule().CSSSupportsRule;
    CSSOM.CSSFontFaceRule = require_CSSFontFaceRule().CSSFontFaceRule;
    CSSOM.CSSHostRule = require_CSSHostRule().CSSHostRule;
    CSSOM.CSSStyleDeclaration = require_CSSStyleDeclaration().CSSStyleDeclaration;
    CSSOM.CSSKeyframeRule = require_CSSKeyframeRule().CSSKeyframeRule;
    CSSOM.CSSKeyframesRule = require_CSSKeyframesRule().CSSKeyframesRule;
    CSSOM.CSSValueExpression = require_CSSValueExpression().CSSValueExpression;
    CSSOM.CSSDocumentRule = require_CSSDocumentRule().CSSDocumentRule;
  }
});

// node_modules/cssom/lib/CSSStyleDeclaration.js
var require_CSSStyleDeclaration = __commonJS({
  "node_modules/cssom/lib/CSSStyleDeclaration.js"(exports) {
    var CSSOM = {};
    CSSOM.CSSStyleDeclaration = function CSSStyleDeclaration2() {
      this.length = 0;
      this.parentRule = null;
      this._importants = {};
    };
    CSSOM.CSSStyleDeclaration.prototype = {
      constructor: CSSOM.CSSStyleDeclaration,
      /**
       *
       * @param {string} name
       * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-getPropertyValue
       * @return {string} the value of the property if it has been explicitly set for this declaration block.
       * Returns the empty string if the property has not been set.
       */
      getPropertyValue: function(name) {
        return this[name] || "";
      },
      /**
       *
       * @param {string} name
       * @param {string} value
       * @param {string} [priority=null] "important" or null
       * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-setProperty
       */
      setProperty: function(name, value, priority) {
        if (this[name]) {
          var index = Array.prototype.indexOf.call(this, name);
          if (index < 0) {
            this[this.length] = name;
            this.length++;
          }
        } else {
          this[this.length] = name;
          this.length++;
        }
        this[name] = value + "";
        this._importants[name] = priority;
      },
      /**
       *
       * @param {string} name
       * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-removeProperty
       * @return {string} the value of the property if it has been explicitly set for this declaration block.
       * Returns the empty string if the property has not been set or the property name does not correspond to a known CSS property.
       */
      removeProperty: function(name) {
        if (!(name in this)) {
          return "";
        }
        var index = Array.prototype.indexOf.call(this, name);
        if (index < 0) {
          return "";
        }
        var prevValue = this[name];
        this[name] = "";
        Array.prototype.splice.call(this, index, 1);
        return prevValue;
      },
      getPropertyCSSValue: function() {
      },
      /**
       *
       * @param {String} name
       */
      getPropertyPriority: function(name) {
        return this._importants[name] || "";
      },
      /**
       *   element.style.overflow = "auto"
       *   element.style.getPropertyShorthand("overflow-x")
       *   -> "overflow"
       */
      getPropertyShorthand: function() {
      },
      isPropertyImplicit: function() {
      },
      // Doesn't work in IE < 9
      get cssText() {
        var properties = [];
        for (var i = 0, length = this.length; i < length; ++i) {
          var name = this[i];
          var value = this.getPropertyValue(name);
          var priority = this.getPropertyPriority(name);
          if (priority) {
            priority = " !" + priority;
          }
          properties[i] = name + ": " + value + priority + ";";
        }
        return properties.join(" ");
      },
      set cssText(text) {
        var i, name;
        for (i = this.length; i--; ) {
          name = this[i];
          this[name] = "";
        }
        Array.prototype.splice.call(this, 0, this.length);
        this._importants = {};
        var dummyRule = CSSOM.parse("#bogus{" + text + "}").cssRules[0].style;
        var length = dummyRule.length;
        for (i = 0; i < length; ++i) {
          name = dummyRule[i];
          this.setProperty(dummyRule[i], dummyRule.getPropertyValue(name), dummyRule.getPropertyPriority(name));
        }
      }
    };
    exports.CSSStyleDeclaration = CSSOM.CSSStyleDeclaration;
    CSSOM.parse = require_parse().parse;
  }
});

// node_modules/cssom/lib/clone.js
var require_clone = __commonJS({
  "node_modules/cssom/lib/clone.js"(exports) {
    var CSSOM = {
      CSSStyleSheet: require_CSSStyleSheet().CSSStyleSheet,
      CSSRule: require_CSSRule().CSSRule,
      CSSStyleRule: require_CSSStyleRule().CSSStyleRule,
      CSSGroupingRule: require_CSSGroupingRule().CSSGroupingRule,
      CSSConditionRule: require_CSSConditionRule().CSSConditionRule,
      CSSMediaRule: require_CSSMediaRule().CSSMediaRule,
      CSSSupportsRule: require_CSSSupportsRule().CSSSupportsRule,
      CSSStyleDeclaration: require_CSSStyleDeclaration().CSSStyleDeclaration,
      CSSKeyframeRule: require_CSSKeyframeRule().CSSKeyframeRule,
      CSSKeyframesRule: require_CSSKeyframesRule().CSSKeyframesRule
    };
    CSSOM.clone = function clone(stylesheet) {
      var cloned = new CSSOM.CSSStyleSheet();
      var rules = stylesheet.cssRules;
      if (!rules) {
        return cloned;
      }
      for (var i = 0, rulesLength = rules.length; i < rulesLength; i++) {
        var rule = rules[i];
        var ruleClone = cloned.cssRules[i] = new rule.constructor();
        var style = rule.style;
        if (style) {
          var styleClone = ruleClone.style = new CSSOM.CSSStyleDeclaration();
          for (var j = 0, styleLength = style.length; j < styleLength; j++) {
            var name = styleClone[j] = style[j];
            styleClone[name] = style[name];
            styleClone._importants[name] = style.getPropertyPriority(name);
          }
          styleClone.length = style.length;
        }
        if (rule.hasOwnProperty("keyText")) {
          ruleClone.keyText = rule.keyText;
        }
        if (rule.hasOwnProperty("selectorText")) {
          ruleClone.selectorText = rule.selectorText;
        }
        if (rule.hasOwnProperty("mediaText")) {
          ruleClone.mediaText = rule.mediaText;
        }
        if (rule.hasOwnProperty("conditionText")) {
          ruleClone.conditionText = rule.conditionText;
        }
        if (rule.hasOwnProperty("cssRules")) {
          ruleClone.cssRules = clone(rule).cssRules;
        }
      }
      return cloned;
    };
    exports.clone = CSSOM.clone;
  }
});

// node_modules/cssom/lib/index.js
var require_lib = __commonJS({
  "node_modules/cssom/lib/index.js"(exports) {
    "use strict";
    exports.CSSStyleDeclaration = require_CSSStyleDeclaration().CSSStyleDeclaration;
    exports.CSSRule = require_CSSRule().CSSRule;
    exports.CSSGroupingRule = require_CSSGroupingRule().CSSGroupingRule;
    exports.CSSConditionRule = require_CSSConditionRule().CSSConditionRule;
    exports.CSSStyleRule = require_CSSStyleRule().CSSStyleRule;
    exports.MediaList = require_MediaList().MediaList;
    exports.CSSMediaRule = require_CSSMediaRule().CSSMediaRule;
    exports.CSSSupportsRule = require_CSSSupportsRule().CSSSupportsRule;
    exports.CSSImportRule = require_CSSImportRule().CSSImportRule;
    exports.CSSFontFaceRule = require_CSSFontFaceRule().CSSFontFaceRule;
    exports.CSSHostRule = require_CSSHostRule().CSSHostRule;
    exports.StyleSheet = require_StyleSheet().StyleSheet;
    exports.CSSStyleSheet = require_CSSStyleSheet().CSSStyleSheet;
    exports.CSSKeyframesRule = require_CSSKeyframesRule().CSSKeyframesRule;
    exports.CSSKeyframeRule = require_CSSKeyframeRule().CSSKeyframeRule;
    exports.MatcherList = require_MatcherList().MatcherList;
    exports.CSSDocumentRule = require_CSSDocumentRule().CSSDocumentRule;
    exports.CSSValue = require_CSSValue().CSSValue;
    exports.CSSValueExpression = require_CSSValueExpression().CSSValueExpression;
    exports.parse = require_parse().parse;
    exports.clone = require_clone().clone;
  }
});

// node_modules/linkedom/commonjs/canvas-shim.cjs
var require_canvas_shim = __commonJS({
  "node_modules/linkedom/commonjs/canvas-shim.cjs"(exports, module) {
    var Canvas2 = class {
      constructor(width, height) {
        this.width = width;
        this.height = height;
      }
      getContext() {
        return null;
      }
      toDataURL() {
        return "";
      }
    };
    module.exports = {
      createCanvas: (width, height) => new Canvas2(width, height)
    };
  }
});

// node_modules/linkedom/commonjs/canvas.cjs
var require_canvas = __commonJS({
  "node_modules/linkedom/commonjs/canvas.cjs"(exports, module) {
    try {
      module.exports = __require("canvas");
    } catch (fallback) {
      module.exports = require_canvas_shim();
    }
  }
});

// src/shim/empty.ts
var empty_exports = {};
__export(empty_exports, {
  default: () => empty_default
});
var empty_default;
var init_empty = __esm({
  "src/shim/empty.ts"() {
    "use strict";
    empty_default = {};
  }
});

// src/shim/url-empty.ts
var url_empty_exports = {};
__export(url_empty_exports, {
  fileURLToPath: () => fileURLToPath,
  pathToFileURL: () => pathToFileURL
});
function fileURLToPath(_url) {
  throw new Error("fileURLToPath is not available in browser bundle");
}
function pathToFileURL(_path) {
  throw new Error("pathToFileURL is not available in browser bundle");
}
var init_url_empty = __esm({
  "src/shim/url-empty.ts"() {
    "use strict";
  }
});

// node_modules/css/lib/parse/index.js
var require_parse2 = __commonJS({
  "node_modules/css/lib/parse/index.js"(exports, module) {
    var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    module.exports = function(css, options) {
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(/\n/g);
        if (lines) lineno += lines.length;
        var i = str.lastIndexOf("\n");
        column = ~i ? str.length - i : column + str.length;
      }
      function position() {
        var start = { line: lineno, column };
        return function(node) {
          node.position = new Position3(start);
          whitespace2();
          return node;
        };
      }
      function Position3(start) {
        this.start = start;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position3.prototype.content = css;
      var errorsList = [];
      function error(msg) {
        var err = new Error(options.source + ":" + lineno + ":" + column + ": " + msg);
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = css;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function stylesheet() {
        var rulesList = rules();
        return {
          type: "stylesheet",
          stylesheet: {
            source: options.source,
            rules: rulesList,
            parsingErrors: errorsList
          }
        };
      }
      function open() {
        return match(/^{\s*/);
      }
      function close() {
        return match(/^}/);
      }
      function rules() {
        var node;
        var rules2 = [];
        whitespace2();
        comments(rules2);
        while (css.length && css.charAt(0) != "}" && (node = atrule() || rule())) {
          if (node !== false) {
            rules2.push(node);
            comments(rules2);
          }
        }
        return rules2;
      }
      function match(re) {
        var m = re.exec(css);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        css = css.slice(str.length);
        return m;
      }
      function whitespace2() {
        match(/^\s*/);
      }
      function comments(rules2) {
        var c;
        rules2 = rules2 || [];
        while (c = comment()) {
          if (c !== false) {
            rules2.push(c);
          }
        }
        return rules2;
      }
      function comment() {
        var pos = position();
        if ("/" != css.charAt(0) || "*" != css.charAt(1)) return;
        var i = 2;
        while ("" != css.charAt(i) && ("*" != css.charAt(i) || "/" != css.charAt(i + 1))) ++i;
        i += 2;
        if ("" === css.charAt(i - 1)) {
          return error("End of comment missing");
        }
        var str = css.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        css = css.slice(i);
        column += 2;
        return pos({
          type: "comment",
          comment: str
        });
      }
      function selector() {
        var m = match(/^([^{]+)/);
        if (!m) return;
        return trim(m[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m2) {
          return m2.replace(/,/g, "\u200C");
        }).split(/\s*(?![^(]*\)),\s*/).map(function(s) {
          return s.replace(/\u200C/g, ",");
        });
      }
      function declaration() {
        var pos = position();
        var prop2 = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
        if (!prop2) return;
        prop2 = trim(prop2[0]);
        if (!match(/^:\s*/)) return error("property missing ':'");
        var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
        var ret = pos({
          type: "declaration",
          property: prop2.replace(commentre, ""),
          value: val ? trim(val[0]).replace(commentre, "") : ""
        });
        match(/^[;\s]*/);
        return ret;
      }
      function declarations() {
        var decls = [];
        if (!open()) return error("missing '{'");
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        if (!close()) return error("missing '}'");
        return decls;
      }
      function keyframe() {
        var m;
        var vals = [];
        var pos = position();
        while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
          vals.push(m[1]);
          match(/^,\s*/);
        }
        if (!vals.length) return;
        return pos({
          type: "keyframe",
          values: vals,
          declarations: declarations()
        });
      }
      function atkeyframes() {
        var pos = position();
        var m = match(/^@([-\w]+)?keyframes\s*/);
        if (!m) return;
        var vendor = m[1];
        var m = match(/^([-\w]+)\s*/);
        if (!m) return error("@keyframes missing name");
        var name = m[1];
        if (!open()) return error("@keyframes missing '{'");
        var frame;
        var frames = comments();
        while (frame = keyframe()) {
          frames.push(frame);
          frames = frames.concat(comments());
        }
        if (!close()) return error("@keyframes missing '}'");
        return pos({
          type: "keyframes",
          name,
          vendor,
          keyframes: frames
        });
      }
      function atsupports() {
        var pos = position();
        var m = match(/^@supports *([^{]+)/);
        if (!m) return;
        var supports = trim(m[1]);
        if (!open()) return error("@supports missing '{'");
        var style = comments().concat(rules());
        if (!close()) return error("@supports missing '}'");
        return pos({
          type: "supports",
          supports,
          rules: style
        });
      }
      function athost() {
        var pos = position();
        var m = match(/^@host\s*/);
        if (!m) return;
        if (!open()) return error("@host missing '{'");
        var style = comments().concat(rules());
        if (!close()) return error("@host missing '}'");
        return pos({
          type: "host",
          rules: style
        });
      }
      function atmedia() {
        var pos = position();
        var m = match(/^@media *([^{]+)/);
        if (!m) return;
        var media = trim(m[1]);
        if (!open()) return error("@media missing '{'");
        var style = comments().concat(rules());
        if (!close()) return error("@media missing '}'");
        return pos({
          type: "media",
          media,
          rules: style
        });
      }
      function atcustommedia() {
        var pos = position();
        var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
        if (!m) return;
        return pos({
          type: "custom-media",
          name: trim(m[1]),
          media: trim(m[2])
        });
      }
      function atpage() {
        var pos = position();
        var m = match(/^@page */);
        if (!m) return;
        var sel = selector() || [];
        if (!open()) return error("@page missing '{'");
        var decls = comments();
        var decl;
        while (decl = declaration()) {
          decls.push(decl);
          decls = decls.concat(comments());
        }
        if (!close()) return error("@page missing '}'");
        return pos({
          type: "page",
          selectors: sel,
          declarations: decls
        });
      }
      function atdocument() {
        var pos = position();
        var m = match(/^@([-\w]+)?document *([^{]+)/);
        if (!m) return;
        var vendor = trim(m[1]);
        var doc = trim(m[2]);
        if (!open()) return error("@document missing '{'");
        var style = comments().concat(rules());
        if (!close()) return error("@document missing '}'");
        return pos({
          type: "document",
          document: doc,
          vendor,
          rules: style
        });
      }
      function atfontface() {
        var pos = position();
        var m = match(/^@font-face\s*/);
        if (!m) return;
        if (!open()) return error("@font-face missing '{'");
        var decls = comments();
        var decl;
        while (decl = declaration()) {
          decls.push(decl);
          decls = decls.concat(comments());
        }
        if (!close()) return error("@font-face missing '}'");
        return pos({
          type: "font-face",
          declarations: decls
        });
      }
      var atimport = _compileAtrule("import");
      var atcharset = _compileAtrule("charset");
      var atnamespace = _compileAtrule("namespace");
      function _compileAtrule(name) {
        var re = new RegExp("^@" + name + "\\s*([^;]+);");
        return function() {
          var pos = position();
          var m = match(re);
          if (!m) return;
          var ret = { type: name };
          ret[name] = m[1].trim();
          return pos(ret);
        };
      }
      function atrule() {
        if (css[0] != "@") return;
        return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
      }
      function rule() {
        var pos = position();
        var sel = selector();
        if (!sel) return error("selector missing");
        comments();
        return pos({
          type: "rule",
          selectors: sel,
          declarations: declarations()
        });
      }
      return addParent(stylesheet());
    };
    function trim(str) {
      return str ? str.replace(/^\s+|\s+$/g, "") : "";
    }
    function addParent(obj, parent) {
      var isNode2 = obj && typeof obj.type === "string";
      var childParent = isNode2 ? obj : parent;
      for (var k in obj) {
        var value = obj[k];
        if (Array.isArray(value)) {
          value.forEach(function(v) {
            addParent(v, childParent);
          });
        } else if (value && typeof value === "object") {
          addParent(value, childParent);
        }
      }
      if (isNode2) {
        Object.defineProperty(obj, "parent", {
          configurable: true,
          writable: true,
          enumerable: false,
          value: parent || null
        });
      }
      return obj;
    }
  }
});

// node_modules/css/lib/stringify/compiler.js
var require_compiler = __commonJS({
  "node_modules/css/lib/stringify/compiler.js"(exports, module) {
    module.exports = Compiler;
    function Compiler(opts) {
      this.options = opts || {};
    }
    Compiler.prototype.emit = function(str) {
      return str;
    };
    Compiler.prototype.visit = function(node) {
      return this[node.type](node);
    };
    Compiler.prototype.mapVisit = function(nodes, delim) {
      var buf = "";
      delim = delim || "";
      for (var i = 0, length = nodes.length; i < length; i++) {
        buf += this.visit(nodes[i]);
        if (delim && i < length - 1) buf += this.emit(delim);
      }
      return buf;
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/css/lib/stringify/compress.js
var require_compress = __commonJS({
  "node_modules/css/lib/stringify/compress.js"(exports, module) {
    var Base = require_compiler();
    var inherits = require_inherits_browser();
    module.exports = Compiler;
    function Compiler(options) {
      Base.call(this, options);
    }
    inherits(Compiler, Base);
    Compiler.prototype.compile = function(node) {
      return node.stylesheet.rules.map(this.visit, this).join("");
    };
    Compiler.prototype.comment = function(node) {
      return this.emit("", node.position);
    };
    Compiler.prototype.import = function(node) {
      return this.emit("@import " + node.import + ";", node.position);
    };
    Compiler.prototype.media = function(node) {
      return this.emit("@media " + node.media, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
    };
    Compiler.prototype.document = function(node) {
      var doc = "@" + (node.vendor || "") + "document " + node.document;
      return this.emit(doc, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
    };
    Compiler.prototype.charset = function(node) {
      return this.emit("@charset " + node.charset + ";", node.position);
    };
    Compiler.prototype.namespace = function(node) {
      return this.emit("@namespace " + node.namespace + ";", node.position);
    };
    Compiler.prototype.supports = function(node) {
      return this.emit("@supports " + node.supports, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
    };
    Compiler.prototype.keyframes = function(node) {
      return this.emit("@" + (node.vendor || "") + "keyframes " + node.name, node.position) + this.emit("{") + this.mapVisit(node.keyframes) + this.emit("}");
    };
    Compiler.prototype.keyframe = function(node) {
      var decls = node.declarations;
      return this.emit(node.values.join(","), node.position) + this.emit("{") + this.mapVisit(decls) + this.emit("}");
    };
    Compiler.prototype.page = function(node) {
      var sel = node.selectors.length ? node.selectors.join(", ") : "";
      return this.emit("@page " + sel, node.position) + this.emit("{") + this.mapVisit(node.declarations) + this.emit("}");
    };
    Compiler.prototype["font-face"] = function(node) {
      return this.emit("@font-face", node.position) + this.emit("{") + this.mapVisit(node.declarations) + this.emit("}");
    };
    Compiler.prototype.host = function(node) {
      return this.emit("@host", node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
    };
    Compiler.prototype["custom-media"] = function(node) {
      return this.emit("@custom-media " + node.name + " " + node.media + ";", node.position);
    };
    Compiler.prototype.rule = function(node) {
      var decls = node.declarations;
      if (!decls.length) return "";
      return this.emit(node.selectors.join(","), node.position) + this.emit("{") + this.mapVisit(decls) + this.emit("}");
    };
    Compiler.prototype.declaration = function(node) {
      return this.emit(node.property + ":" + node.value, node.position) + this.emit(";");
    };
  }
});

// node_modules/css/lib/stringify/identity.js
var require_identity = __commonJS({
  "node_modules/css/lib/stringify/identity.js"(exports, module) {
    var Base = require_compiler();
    var inherits = require_inherits_browser();
    module.exports = Compiler;
    function Compiler(options) {
      options = options || {};
      Base.call(this, options);
      this.indentation = options.indent;
    }
    inherits(Compiler, Base);
    Compiler.prototype.compile = function(node) {
      return this.stylesheet(node);
    };
    Compiler.prototype.stylesheet = function(node) {
      return this.mapVisit(node.stylesheet.rules, "\n\n");
    };
    Compiler.prototype.comment = function(node) {
      return this.emit(this.indent() + "/*" + node.comment + "*/", node.position);
    };
    Compiler.prototype.import = function(node) {
      return this.emit("@import " + node.import + ";", node.position);
    };
    Compiler.prototype.media = function(node) {
      return this.emit("@media " + node.media, node.position) + this.emit(
        " {\n" + this.indent(1)
      ) + this.mapVisit(node.rules, "\n\n") + this.emit(
        this.indent(-1) + "\n}"
      );
    };
    Compiler.prototype.document = function(node) {
      var doc = "@" + (node.vendor || "") + "document " + node.document;
      return this.emit(doc, node.position) + this.emit(
        "  {\n" + this.indent(1)
      ) + this.mapVisit(node.rules, "\n\n") + this.emit(
        this.indent(-1) + "\n}"
      );
    };
    Compiler.prototype.charset = function(node) {
      return this.emit("@charset " + node.charset + ";", node.position);
    };
    Compiler.prototype.namespace = function(node) {
      return this.emit("@namespace " + node.namespace + ";", node.position);
    };
    Compiler.prototype.supports = function(node) {
      return this.emit("@supports " + node.supports, node.position) + this.emit(
        " {\n" + this.indent(1)
      ) + this.mapVisit(node.rules, "\n\n") + this.emit(
        this.indent(-1) + "\n}"
      );
    };
    Compiler.prototype.keyframes = function(node) {
      return this.emit("@" + (node.vendor || "") + "keyframes " + node.name, node.position) + this.emit(
        " {\n" + this.indent(1)
      ) + this.mapVisit(node.keyframes, "\n") + this.emit(
        this.indent(-1) + "}"
      );
    };
    Compiler.prototype.keyframe = function(node) {
      var decls = node.declarations;
      return this.emit(this.indent()) + this.emit(node.values.join(", "), node.position) + this.emit(
        " {\n" + this.indent(1)
      ) + this.mapVisit(decls, "\n") + this.emit(
        this.indent(-1) + "\n" + this.indent() + "}\n"
      );
    };
    Compiler.prototype.page = function(node) {
      var sel = node.selectors.length ? node.selectors.join(", ") + " " : "";
      return this.emit("@page " + sel, node.position) + this.emit("{\n") + this.emit(this.indent(1)) + this.mapVisit(node.declarations, "\n") + this.emit(this.indent(-1)) + this.emit("\n}");
    };
    Compiler.prototype["font-face"] = function(node) {
      return this.emit("@font-face ", node.position) + this.emit("{\n") + this.emit(this.indent(1)) + this.mapVisit(node.declarations, "\n") + this.emit(this.indent(-1)) + this.emit("\n}");
    };
    Compiler.prototype.host = function(node) {
      return this.emit("@host", node.position) + this.emit(
        " {\n" + this.indent(1)
      ) + this.mapVisit(node.rules, "\n\n") + this.emit(
        this.indent(-1) + "\n}"
      );
    };
    Compiler.prototype["custom-media"] = function(node) {
      return this.emit("@custom-media " + node.name + " " + node.media + ";", node.position);
    };
    Compiler.prototype.rule = function(node) {
      var indent = this.indent();
      var decls = node.declarations;
      if (!decls.length) return "";
      return this.emit(node.selectors.map(function(s) {
        return indent + s;
      }).join(",\n"), node.position) + this.emit(" {\n") + this.emit(this.indent(1)) + this.mapVisit(decls, "\n") + this.emit(this.indent(-1)) + this.emit("\n" + this.indent() + "}");
    };
    Compiler.prototype.declaration = function(node) {
      return this.emit(this.indent()) + this.emit(node.property + ": " + node.value, node.position) + this.emit(";");
    };
    Compiler.prototype.indent = function(level) {
      this.level = this.level || 1;
      if (null != level) {
        this.level += level;
        return "";
      }
      return Array(this.level).join(this.indentation || "  ");
    };
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key2 = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key2) ? this._sourcesContents[key2] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order2 = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order2) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/atob/browser-atob.js
var require_browser_atob = __commonJS({
  "node_modules/atob/browser-atob.js"(exports, module) {
    (function(w) {
      "use strict";
      function findBest(atobNative) {
        if ("function" === typeof atobNative) {
          return atobNative;
        }
        if ("function" === typeof Buffer) {
          return function atobBrowserify(a) {
            return new Buffer(a, "base64").toString("binary");
          };
        }
        if ("object" === typeof w.base64js) {
          return function atobWebWorker_iOS(a) {
            var buf = w.base64js.b64ToByteArray(a);
            return Array.prototype.map.call(buf, function(ch) {
              return String.fromCharCode(ch);
            }).join("");
          };
        }
        return function() {
          throw new Error("You're probably in an old browser or an iOS webworker. It might help to include beatgammit's base64-js.");
        };
      }
      var atobBest = findBest(w.atob);
      w.atob = atobBest;
      if (typeof module === "object" && module && module.exports) {
        module.exports = atobBest;
      }
    })(window);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries2 = Object.keys(replaceMap);
      for (var i = 0; i < entries2.length; i++) {
        var key2 = entries2[i];
        input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/source-map-resolve/index.js
var require_source_map_resolve = __commonJS({
  "node_modules/source-map-resolve/index.js"(exports, module) {
    var atob = require_browser_atob();
    var urlLib = (init_url_empty(), __toCommonJS(url_empty_exports));
    var pathLib = (init_empty(), __toCommonJS(empty_exports));
    var decodeUriComponentLib = require_decode_uri_component();
    function resolveUrl() {
      return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {
        return urlLib.resolve(resolved, nextUrl);
      });
    }
    function convertWindowsPath(aPath) {
      return pathLib.sep === "\\" ? aPath.replace(/\\/g, "/").replace(/^[a-z]:\/?/i, "/") : aPath;
    }
    function customDecodeUriComponent(string) {
      return decodeUriComponentLib(string.replace(/\+/g, "%2B"));
    }
    function callbackAsync(callback, error, result) {
      setImmediate(function() {
        callback(error, result);
      });
    }
    function parseMapToJSON(string, data) {
      try {
        return JSON.parse(string.replace(/^\)\]\}'/, ""));
      } catch (error) {
        error.sourceMapData = data;
        throw error;
      }
    }
    function readSync(read, url, data) {
      var readUrl = customDecodeUriComponent(url);
      try {
        return String(read(readUrl));
      } catch (error) {
        error.sourceMapData = data;
        throw error;
      }
    }
    var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/;
    var sourceMappingURLRegex = RegExp(
      "(?:/\\*(?:\\s*\r?\n(?://)?)?(?:" + innerRegex.source + ")\\s*\\*/|//(?:" + innerRegex.source + "))\\s*"
    );
    function getSourceMappingUrl(code) {
      var match = code.match(sourceMappingURLRegex);
      return match ? match[1] || match[2] || "" : null;
    }
    function resolveSourceMap(code, codeUrl, read, callback) {
      var mapData;
      try {
        mapData = resolveSourceMapHelper(code, codeUrl);
      } catch (error) {
        return callbackAsync(callback, error);
      }
      if (!mapData || mapData.map) {
        return callbackAsync(callback, null, mapData);
      }
      var readUrl = customDecodeUriComponent(mapData.url);
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = mapData;
          return callback(error);
        }
        mapData.map = String(result);
        try {
          mapData.map = parseMapToJSON(mapData.map, mapData);
        } catch (error2) {
          return callback(error2);
        }
        callback(null, mapData);
      });
    }
    function resolveSourceMapSync(code, codeUrl, read) {
      var mapData = resolveSourceMapHelper(code, codeUrl);
      if (!mapData || mapData.map) {
        return mapData;
      }
      mapData.map = readSync(read, mapData.url, mapData);
      mapData.map = parseMapToJSON(mapData.map, mapData);
      return mapData;
    }
    var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;
    var jsonMimeTypeRegex = /^(?:application|text)\/json$/;
    var jsonCharacterEncoding = "utf-8";
    function base64ToBuf(b64) {
      var binStr = atob(b64);
      var len = binStr.length;
      var arr = new Uint8Array(len);
      for (var i = 0; i < len; i++) {
        arr[i] = binStr.charCodeAt(i);
      }
      return arr;
    }
    function decodeBase64String(b64) {
      if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
        return atob(b64);
      }
      var buf = base64ToBuf(b64);
      var decoder = new TextDecoder(jsonCharacterEncoding, { fatal: true });
      return decoder.decode(buf);
    }
    function resolveSourceMapHelper(code, codeUrl) {
      codeUrl = convertWindowsPath(codeUrl);
      var url = getSourceMappingUrl(code);
      if (!url) {
        return null;
      }
      var dataUri = url.match(dataUriRegex);
      if (dataUri) {
        var mimeType = dataUri[1] || "text/plain";
        var lastParameter = dataUri[2] || "";
        var encoded = dataUri[3] || "";
        var data = {
          sourceMappingURL: url,
          url: null,
          sourcesRelativeTo: codeUrl,
          map: encoded
        };
        if (!jsonMimeTypeRegex.test(mimeType)) {
          var error = new Error("Unuseful data uri mime type: " + mimeType);
          error.sourceMapData = data;
          throw error;
        }
        try {
          data.map = parseMapToJSON(
            lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded),
            data
          );
        } catch (error2) {
          error2.sourceMapData = data;
          throw error2;
        }
        return data;
      }
      var mapUrl = resolveUrl(codeUrl, url);
      return {
        sourceMappingURL: url,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      };
    }
    function resolveSources(map, mapUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      var pending = map.sources ? map.sources.length : 0;
      var result = {
        sourcesResolved: [],
        sourcesContent: []
      };
      if (pending === 0) {
        callbackAsync(callback, null, result);
        return;
      }
      var done = function() {
        pending--;
        if (pending === 0) {
          callback(null, result);
        }
      };
      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl;
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent;
          callbackAsync(done, null);
        } else {
          var readUrl = customDecodeUriComponent(fullUrl);
          read(readUrl, function(error, source) {
            result.sourcesContent[index] = error ? error : String(source);
            done();
          });
        }
      });
    }
    function resolveSourcesSync(map, mapUrl, read, options) {
      var result = {
        sourcesResolved: [],
        sourcesContent: []
      };
      if (!map.sources || map.sources.length === 0) {
        return result;
      }
      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl;
        if (read !== null) {
          if (typeof sourceContent === "string") {
            result.sourcesContent[index] = sourceContent;
          } else {
            var readUrl = customDecodeUriComponent(fullUrl);
            try {
              result.sourcesContent[index] = String(read(readUrl));
            } catch (error) {
              result.sourcesContent[index] = error;
            }
          }
        }
      });
      return result;
    }
    var endingSlash = /\/?$/;
    function resolveSourcesHelper(map, mapUrl, options, fn) {
      options = options || {};
      mapUrl = convertWindowsPath(mapUrl);
      var fullUrl;
      var sourceContent;
      var sourceRoot;
      for (var index = 0, len = map.sources.length; index < len; index++) {
        sourceRoot = null;
        if (typeof options.sourceRoot === "string") {
          sourceRoot = options.sourceRoot;
        } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
          sourceRoot = map.sourceRoot;
        }
        if (sourceRoot === null || sourceRoot === "") {
          fullUrl = resolveUrl(mapUrl, map.sources[index]);
        } else {
          fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index]);
        }
        sourceContent = (map.sourcesContent || [])[index];
        fn(fullUrl, sourceContent, index);
      }
    }
    function resolve(code, codeUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (code === null) {
        var mapUrl = codeUrl;
        var data = {
          sourceMappingURL: null,
          url: mapUrl,
          sourcesRelativeTo: mapUrl,
          map: null
        };
        var readUrl = customDecodeUriComponent(mapUrl);
        read(readUrl, function(error, result) {
          if (error) {
            error.sourceMapData = data;
            return callback(error);
          }
          data.map = String(result);
          try {
            data.map = parseMapToJSON(data.map, data);
          } catch (error2) {
            return callback(error2);
          }
          _resolveSources(data);
        });
      } else {
        resolveSourceMap(code, codeUrl, read, function(error, mapData) {
          if (error) {
            return callback(error);
          }
          if (!mapData) {
            return callback(null, null);
          }
          _resolveSources(mapData);
        });
      }
      function _resolveSources(mapData) {
        resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
          if (error) {
            return callback(error);
          }
          mapData.sourcesResolved = result.sourcesResolved;
          mapData.sourcesContent = result.sourcesContent;
          callback(null, mapData);
        });
      }
    }
    function resolveSync(code, codeUrl, read, options) {
      var mapData;
      if (code === null) {
        var mapUrl = codeUrl;
        mapData = {
          sourceMappingURL: null,
          url: mapUrl,
          sourcesRelativeTo: mapUrl,
          map: null
        };
        mapData.map = readSync(read, mapUrl, mapData);
        mapData.map = parseMapToJSON(mapData.map, mapData);
      } else {
        mapData = resolveSourceMapSync(code, codeUrl, read);
        if (!mapData) {
          return null;
        }
      }
      var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);
      mapData.sourcesResolved = result.sourcesResolved;
      mapData.sourcesContent = result.sourcesContent;
      return mapData;
    }
    module.exports = {
      resolveSourceMap,
      resolveSourceMapSync,
      resolveSources,
      resolveSourcesSync,
      resolve,
      resolveSync,
      parseMapToJSON
    };
  }
});

// src/shim/fs-empty.ts
var fs_empty_exports = {};
__export(fs_empty_exports, {
  default: () => fs_empty_default,
  readFileSync: () => readFileSync
});
function readFileSync(_path) {
  throw new Error("readFileSync is not available in browser bundle");
}
var fs_empty_default;
var init_fs_empty = __esm({
  "src/shim/fs-empty.ts"() {
    "use strict";
    fs_empty_default = {};
  }
});

// node_modules/css/lib/stringify/source-map-support.js
var require_source_map_support = __commonJS({
  "node_modules/css/lib/stringify/source-map-support.js"(exports, module) {
    var SourceMap = require_source_map().SourceMapGenerator;
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var sourceMapResolve = require_source_map_resolve();
    var fs = (init_fs_empty(), __toCommonJS(fs_empty_exports));
    var path = (init_empty(), __toCommonJS(empty_exports));
    module.exports = mixin;
    var makeFriendlyPath = function(aPath) {
      return path.sep === "\\" ? aPath.replace(/\\/g, "/").replace(/^[a-z]:\/?/i, "/") : aPath;
    };
    function mixin(compiler) {
      compiler._comment = compiler.comment;
      compiler.map = new SourceMap();
      compiler.position = { line: 1, column: 1 };
      compiler.files = {};
      for (var k in exports) compiler[k] = exports[k];
    }
    exports.updatePosition = function(str) {
      var lines = str.match(/\n/g);
      if (lines) this.position.line += lines.length;
      var i = str.lastIndexOf("\n");
      this.position.column = ~i ? str.length - i : this.position.column + str.length;
    };
    exports.emit = function(str, pos) {
      if (pos) {
        var sourceFile = makeFriendlyPath(pos.source || "source.css");
        this.map.addMapping({
          source: sourceFile,
          generated: {
            line: this.position.line,
            column: Math.max(this.position.column - 1, 0)
          },
          original: {
            line: pos.start.line,
            column: pos.start.column - 1
          }
        });
        this.addFile(sourceFile, pos);
      }
      this.updatePosition(str);
      return str;
    };
    exports.addFile = function(file, pos) {
      if (typeof pos.content !== "string") return;
      if (Object.prototype.hasOwnProperty.call(this.files, file)) return;
      this.files[file] = pos.content;
    };
    exports.applySourceMaps = function() {
      Object.keys(this.files).forEach(function(file) {
        var content = this.files[file];
        this.map.setSourceContent(file, content);
        if (this.options.inputSourcemaps !== false) {
          var originalMap = sourceMapResolve.resolveSync(
            content,
            file,
            fs.readFileSync
          );
          if (originalMap) {
            var map = new SourceMapConsumer(originalMap.map);
            var relativeTo = originalMap.sourcesRelativeTo;
            this.map.applySourceMap(map, file, makeFriendlyPath(path.dirname(relativeTo)));
          }
        }
      }, this);
    };
    exports.comment = function(node) {
      if (/^# sourceMappingURL=/.test(node.comment))
        return this.emit("", node.position);
      else
        return this._comment(node);
    };
  }
});

// node_modules/css/lib/stringify/index.js
var require_stringify = __commonJS({
  "node_modules/css/lib/stringify/index.js"(exports, module) {
    var Compressed = require_compress();
    var Identity = require_identity();
    module.exports = function(node, options) {
      options = options || {};
      var compiler = options.compress ? new Compressed(options) : new Identity(options);
      if (options.sourcemap) {
        var sourcemaps = require_source_map_support();
        sourcemaps(compiler);
        var code = compiler.compile(node);
        compiler.applySourceMaps();
        var map = options.sourcemap === "generator" ? compiler.map : compiler.map.toJSON();
        return { code, map };
      }
      var code = compiler.compile(node);
      return code;
    };
  }
});

// node_modules/css/index.js
var require_css = __commonJS({
  "node_modules/css/index.js"(exports) {
    exports.parse = require_parse2();
    exports.stringify = require_stringify();
  }
});

// src/shim/zlib-empty.ts
var zlib_empty_exports = {};
__export(zlib_empty_exports, {
  brotliDecompressSync: () => brotliDecompressSync,
  default: () => zlib_empty_default,
  inflateSync: () => inflateSync
});
function inflateSync(_data) {
  throw new Error("inflateSync is not available in browser bundle");
}
function brotliDecompressSync(_data) {
  throw new Error("brotliDecompressSync is not available in browser bundle");
}
var zlib_empty_default;
var init_zlib_empty = __esm({
  "src/shim/zlib-empty.ts"() {
    "use strict";
    zlib_empty_default = {};
  }
});

// src/fonts/woff/decoder.ts
var decoder_exports = {};
__export(decoder_exports, {
  decodeWoff: () => decodeWoff
});
function readUInt32(view, offset) {
  return view.getUint32(offset, false);
}
function readUInt16(view, offset) {
  return view.getUint16(offset, false);
}
function tagToString(tag) {
  return String.fromCharCode(
    tag >> 24 & 255,
    tag >> 16 & 255,
    tag >> 8 & 255,
    tag & 255
  );
}
function decodeWoff(fontData) {
  if (fontData.byteLength < WOFF_HEADER_SIZE) {
    throw new Error("Invalid WOFF: file too short");
  }
  const view = new DataView(
    fontData.buffer,
    fontData.byteOffset,
    fontData.byteLength
  );
  const signature = readUInt32(view, 0);
  if (signature !== WOFF_SIGNATURE) {
    throw new Error("Invalid WOFF signature");
  }
  const flavor = readUInt32(view, 4) >>> 0;
  const reportedLength = readUInt32(view, 8);
  if (reportedLength !== fontData.byteLength) {
    throw new Error("Invalid WOFF: length mismatch");
  }
  const numTables = readUInt16(view, 12);
  const totalSfntSize = readUInt32(view, 16);
  if (numTables === 0 || totalSfntSize === 0) {
    throw new Error("Invalid WOFF: missing tables");
  }
  const directoryOffset = WOFF_HEADER_SIZE;
  const directoryLength = numTables * TABLE_DIR_ENTRY_SIZE;
  if (directoryOffset + directoryLength > fontData.byteLength) {
    throw new Error("Invalid WOFF: truncated directory");
  }
  const tables = {};
  for (let i = 0; i < numTables; i++) {
    const entryOffset = directoryOffset + i * TABLE_DIR_ENTRY_SIZE;
    const tag = readUInt32(view, entryOffset);
    const offset = readUInt32(view, entryOffset + 4);
    const compLength = readUInt32(view, entryOffset + 8);
    const origLength = readUInt32(view, entryOffset + 12);
    if (offset + compLength > fontData.byteLength) {
      throw new Error("Invalid WOFF: table outside bounds");
    }
    const compressedSlice = fontData.subarray(offset, offset + compLength);
    let tableData;
    if (compLength !== origLength) {
      const inflated = inflateSync(compressedSlice);
      if (inflated.byteLength !== origLength) {
        throw new Error("Invalid WOFF: decompressed size mismatch");
      }
      tableData = new Uint8Array(inflated);
    } else {
      tableData = new Uint8Array(origLength);
      tableData.set(compressedSlice.subarray(0, origLength));
    }
    const tagString = tagToString(tag);
    tables[tagString] = tableData;
  }
  return {
    flavor,
    numTables,
    tables
  };
}
var WOFF_SIGNATURE, WOFF_HEADER_SIZE, TABLE_DIR_ENTRY_SIZE;
var init_decoder = __esm({
  "src/fonts/woff/decoder.ts"() {
    "use strict";
    init_zlib_empty();
    WOFF_SIGNATURE = 2001684038;
    WOFF_HEADER_SIZE = 44;
    TABLE_DIR_ENTRY_SIZE = 20;
  }
});

// src/fonts/woff2/buffer.ts
function readBase128(buf) {
  let result = 0;
  for (let i = 0; i < 5; i++) {
    const code = buf.readU8();
    if (i === 0 && code === 128) {
      throw new Error("Invalid Base128: leading zero");
    }
    if (result & 4261412864) {
      throw new Error("Base128 overflow");
    }
    result = result << 7 | code & 127;
    if ((code & 128) === 0) {
      return result >>> 0;
    }
  }
  throw new Error("Base128 exceeds 5 bytes");
}
function read255UShort(buf) {
  const code = buf.readU8();
  const LOWEST_UCODE = 253;
  if (code === 253) {
    return buf.readU16();
  }
  if (code === 255) {
    return LOWEST_UCODE + buf.readU8();
  }
  if (code === 254) {
    return LOWEST_UCODE * 2 + buf.readU8();
  }
  return code;
}
var Buf;
var init_buffer = __esm({
  "src/fonts/woff2/buffer.ts"() {
    "use strict";
    Buf = class {
      constructor(data, offset = 0) {
        this.data = data;
        this.offset = offset;
      }
      get length() {
        return this.data.length;
      }
      peekRemaining() {
        return this.data.subarray(this.offset);
      }
      readU8() {
        if (this.offset + 1 > this.data.length) {
          throw new Error("Unexpected EOF");
        }
        return this.data[this.offset++];
      }
      readU16() {
        if (this.offset + 2 > this.data.length) {
          throw new Error("Unexpected EOF");
        }
        const v = this.data[this.offset] << 8 | this.data[this.offset + 1] & 255;
        this.offset += 2;
        return v;
      }
      readS16() {
        const v = this.readU16();
        return v & 32768 ? v - 65536 : v;
      }
      readU32() {
        if (this.offset + 4 > this.data.length) {
          throw new Error("Unexpected EOF");
        }
        const v = this.data[this.offset] << 24 | this.data[this.offset + 1] << 16 | this.data[this.offset + 2] << 8 | this.data[this.offset + 3];
        this.offset += 4;
        return v >>> 0;
      }
      readBytes(n) {
        if (this.offset + n > this.data.length) {
          throw new Error("Unexpected EOF");
        }
        const slice = this.data.subarray(this.offset, this.offset + n);
        this.offset += n;
        return slice;
      }
      skip(n) {
        if (this.offset + n > this.data.length) {
          throw new Error("Unexpected EOF");
        }
        this.offset += n;
      }
    };
  }
});

// src/fonts/woff2/decoder.ts
var decoder_exports2 = {};
__export(decoder_exports2, {
  decodeWoff2: () => decodeWoff2
});
function tagToString2(tag) {
  return String.fromCharCode(
    tag >> 24 & 255,
    tag >> 16 & 255,
    tag >> 8 & 255,
    tag & 255
  );
}
function resolveDependencies(deps) {
  return {
    decompress: deps?.decompress ?? ((data) => brotliDecompressSync(data)),
    transformers: deps?.transformers ?? createDefaultTransformers()
  };
}
function computeULongSum(data) {
  let checksum = 0 >>> 0;
  const aligned = data.length & ~3;
  for (let i = 0; i < aligned; i += 4) {
    const value = data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3];
    checksum = checksum + value >>> 0;
  }
  if (aligned !== data.length) {
    let v = 0;
    for (let i = aligned; i < data.length; i++) {
      v |= data[i] << 24 - 8 * (i & 3);
    }
    checksum = checksum + v >>> 0;
  }
  return checksum >>> 0;
}
function store16(value, out, offset) {
  const v = value & 65535;
  out[offset] = v >> 8 & 255;
  out[offset + 1] = v & 255;
  return offset + 2;
}
function store32(value, out, offset) {
  out[offset] = value >>> 24 & 255;
  out[offset + 1] = value >>> 16 & 255;
  out[offset + 2] = value >>> 8 & 255;
  out[offset + 3] = value & 255;
  return offset + 4;
}
function readTableDirectory(buf, numTables) {
  const tables = [];
  let srcOffset = 0;
  for (let i = 0; i < numTables; i++) {
    const flagByte = buf.readU8();
    let tag;
    if ((flagByte & 63) === 63) {
      tag = buf.readU32();
    } else {
      tag = KNOWN_TAGS[flagByte & 63] ?? 0;
    }
    const xformVersion = flagByte >> 6 & 3;
    let flags = 0;
    if (tag === TAG_GLYF || tag === TAG_LOCA) {
      if (xformVersion === 0) {
        flags |= WOFF2_FLAG_TRANSFORM;
      }
    } else if (xformVersion !== 0) {
      flags |= WOFF2_FLAG_TRANSFORM;
    }
    flags |= xformVersion;
    const dstLength = readBase128(buf);
    let transformLength = dstLength;
    if (flags & WOFF2_FLAG_TRANSFORM) {
      transformLength = readBase128(buf);
      if (tag === TAG_LOCA && transformLength !== 0) {
        throw new Error("Invalid WOFF2: transformed loca must have zero length");
      }
    }
    tables.push({
      tag,
      flags,
      srcOffset,
      srcLength: transformLength,
      transformLength,
      dstLength
    });
    srcOffset += transformLength;
  }
  return tables;
}
function parseHeader(fontData) {
  if (fontData.byteLength < WOFF2_HEADER_SIZE) {
    throw new Error("Invalid WOFF2: file too short");
  }
  const buf = new Buf(fontData);
  const signature = buf.readU32();
  if (signature !== WOFF2_SIGNATURE) {
    throw new Error("Invalid WOFF2 signature");
  }
  const flavor = buf.readU32() >>> 0;
  const reportedLength = buf.readU32();
  if (reportedLength !== fontData.byteLength) {
    throw new Error("Invalid WOFF2: length mismatch");
  }
  const numTables = buf.readU16();
  if (numTables === 0) {
    throw new Error("Invalid WOFF2: no tables");
  }
  buf.skip(2 + 4);
  const compressedLength = buf.readU32();
  buf.skip(4);
  const metaOffset = buf.readU32();
  const metaLength = buf.readU32();
  const metaOrigLen = buf.readU32();
  if (metaOffset !== 0) {
    if (metaOffset + metaLength > fontData.byteLength || metaOrigLen === 0) {
      throw new Error("Invalid WOFF2 metadata block");
    }
  }
  const privOffset = buf.readU32();
  const privLength = buf.readU32();
  if (privOffset !== 0 && privOffset + privLength > fontData.byteLength) {
    throw new Error("Invalid WOFF2 private block");
  }
  const tables = readTableDirectory(buf, numTables);
  const lastTable = tables[tables.length - 1];
  const uncompressedSize = lastTable.srcOffset + lastTable.srcLength;
  const compressedOffset = buf.offset;
  if (compressedOffset + compressedLength > fontData.byteLength) {
    throw new Error("Invalid WOFF2: compressed stream truncated");
  }
  const compressionRatio = uncompressedSize / Math.max(1, fontData.byteLength);
  if (compressionRatio > MAX_PLAUSIBLE_COMPRESSION_RATIO) {
    throw new Error("Invalid WOFF2: implausible compression ratio");
  }
  return {
    flavor,
    numTables,
    compressedOffset,
    compressedLength,
    uncompressedSize,
    tables
  };
}
function withSign(flag, base) {
  return flag & 1 ? base : -base;
}
function tripletDecode(flagsIn, data, nPoints) {
  let x = 0;
  let y = 0;
  let tripletIndex = 0;
  const points = new Array(
    nPoints
  );
  for (let i = 0; i < nPoints; i++) {
    let flag = flagsIn[i];
    const onCurve = flag >> 7 === 0;
    flag &= 127;
    let nDataBytes = 1;
    if (flag >= 84 && flag < 120) nDataBytes = 2;
    else if (flag < 84) nDataBytes = 1;
    else if (flag < 124) nDataBytes = 3;
    else nDataBytes = 4;
    if (tripletIndex + nDataBytes > data.length) {
      throw new Error("Invalid WOFF2 glyf triplet");
    }
    let dx;
    let dy;
    if (flag < 10) {
      dx = 0;
      dy = withSign(flag, ((flag & 14) << 7) + data[tripletIndex]);
    } else if (flag < 20) {
      dx = withSign(flag, ((flag - 10 & 14) << 7) + data[tripletIndex]);
      dy = 0;
    } else if (flag < 84) {
      const b0 = flag - 20;
      const b1 = data[tripletIndex];
      dx = withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
      dy = withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flag < 120) {
      const b0 = flag - 84;
      dx = withSign(flag, 1 + (b0 / 12 << 8) + data[tripletIndex]);
      dy = withSign(
        flag >> 1,
        1 + (b0 % 12 >> 2 << 8) + data[tripletIndex + 1]
      );
    } else if (flag < 124) {
      const b2 = data[tripletIndex + 1];
      dx = withSign(flag, (data[tripletIndex] << 4) + (b2 >> 4));
      dy = withSign(flag >> 1, ((b2 & 15) << 8) + data[tripletIndex + 2]);
    } else {
      dx = withSign(flag, (data[tripletIndex] << 8) + data[tripletIndex + 1]);
      dy = withSign(
        flag >> 1,
        (data[tripletIndex + 2] << 8) + data[tripletIndex + 3]
      );
    }
    tripletIndex += nDataBytes;
    x += dx;
    y += dy;
    points[i] = { x, y, onCurve };
  }
  return { points, consumed: tripletIndex };
}
function storePoints(points, nContours, instructionLength, hasOverlap) {
  const nPoints = points.length;
  const xBytes = [];
  const yBytes = [];
  let lastX = 0;
  let lastY = 0;
  let lastFlag = -1;
  let repeatCount = 0;
  const flagOffset = 10 + 2 * nContours + 2 + instructionLength;
  const flagsOut = [];
  for (let i = 0; i < nPoints; i++) {
    const point = points[i];
    let flag = point.onCurve ? GLYF_FLAGS.ON_CURVE : 0;
    if (hasOverlap && i === 0) {
      flag |= GLYF_FLAGS.OVERLAP_SIMPLE;
    }
    const dx = point.x - lastX;
    const dy = point.y - lastY;
    if (dx === 0) flag |= GLYF_FLAGS.X_SAME;
    else if (dx > -256 && dx < 256) {
      flag |= GLYF_FLAGS.X_SHORT | (dx > 0 ? GLYF_FLAGS.X_SAME : 0);
      xBytes.push(Math.abs(dx));
    } else {
      xBytes.push(dx >> 8 & 255, dx & 255);
    }
    if (dy === 0) flag |= GLYF_FLAGS.Y_SAME;
    else if (dy > -256 && dy < 256) {
      flag |= GLYF_FLAGS.Y_SHORT | (dy > 0 ? GLYF_FLAGS.Y_SAME : 0);
      yBytes.push(Math.abs(dy));
    } else {
      yBytes.push(dy >> 8 & 255, dy & 255);
    }
    if (flag === lastFlag && repeatCount !== 255) {
      flagsOut[flagsOut.length - 1] |= GLYF_FLAGS.REPEAT;
      repeatCount++;
    } else {
      if (repeatCount !== 0) {
        flagsOut.push(repeatCount);
      }
      flagsOut.push(flag);
      repeatCount = 0;
      lastFlag = flag;
    }
    lastX = point.x;
    lastY = point.y;
  }
  if (repeatCount !== 0) {
    flagsOut.push(repeatCount);
  }
  const totalSize = flagOffset + flagsOut.length + xBytes.length + yBytes.length;
  const out = new Uint8Array(totalSize);
  let offset = flagOffset;
  for (const f of flagsOut) out[offset++] = f;
  for (const b of xBytes) out[offset++] = b;
  for (const b of yBytes) out[offset++] = b;
  return out;
}
function computeBBox(points) {
  if (points.length === 0) {
    return [0, 0, 0, 0];
  }
  let xMin = points[0].x;
  let xMax = points[0].x;
  let yMin = points[0].y;
  let yMax = points[0].y;
  for (let i = 1; i < points.length; i++) {
    const p = points[i];
    if (p.x < xMin) xMin = p.x;
    if (p.x > xMax) xMax = p.x;
    if (p.y < yMin) yMin = p.y;
    if (p.y > yMax) yMax = p.y;
  }
  return [xMin, yMin, xMax, yMax];
}
function sizeOfComposite(stream) {
  const start = stream.offset;
  let flags = COMPOSITE_FLAGS.MORE_COMPONENTS;
  let haveInstructions = false;
  while (flags & COMPOSITE_FLAGS.MORE_COMPONENTS) {
    flags = stream.readU16();
    haveInstructions ||= (flags & COMPOSITE_FLAGS.WE_HAVE_INSTRUCTIONS) !== 0;
    let argSize = 2;
    if (flags & COMPOSITE_FLAGS.ARG_WORDS) argSize += 4;
    else argSize += 2;
    if (flags & COMPOSITE_FLAGS.WE_HAVE_A_SCALE) argSize += 2;
    else if (flags & COMPOSITE_FLAGS.WE_HAVE_AN_XY_SCALE) argSize += 4;
    else if (flags & COMPOSITE_FLAGS.WE_HAVE_A_TWO_BY_TWO) argSize += 8;
    stream.skip(argSize);
  }
  return { size: stream.offset - start, haveInstructions };
}
function storeLoca(locaValues, indexFormat) {
  const offsetSize = indexFormat ? 4 : 2;
  const buffer = new Uint8Array(locaValues.length * offsetSize);
  let off = 0;
  for (const value of locaValues) {
    if (indexFormat) {
      off = store32(value, buffer, off);
    } else {
      off = store16(value >> 1, buffer, off);
    }
  }
  return { data: buffer, checksum: computeULongSum(buffer) };
}
function reconstructGlyfTable(transformed, locaDstLength) {
  const stream = new Buf(transformed);
  stream.readU16();
  const flags = stream.readU16();
  const hasOverlapBitmap = (flags & 1) !== 0;
  const numGlyphs = stream.readU16();
  const indexFormat = stream.readU16();
  const substreamSizes = [];
  for (let i = 0; i < 7; i++) {
    substreamSizes.push(stream.readU32());
  }
  let dataOffset = (2 + 7) * 4;
  const substreams = [];
  for (const sz of substreamSizes) {
    if (dataOffset + sz > transformed.length) {
      throw new Error("Invalid WOFF2 glyf stream");
    }
    substreams.push(transformed.subarray(dataOffset, dataOffset + sz));
    dataOffset += sz;
  }
  let overlapBitmap = null;
  if (hasOverlapBitmap) {
    const len = numGlyphs + 7 >> 3;
    if (dataOffset + len > transformed.length) {
      throw new Error("Invalid WOFF2 overlap bitmap");
    }
    overlapBitmap = transformed.subarray(dataOffset, dataOffset + len);
  }
  const nContourStream = new Buf(substreams[0]);
  const nPointsStream = new Buf(substreams[1]);
  const flagStream = new Buf(substreams[2]);
  const glyphStream = new Buf(substreams[3]);
  const compositeStream = new Buf(substreams[4]);
  const bboxStream = new Buf(substreams[5]);
  const instructionStream = new Buf(substreams[6]);
  const bboxBitmapLen = numGlyphs + 31 >> 5 << 2;
  const bboxBitmap = bboxStream.readBytes(bboxBitmapLen);
  const locaValues = new Array(numGlyphs + 1).fill(0);
  const xMins = new Int16Array(numGlyphs);
  const glyfChunks = [];
  let glyfChecksum = 0 >>> 0;
  let currentGlyfOffset = 0;
  for (let i = 0; i < numGlyphs; i++) {
    const nContours = nContourStream.readU16();
    const haveBbox = (bboxBitmap[i >> 3] & 128 >> (i & 7)) !== 0;
    let glyphBytes = null;
    if (nContours === 65535) {
      const { size: compositeSize, haveInstructions } = sizeOfComposite(
        new Buf(compositeStream.peekRemaining())
      );
      let instructionSize = 0;
      if (haveInstructions) {
        instructionSize = read255UShort(glyphStream);
      }
      const total = 12 + compositeSize + instructionSize;
      const out = new Uint8Array(total);
      let off = 0;
      off = store16(nContours, out, off);
      if (!haveBbox) {
        throw new Error("Invalid WOFF2 glyf: composite without bbox");
      }
      const bboxData = bboxStream.readBytes(8);
      const xMinRaw = bboxData[0] << 8 | bboxData[1];
      xMins[i] = xMinRaw & 32768 ? xMinRaw - 65536 : xMinRaw;
      out.set(bboxData, off);
      off += 8;
      out.set(compositeStream.readBytes(compositeSize), off);
      off += compositeSize;
      if (haveInstructions) {
        off = store16(instructionSize, out, off);
        out.set(instructionStream.readBytes(instructionSize), off);
      }
      glyphBytes = out;
    } else if (nContours > 0) {
      const nPoints = [];
      let totalPoints = 0;
      for (let c = 0; c < nContours; c++) {
        const pts = read255UShort(nPointsStream);
        totalPoints += pts;
        nPoints.push(pts);
      }
      const flagData = flagStream.readBytes(totalPoints);
      const tripletsView = glyphStream.peekRemaining();
      const { points, consumed } = tripletDecode(
        flagData,
        tripletsView,
        totalPoints
      );
      glyphStream.offset += consumed;
      const instructionSize = read255UShort(glyphStream);
      const bbox = haveBbox ? bboxStream.readBytes(8) : null;
      const baseSize = 12 + 2 * nContours + instructionSize;
      const ptsBuf = storePoints(
        points,
        nContours,
        instructionSize,
        !!(overlapBitmap && overlapBitmap[i >> 3] & 128 >> (i & 7))
      );
      const glyphBuf = new Uint8Array(ptsBuf.length);
      glyphBuf.set(ptsBuf);
      let off = 0;
      off = store16(nContours, glyphBuf, off);
      if (bbox) {
        glyphBuf.set(bbox, off);
        off += 8;
      } else {
        const [xMin, yMin, xMax, yMax] = computeBBox(points);
        off = store16(xMin, glyphBuf, off);
        off = store16(yMin, glyphBuf, off);
        off = store16(xMax, glyphBuf, off);
        off = store16(yMax, glyphBuf, off);
      }
      let endPoint = -1;
      for (const count of nPoints) {
        endPoint += count;
        off = store16(endPoint, glyphBuf, off);
      }
      off = store16(instructionSize, glyphBuf, off);
      const remaining = instructionStream.peekRemaining().length;
      const safeSize = Math.min(instructionSize, remaining);
      const instructions = instructionStream.readBytes(safeSize);
      glyphBuf.set(instructions, off);
      glyphBytes = glyphBuf;
      const xMinRaw = glyphBuf[2] << 8 | glyphBuf[3];
      xMins[i] = xMinRaw & 32768 ? xMinRaw - 65536 : xMinRaw;
    } else {
      if (haveBbox) {
        throw new Error("Invalid WOFF2 glyf: empty glyph with bbox");
      }
      glyphBytes = new Uint8Array(0);
    }
    locaValues[i] = currentGlyfOffset;
    glyfChunks.push(glyphBytes);
    currentGlyfOffset += round4(glyphBytes.length);
    glyfChecksum = glyfChecksum + computeULongSum(glyphBytes) >>> 0;
  }
  locaValues[numGlyphs] = currentGlyfOffset;
  if (locaDstLength !== (indexFormat ? 4 : 2) * (numGlyphs + 1)) {
    throw new Error("Invalid WOFF2 loca length");
  }
  const glyfSize = locaValues[numGlyphs];
  const glyfData = new Uint8Array(glyfSize);
  let glyfOffset = 0;
  for (const chunk of glyfChunks) {
    glyfData.set(chunk, glyfOffset);
    glyfOffset += chunk.length;
    const padded = round4(glyfOffset) - glyfOffset;
    glyfOffset += padded;
  }
  const loca = storeLoca(locaValues, indexFormat);
  return {
    glyfData,
    locaData: loca.data,
    glyfChecksum,
    locaChecksum: loca.checksum,
    numGlyphs,
    indexFormat,
    xMins
  };
}
function readNumHMetrics(hheaTable) {
  const buf = new Buf(hheaTable);
  buf.skip(34);
  return buf.readU16();
}
function reconstructTransformedHmtx(transformed, numGlyphs, numHMetrics, xMins) {
  const buf = new Buf(transformed);
  const flags = buf.readU8();
  const hasPropLSB = (flags & 1) === 0;
  const hasMonoLSB = (flags & 2) === 0;
  if ((flags & 252) !== 0) {
    throw new Error("Invalid hmtx flags");
  }
  if (hasPropLSB && hasMonoLSB) {
    throw new Error("Invalid hmtx transform state");
  }
  if (numHMetrics < 1 || numHMetrics > numGlyphs) {
    throw new Error("Invalid hmtx metrics count");
  }
  const advanceWidths = [];
  const lsbs = [];
  for (let i = 0; i < numHMetrics; i++) {
    advanceWidths.push(buf.readU16());
  }
  for (let i = 0; i < numHMetrics; i++) {
    lsbs.push(hasPropLSB ? buf.readS16() : xMins[i]);
  }
  for (let i = numHMetrics; i < numGlyphs; i++) {
    lsbs.push(hasMonoLSB ? buf.readS16() : xMins[i]);
  }
  const out = new Uint8Array(2 * numGlyphs + 2 * numHMetrics);
  let off = 0;
  for (let i = 0; i < numGlyphs; i++) {
    if (i < numHMetrics) {
      off = store16(advanceWidths[i], out, off);
    }
    off = store16(lsbs[i], out, off);
  }
  return { data: out, checksum: computeULongSum(out) };
}
function transformGlyfTable(_table, srcData, context) {
  const locaTable = context.tablesByTag.get(TAG_LOCA);
  if (!locaTable) {
    throw new Error("Invalid WOFF2: missing loca for glyf");
  }
  const glyfInfo = reconstructGlyfTable(srcData, locaTable.dstLength);
  context.state.glyfInfo = glyfInfo;
  context.tableMap.set(TAG_GLYF, glyfInfo.glyfData);
  context.tableMap.set(TAG_LOCA, glyfInfo.locaData);
}
function transformLocaTable(_table, _srcData, context) {
  if (!context.tableMap.has(TAG_LOCA)) {
    throw new Error("Invalid WOFF2: loca transformed without glyf");
  }
}
function transformHmtxTable(_table, srcData, context) {
  const glyfInfo = context.state.glyfInfo;
  if (!glyfInfo) {
    throw new Error("Invalid WOFF2: hmtx transform before glyf");
  }
  const hmtx = reconstructTransformedHmtx(
    srcData,
    glyfInfo.numGlyphs,
    context.state.numHMetrics,
    glyfInfo.xMins
  );
  context.tableMap.set(TAG_HMTX, hmtx.data);
}
function createDefaultTransformers() {
  return /* @__PURE__ */ new Map([
    [TAG_GLYF, transformGlyfTable],
    [TAG_LOCA, transformLocaTable],
    [TAG_HMTX, transformHmtxTable]
  ]);
}
function buildSfnt(flavor, tableData) {
  const entries2 = Array.from(tableData.entries()).sort((a, b) => a[0] - b[0]);
  const numTables = entries2.length;
  let offset = SFNT_HEADER_SIZE + SFNT_ENTRY_SIZE * numTables;
  const records = [];
  for (const [tag, data] of entries2) {
    const paddedLen = round4(data.length);
    records.push({
      tag,
      checksum: computeULongSum(data),
      offset,
      length: data.length,
      data
    });
    offset += paddedLen;
  }
  const ttf = new Uint8Array(offset);
  let off = 0;
  off = store32(flavor >>> 0, ttf, off);
  off = store16(numTables, ttf, off);
  let maxPow2 = 0;
  while (1 << maxPow2 + 1 <= numTables) maxPow2++;
  const searchRange = (1 << maxPow2) * 16;
  off = store16(searchRange, ttf, off);
  off = store16(maxPow2, ttf, off);
  off = store16(numTables * 16 - searchRange, ttf, off);
  for (const rec of records) {
    off = store32(rec.tag, ttf, off);
    off = store32(rec.checksum, ttf, off);
    off = store32(rec.offset, ttf, off);
    off = store32(rec.length, ttf, off);
  }
  for (const rec of records) {
    ttf.set(rec.data, rec.offset);
  }
  const headRecord = records.find((r) => r.tag === TAG_HEAD);
  if (headRecord) {
    const checksum = computeULongSum(ttf);
    const adjustment = 2981146554 - checksum >>> 0;
    store32(adjustment, ttf, headRecord.offset + CHECKSUM_ADJUSTMENT_OFFSET);
  }
  const tables = {};
  for (const [tag, data] of entries2) {
    tables[tagToString2(tag)] = data;
  }
  return { ttf, tables };
}
function rebuildFont(header, transformed, deps) {
  const tableMap = /* @__PURE__ */ new Map();
  const tablesByTag = new Map(header.tables.map((t) => [t.tag, t]));
  const state = { glyfInfo: null, numHMetrics: 0 };
  const context = { header, tableMap, tablesByTag, state };
  const transformers = deps.transformers;
  const sortedTables = header.tables.slice().sort((a, b) => a.tag - b.tag);
  for (const table of sortedTables) {
    const srcStart = table.srcOffset;
    const srcEnd = srcStart + table.srcLength;
    if (srcEnd > transformed.length) {
      throw new Error("Invalid WOFF2: table outside brotli buffer");
    }
    const srcData = transformed.subarray(srcStart, srcEnd);
    if ((table.flags & WOFF2_FLAG_TRANSFORM) === 0) {
      const data = new Uint8Array(srcData);
      if (table.tag === TAG_HEAD && data.length >= 12) {
        data[CHECKSUM_ADJUSTMENT_OFFSET] = 0;
        data[CHECKSUM_ADJUSTMENT_OFFSET + 1] = 0;
        data[CHECKSUM_ADJUSTMENT_OFFSET + 2] = 0;
        data[CHECKSUM_ADJUSTMENT_OFFSET + 3] = 0;
      }
      tableMap.set(table.tag, data);
      if (table.tag === TAG_HHEA) {
        state.numHMetrics = readNumHMetrics(data);
      }
      continue;
    }
    const transformer = transformers.get(table.tag);
    if (!transformer) {
      throw new Error(`Unsupported WOFF2 transform for ${tagToString2(table.tag)}`);
    }
    transformer(table, srcData, context);
  }
  return buildSfnt(header.flavor, tableMap);
}
function decodeWoff2(fontData, deps) {
  const resolvedDeps = resolveDependencies(deps);
  const header = parseHeader(fontData);
  const compressed = fontData.subarray(
    header.compressedOffset,
    header.compressedOffset + header.compressedLength
  );
  const decompressed = resolvedDeps.decompress(compressed);
  if (decompressed.byteLength !== header.uncompressedSize) {
    throw new Error("Invalid WOFF2: brotli size mismatch");
  }
  const rebuilt = rebuildFont(header, decompressed, resolvedDeps);
  const parsed = {
    flavor: header.flavor,
    numTables: header.numTables,
    tables: rebuilt.tables
  };
  return { parsed, ttfBuffer: rebuilt.ttf };
}
var WOFF2_SIGNATURE, WOFF2_HEADER_SIZE, WOFF2_FLAG_TRANSFORM, SFNT_HEADER_SIZE, SFNT_ENTRY_SIZE, CHECKSUM_ADJUSTMENT_OFFSET, MAX_PLAUSIBLE_COMPRESSION_RATIO, TAG, TAG_GLYF, TAG_LOCA, TAG_HMTX, TAG_HHEA, TAG_HEAD, KNOWN_TAGS, round4, GLYF_FLAGS, COMPOSITE_FLAGS;
var init_decoder2 = __esm({
  "src/fonts/woff2/decoder.ts"() {
    "use strict";
    init_zlib_empty();
    init_buffer();
    WOFF2_SIGNATURE = 2001684018;
    WOFF2_HEADER_SIZE = 48;
    WOFF2_FLAG_TRANSFORM = 1 << 8;
    SFNT_HEADER_SIZE = 12;
    SFNT_ENTRY_SIZE = 16;
    CHECKSUM_ADJUSTMENT_OFFSET = 8;
    MAX_PLAUSIBLE_COMPRESSION_RATIO = 100;
    TAG = (text) => text.charCodeAt(0) << 24 | text.charCodeAt(1) << 16 | text.charCodeAt(2) << 8 | text.charCodeAt(3);
    TAG_GLYF = TAG("glyf");
    TAG_LOCA = TAG("loca");
    TAG_HMTX = TAG("hmtx");
    TAG_HHEA = TAG("hhea");
    TAG_HEAD = TAG("head");
    KNOWN_TAGS = [
      TAG("cmap"),
      TAG("head"),
      TAG("hhea"),
      TAG("hmtx"),
      TAG("maxp"),
      TAG("name"),
      TAG("OS/2"),
      TAG("post"),
      TAG("cvt "),
      TAG("fpgm"),
      TAG_GLYF,
      TAG_LOCA,
      TAG("prep"),
      TAG("CFF "),
      TAG("VORG"),
      TAG("EBDT"),
      TAG("EBLC"),
      TAG("gasp"),
      TAG("hdmx"),
      TAG("kern"),
      TAG("LTSH"),
      TAG("PCLT"),
      TAG("VDMX"),
      TAG("vhea"),
      TAG("vmtx"),
      TAG("BASE"),
      TAG("GDEF"),
      TAG("GPOS"),
      TAG("GSUB"),
      TAG("EBSC"),
      TAG("JSTF"),
      TAG("MATH"),
      TAG("CBDT"),
      TAG("CBLC"),
      TAG("COLR"),
      TAG("CPAL"),
      TAG("SVG "),
      TAG("sbix"),
      TAG("acnt"),
      TAG("avar"),
      TAG("bdat"),
      TAG("bloc"),
      TAG("bsln"),
      TAG("cvar"),
      TAG("fdsc"),
      TAG("feat"),
      TAG("fmtx"),
      TAG("fvar"),
      TAG("gvar"),
      TAG("hsty"),
      TAG("just"),
      TAG("lcar"),
      TAG("mort"),
      TAG("morx"),
      TAG("opbd"),
      TAG("prop"),
      TAG("trak"),
      TAG("Zapf"),
      TAG("Silf"),
      TAG("Glat"),
      TAG("Gloc"),
      TAG("Feat"),
      TAG("Sill")
    ];
    round4 = (v) => v + 3 & ~3;
    GLYF_FLAGS = {
      ON_CURVE: 1 << 0,
      X_SHORT: 1 << 1,
      Y_SHORT: 1 << 2,
      REPEAT: 1 << 3,
      X_SAME: 1 << 4,
      Y_SAME: 1 << 5,
      OVERLAP_SIMPLE: 1 << 6
    };
    COMPOSITE_FLAGS = {
      ARG_WORDS: 1 << 0,
      WE_HAVE_A_SCALE: 1 << 3,
      MORE_COMPONENTS: 1 << 5,
      WE_HAVE_AN_XY_SCALE: 1 << 6,
      WE_HAVE_A_TWO_BY_TWO: 1 << 7,
      WE_HAVE_INSTRUCTIONS: 1 << 8
    };
  }
});

// src/pdf/font/glyph-atlas.ts
var glyph_atlas_exports = {};
__export(glyph_atlas_exports, {
  GlyphAtlas: () => GlyphAtlas,
  globalGlyphAtlas: () => globalGlyphAtlas
});
var DEFAULT_PAGE_SIZE, PADDING, Shelf, GlyphAtlas, globalGlyphAtlas;
var init_glyph_atlas = __esm({
  "src/pdf/font/glyph-atlas.ts"() {
    "use strict";
    DEFAULT_PAGE_SIZE = 2048;
    PADDING = 2;
    Shelf = class {
      constructor(y, height, pageWidth) {
        this.y = y;
        this.height = height;
        this.xCursor = 0;
        this.remaining = pageWidth;
      }
    };
    GlyphAtlas = class {
      constructor(pageSize = DEFAULT_PAGE_SIZE) {
        this.pageSize = DEFAULT_PAGE_SIZE;
        this.pages = [];
        this.placements = /* @__PURE__ */ new Map();
        // LRU eviction control for shelf atlas
        this.maxPages = 8;
        this.pageSize = pageSize;
      }
      setMaxPages(n) {
        if (!Number.isFinite(n) || n < 1) return;
        this.maxPages = Math.max(1, Math.floor(n));
        this.evictIfNeeded();
      }
      clear() {
        this.pages = [];
        this.placements.clear();
      }
      getPages() {
        return this.pages.map((p) => ({ width: p.width, height: p.height, data: p.data.slice() }));
      }
      has(key2) {
        return this.placements.has(key2);
      }
      getPlacement(key2) {
        return this.placements.get(key2) ?? null;
      }
      /**
       * Pack an alpha mask into the atlas.
       * - key: unique identifier for the glyph (e.g., fontUid|gid|size|ss)
       * - mask: Uint8ClampedArray length = w*h
       * - w,h: dimensions
       * Returns placement or null on failure.
       */
      pack(key2, mask, w, h, extraPadding = 0) {
        if (this.placements.has(key2)) {
          return this.placements.get(key2);
        }
        const pw = this.pageSize;
        const ph = this.pageSize;
        const pad = PADDING + Math.max(0, Math.floor(extraPadding));
        const rw = w + pad * 2;
        const rh = h + pad * 2;
        for (let pi = 0; pi < this.pages.length; pi++) {
          const page = this.pages[pi];
          for (const shelf2 of page.shelves) {
            if (rh <= shelf2.height && rw <= shelf2.remaining) {
              const x2 = shelf2.xCursor + pad;
              const y2 = shelf2.y + pad;
              this.blitToPage(page.data, page.width, page.height, x2, y2, mask, w, h);
              shelf2.xCursor += rw;
              shelf2.remaining -= rw;
              page.used += rw * rh;
              page.lastUsed = Date.now();
              const placement2 = { pageIndex: pi, x: x2, y: y2, width: w, height: h };
              this.placements.set(key2, placement2);
              return placement2;
            }
          }
          const usedHeight = page.shelves.reduce((s, sh) => s + sh.height, 0);
          if (usedHeight + rh <= page.height) {
            const shelfY = usedHeight;
            const shelf2 = new Shelf(shelfY, rh, page.width);
            page.shelves.push(shelf2);
            const x2 = shelf2.xCursor + pad;
            const y2 = shelf2.y + pad;
            this.blitToPage(page.data, page.width, page.height, x2, y2, mask, w, h);
            shelf2.xCursor += rw;
            shelf2.remaining -= rw;
            page.used += rw * rh;
            page.lastUsed = Date.now();
            const placement2 = { pageIndex: pi, x: x2, y: y2, width: w, height: h };
            this.placements.set(key2, placement2);
            return placement2;
          }
        }
        const pageW = pw;
        const pageH = ph;
        const pageData = new Uint8Array(pageW * pageH * 4);
        const newPage = { width: pageW, height: pageH, data: pageData, shelves: [], used: 0, lastUsed: Date.now() };
        if (rh > pageH || rw > pageW) {
          return null;
        }
        const shelf = new Shelf(0, rh, pageW);
        newPage.shelves.push(shelf);
        this.pages.push(newPage);
        this.evictIfNeeded();
        const x = shelf.xCursor + pad;
        const y = shelf.y + pad;
        this.blitToPage(newPage.data, newPage.width, newPage.height, x, y, mask, w, h);
        shelf.xCursor += rw;
        shelf.remaining -= rw;
        newPage.used += rw * rh;
        newPage.lastUsed = Date.now();
        const placement = { pageIndex: this.pages.length - 1, x, y, width: w, height: h };
        this.placements.set(key2, placement);
        return placement;
      }
      evictIfNeeded() {
        while (this.pages.length > this.maxPages) {
          this.evictLeastRecentlyUsedPage();
        }
      }
      evictLeastRecentlyUsedPage() {
        if (this.pages.length === 0) return;
        let oldest = 0;
        let oldestTime = Infinity;
        for (let i = 0; i < this.pages.length; i++) {
          const p = this.pages[i];
          if (p.lastUsed < oldestTime) {
            oldestTime = p.lastUsed;
            oldest = i;
          }
        }
        this.evictPage(oldest);
      }
      evictPage(idx) {
        if (idx < 0 || idx >= this.pages.length) return;
        this.pages.splice(idx, 1);
        for (const [k, placement] of Array.from(this.placements.entries())) {
          if (placement.pageIndex === idx) {
            this.placements.delete(k);
          } else if (placement.pageIndex > idx) {
            this.placements.set(k, { ...placement, pageIndex: placement.pageIndex - 1 });
          }
        }
      }
      blitToPage(pageData, pageW, _pageH, dstX, dstY, mask, w, h) {
        for (let row = 0; row < h; row++) {
          const srcOff = row * w;
          const dstRow = (dstY + row) * pageW;
          let dstCol = dstX;
          for (let col = 0; col < w; col++) {
            const a = mask[srcOff + col];
            const di = (dstRow + dstCol) * 4;
            pageData[di] = 0;
            pageData[di + 1] = 0;
            pageData[di + 2] = 0;
            pageData[di + 3] = a;
            dstCol++;
          }
        }
      }
    };
    globalGlyphAtlas = new GlyphAtlas(DEFAULT_PAGE_SIZE);
  }
});

// src/environment/browser-environment.ts
var BrowserLoader = class {
  async load(source) {
    const response = await fetch(source);
    if (!response.ok) {
      throw new Error(`Failed to fetch resource: ${source} (${response.status})`);
    }
    return await response.arrayBuffer();
  }
};
var DecompressionStreamCtor = globalThis.DecompressionStream;
var BrowserCompression = class {
  async inflateRaw(data) {
    if (!DecompressionStreamCtor) {
      throw new Error("DecompressionStream not available; provide a polyfill (e.g., pako) for inflateRaw.");
    }
    const stream = new DecompressionStreamCtor("deflate-raw");
    const writer = stream.writable.getWriter();
    await writer.write(new Uint8Array(data));
    await writer.close();
    const reader = stream.readable.getReader();
    const chunks = [];
    let total = 0;
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      total += value.byteLength;
    }
    const out = new Uint8Array(total);
    let offset = 0;
    for (const chunk of chunks) {
      out.set(chunk, offset);
      offset += chunk.byteLength;
    }
    return out;
  }
};
var BrowserEnvironment = class {
  constructor() {
    this.loader = new BrowserLoader();
    this.compression = new BrowserCompression();
  }
  resolveLocal(source, base) {
    if (/^data:/i.test(source)) return source;
    if (/^[a-z][a-z0-9+\-.]*:\/\//i.test(source) || source.startsWith("//")) {
      return source;
    }
    if (base) {
      try {
        return new URL(source, base).toString();
      } catch {
      }
    }
    throw new Error(`Local path resolution is not supported in browser environment: ${source}`);
  }
  now() {
    return typeof performance !== "undefined" ? performance.now() : Date.now();
  }
  getEnv(_name) {
    return void 0;
  }
};

// src/environment/global.ts
function setGlobalEnvironment(env) {
  globalThis.__PAGYRA_ENV__ = env;
}
function getGlobalEnvironment() {
  return globalThis.__PAGYRA_ENV__;
}

// node_modules/linkedom/esm/shared/symbols.js
var CHANGED = Symbol("changed");
var CLASS_LIST = Symbol("classList");
var CUSTOM_ELEMENTS = Symbol("CustomElements");
var CONTENT = Symbol("content");
var DATASET = Symbol("dataset");
var DOCTYPE = Symbol("doctype");
var DOM_PARSER = Symbol("DOMParser");
var END = Symbol("end");
var EVENT_TARGET = Symbol("EventTarget");
var GLOBALS = Symbol("globals");
var IMAGE = Symbol("image");
var MIME = Symbol("mime");
var MUTATION_OBSERVER = Symbol("MutationObserver");
var NEXT = Symbol("next");
var OWNER_ELEMENT = Symbol("ownerElement");
var PREV = Symbol("prev");
var PRIVATE = Symbol("private");
var SHEET = Symbol("sheet");
var START = Symbol("start");
var STYLE = Symbol("style");
var UPGRADE = Symbol("upgrade");
var VALUE = Symbol("value");

// node_modules/htmlparser2/lib/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  DefaultHandler: () => DomHandler,
  DomHandler: () => DomHandler,
  DomUtils: () => esm_exports2,
  ElementType: () => esm_exports,
  Parser: () => Parser,
  QuoteType: () => QuoteType,
  Tokenizer: () => Tokenizer,
  createDocumentStream: () => createDocumentStream,
  createDomStream: () => createDomStream,
  getFeed: () => getFeed,
  parseDOM: () => parseDOM,
  parseDocument: () => parseDocument,
  parseFeed: () => parseFeed
});

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes3) {
  CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
  CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
  CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
  CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
  CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
  CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
  CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
  CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
  CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
  CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
  CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current2 = decodeTree[this.treeIndex];
    let valueLength = (current2 & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current2, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current2 = decodeTree[this.treeIndex];
      valueLength = (current2 & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current2, nodeIdx, char) {
  const branchCount = (current2 & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current2 & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["BeforeSpecialT"] = 23] = "BeforeSpecialT";
  State2[State2["SpecialStartSequence"] = 24] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 25] = "InSpecialTag";
  State2[State2["InEntity"] = 26] = "InEntity";
})(State || (State = {}));
function isWhitespace(c) {
  return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace(c);
}
function isASCIIAlpha(c) {
  return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea`
};
var Tokenizer = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.entityStart = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityDecoder = new EntityDecoder(xmlMode ? decode_data_xml_default : decode_data_html_default, (cp, consumed) => this.emitCodePoint(cp, consumed));
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  stateText(c) {
    if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes2.Gt || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes2.Amp) {
          this.startEntity();
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (this.xmlMode) {
        this.state = State.InTagName;
      } else if (lower === Sequences.ScriptEnd[2]) {
        this.state = State.BeforeSpecialS;
      } else if (lower === Sequences.TitleEnd[2]) {
        this.state = State.BeforeSpecialT;
      } else {
        this.state = State.InTagName;
      }
    } else if (c === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) {
    } else if (c === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes2.Gt || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = this.index;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace(c) || c === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.startEntity();
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    const lower = c | 32;
    if (lower === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (lower === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
  }
  startEntity() {
    this.baseState = this.state;
    this.state = State.InEntity;
    this.entityStart = this.index;
    this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);
  }
  stateInEntity() {
    const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
    if (length >= 0) {
      this.state = this.baseState;
      if (length === 0) {
        this.index = this.entityStart;
      }
    } else {
      this.index = this.offset + this.buffer.length - 1;
    }
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State.BeforeSpecialT: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InEntity) {
      this.entityDecoder.end();
      this.state = this.baseState;
    }
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      if (this.sectionStart < this.entityStart) {
        this.cbs.onattribdata(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.onattribentity(cp);
    } else {
      if (this.sectionStart < this.entityStart) {
        this.cbs.ontext(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.ontextentity(cp, this.sectionStart);
    }
  }
};

// node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser = class {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e, _f;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.htmlMode = !this.options.xmlMode;
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : this.htmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
    this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
    this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer)(this.options, this);
    this.foreignContext = [!this.htmlMode];
    (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a2, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint(cp));
    this.startIndex = endIndex;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(name) {
    return this.htmlMode && voidElements.has(name);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this.emitOpenTag(name);
  }
  emitOpenTag(name) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name;
    const impliesClose = this.htmlMode && openImpliesClose.get(name);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
        const element = this.stack.shift();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name)) {
      this.stack.unshift(name);
      if (this.htmlMode) {
        if (foreignContextElements.has(name)) {
          this.foreignContext.unshift(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.unshift(false);
        }
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    this.endIndex = endIndex;
    let name = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (this.htmlMode && (foreignContextElements.has(name) || htmlIntegrationElements.has(name))) {
      this.foreignContext.shift();
    }
    if (!this.isVoidElement(name)) {
      const pos = this.stack.indexOf(name);
      if (pos !== -1) {
        for (let index = 0; index <= pos; index++) {
          const element = this.stack.shift();
          (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, index !== pos);
        }
      } else if (this.htmlMode && name === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (this.htmlMode && name === "br") {
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
      (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
      (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.recognizeSelfClosing || this.foreignContext[0]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[0] === name) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name, !isOpenImplied);
      this.stack.shift();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (!this.htmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = 0; index < this.stack.length; index++) {
        this.cbs.onclosetag(this.stack[index], true);
      }
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.foreignContext.length = 0;
    this.foreignContext.unshift(!this.htmlMode);
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// node_modules/domelementtype/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CDATA: () => CDATA,
  Comment: () => Comment,
  Directive: () => Directive,
  Doctype: () => Doctype,
  ElementType: () => ElementType,
  Root: () => Root,
  Script: () => Script,
  Style: () => Style,
  Tag: () => Tag,
  Text: () => Text,
  isTag: () => isTag
});
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// node_modules/domhandler/lib/esm/node.js
var Node = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name, data) {
    super(data);
    this.name = name;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name) {
    this.name = name;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name) => {
      var _a2, _b;
      return {
        name,
        value: this.attribs[name],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA2(children);
    children.forEach((child) => child.parent = clone);
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

// node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name, attribs, void 0, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment2(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text2("");
    const node = new CDATA2([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node = new ProcessingInstruction(name, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling2 = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling2) {
      node.prev = previousSibling2;
      previousSibling2.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
};

// node_modules/domutils/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DocumentPosition: () => DocumentPosition,
  append: () => append,
  appendChild: () => appendChild,
  compareDocumentPosition: () => compareDocumentPosition,
  existsOne: () => existsOne,
  filter: () => filter,
  find: () => find,
  findAll: () => findAll,
  findOne: () => findOne,
  findOneChild: () => findOneChild,
  getAttributeValue: () => getAttributeValue,
  getChildren: () => getChildren,
  getElementById: () => getElementById,
  getElements: () => getElements,
  getElementsByClassName: () => getElementsByClassName,
  getElementsByTagName: () => getElementsByTagName,
  getElementsByTagType: () => getElementsByTagType,
  getFeed: () => getFeed,
  getInnerHTML: () => getInnerHTML,
  getName: () => getName,
  getOuterHTML: () => getOuterHTML,
  getParent: () => getParent,
  getSiblings: () => getSiblings,
  getText: () => getText,
  hasAttrib: () => hasAttrib,
  hasChildren: () => hasChildren,
  innerText: () => innerText,
  isCDATA: () => isCDATA,
  isComment: () => isComment,
  isDocument: () => isDocument,
  isTag: () => isTag2,
  isText: () => isText,
  nextElementSibling: () => nextElementSibling,
  prepend: () => prepend,
  prependChild: () => prependChild,
  prevElementSibling: () => prevElementSibling,
  removeElement: () => removeElement,
  removeSubsets: () => removeSubsets,
  replaceElement: () => replaceElement,
  testElement: () => testElement,
  textContent: () => textContent,
  uniqueSort: () => uniqueSort
});

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== void 0) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map) {
  return function escape3(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a2;
  if (!attributes2)
    return;
  const encode = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key2) => {
    var _a3, _b;
    const value = (_a3 = attributes2[key2]) !== null && _a3 !== void 0 ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return `${key2}="${encode(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
var esm_default = render;
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a2;
  let data = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node, options) {
  return esm_default(node, options);
}
function getInnerHTML(node, options) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
}
function getText(node) {
  if (Array.isArray(node))
    return node.map(getText).join("");
  if (isTag2(node))
    return node.name === "br" ? "\n" : getText(node.children);
  if (isCDATA(node))
    return getText(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent(node) {
  if (Array.isArray(node))
    return node.map(textContent).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}

// node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
function getAttributeValue(elem, name) {
  var _a2;
  return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
}
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next } = elem;
  while (next !== null && !isTag2(next))
    ({ next } = next);
  return next;
}
function prevElementSibling(elem) {
  let { prev } = elem;
  while (prev !== null && !isTag2(prev))
    ({ prev } = prev);
  return prev;
}

// node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next) {
  removeElement(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev) {
  removeElement(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

// node_modules/domutils/lib/esm/querying.js
function filter(test, node, recurse = true, limit = Infinity) {
  return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
function find(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne(test, nodes, recurse = true) {
  const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
  for (let i = 0; i < searchedNodes.length; i++) {
    const node = searchedNodes[i];
    if (isTag2(node) && test(node)) {
      return node;
    }
    if (recurse && hasChildren(node) && node.children.length > 0) {
      const found = findOne(test, node.children, true);
      if (found)
        return found;
    }
  }
  return null;
}
function existsOne(test, nodes) {
  return (Array.isArray(nodes) ? nodes : [nodes]).some((node) => isTag2(node) && test(node) || hasChildren(node) && existsOne(test, node.children));
}
function findAll(test, nodes) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (isTag2(elem) && test(elem))
      result.push(elem);
    if (hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

// node_modules/domutils/lib/esm/legacy.js
var Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag2(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data) {
    if (typeof data === "function") {
      return (elem) => isText(elem) && data(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag2(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key2) => {
    const value = options[key2];
    return Object.prototype.hasOwnProperty.call(Checks, key2) ? Checks[key2](value) : getAttribCheck(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node) {
  const test = compileTest(options);
  return test ? test(node) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName19, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName19), nodes, recurse, limit);
}
function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
  return filter(getAttribCheck("class", className), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type), nodes, recurse, limit);
}

// node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current2 = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current2) {
    aParents.unshift(current2);
    current2 = current2.parent;
  }
  current2 = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current2) {
    bParents.unshift(current2);
    current2 = current2.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

// node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a2;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a3;
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href2 = (_a3 = getOneElement("link", children)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch2("summary", children) || fetch2("content", children);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch2("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch2("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a2, _b;
  const childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch2("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName19, node) {
  return getElementsByTagName(tagName19, node, true, 1)[0];
}
function fetch2(tagName19, where, recurse = false) {
  return textContent(getElementsByTagName(tagName19, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName19, where, recurse = false) {
  const val = fetch2(tagName19, where, recurse);
  if (val)
    obj[prop2] = val;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

// node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler4 = new DomHandler(void 0, options);
  new Parser(handler4, options).end(data);
  return handler4.root;
}
function parseDOM(data, options) {
  return parseDocument(data, options).children;
}
function createDocumentStream(callback, options, elementCallback) {
  const handler4 = new DomHandler((error) => callback(error, handler4.root), options, elementCallback);
  return new Parser(handler4, options);
}
function createDomStream(callback, options, elementCallback) {
  const handler4 = new DomHandler(callback, options, elementCallback);
  return new Parser(handler4, options);
}
var parseFeedDefaultOptions = { xmlMode: true };
function parseFeed(feed, options = parseFeedDefaultOptions) {
  return getFeed(parseDOM(feed, options));
}

// node_modules/linkedom/esm/shared/constants.js
var NODE_END = -1;
var ELEMENT_NODE = 1;
var ATTRIBUTE_NODE = 2;
var TEXT_NODE = 3;
var CDATA_SECTION_NODE = 4;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE = 11;
var BLOCK_ELEMENTS = /* @__PURE__ */ new Set(["ARTICLE", "ASIDE", "BLOCKQUOTE", "BODY", "BR", "BUTTON", "CANVAS", "CAPTION", "COL", "COLGROUP", "DD", "DIV", "DL", "DT", "EMBED", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "LI", "UL", "OL", "P"]);
var SHOW_ALL = -1;
var SHOW_ELEMENT = 1;
var SHOW_TEXT = 4;
var SHOW_CDATA_SECTION = 8;
var SHOW_COMMENT = 128;
var DOCUMENT_POSITION_DISCONNECTED = 1;
var DOCUMENT_POSITION_PRECEDING = 2;
var DOCUMENT_POSITION_FOLLOWING = 4;
var DOCUMENT_POSITION_CONTAINS = 8;
var DOCUMENT_POSITION_CONTAINED_BY = 16;
var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";

// node_modules/linkedom/esm/shared/object.js
var {
  assign,
  create,
  defineProperties,
  entries,
  getOwnPropertyDescriptors,
  keys,
  setPrototypeOf
} = Object;

// node_modules/linkedom/esm/shared/utils.js
var $String = String;
var getEnd = (node) => node.nodeType === ELEMENT_NODE ? node[END] : node;
var ignoreCase = ({ ownerDocument }) => ownerDocument[MIME].ignoreCase;
var knownAdjacent = (prev, next) => {
  prev[NEXT] = next;
  next[PREV] = prev;
};
var knownBoundaries = (prev, current2, next) => {
  knownAdjacent(prev, current2);
  knownAdjacent(getEnd(current2), next);
};
var knownSegment = (prev, start, end, next) => {
  knownAdjacent(prev, start);
  knownAdjacent(getEnd(end), next);
};
var knownSiblings = (prev, current2, next) => {
  knownAdjacent(prev, current2);
  knownAdjacent(current2, next);
};
var localCase = ({ localName, ownerDocument }) => {
  return ownerDocument[MIME].ignoreCase ? localName.toUpperCase() : localName;
};
var setAdjacent = (prev, next) => {
  if (prev)
    prev[NEXT] = next;
  if (next)
    next[PREV] = prev;
};

// node_modules/linkedom/esm/shared/shadow-roots.js
var shadowRoots = /* @__PURE__ */ new WeakMap();

// node_modules/linkedom/esm/interface/custom-element-registry.js
var reactive = false;
var Classes = /* @__PURE__ */ new WeakMap();
var customElements = /* @__PURE__ */ new WeakMap();
var attributeChangedCallback = (element, attributeName, oldValue, newValue) => {
  if (reactive && customElements.has(element) && element.attributeChangedCallback && element.constructor.observedAttributes.includes(attributeName)) {
    element.attributeChangedCallback(attributeName, oldValue, newValue);
  }
};
var createTrigger = (method, isConnected2) => (element) => {
  if (customElements.has(element)) {
    const info = customElements.get(element);
    if (info.connected !== isConnected2 && element.isConnected === isConnected2) {
      info.connected = isConnected2;
      if (method in element)
        element[method]();
    }
  }
};
var triggerConnected = createTrigger("connectedCallback", true);
var connectedCallback = (element) => {
  if (reactive) {
    triggerConnected(element);
    if (shadowRoots.has(element))
      element = shadowRoots.get(element).shadowRoot;
    let { [NEXT]: next, [END]: end } = element;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE)
        triggerConnected(next);
      next = next[NEXT];
    }
  }
};
var triggerDisconnected = createTrigger("disconnectedCallback", false);
var disconnectedCallback = (element) => {
  if (reactive) {
    triggerDisconnected(element);
    if (shadowRoots.has(element))
      element = shadowRoots.get(element).shadowRoot;
    let { [NEXT]: next, [END]: end } = element;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE)
        triggerDisconnected(next);
      next = next[NEXT];
    }
  }
};
var CustomElementRegistry = class {
  /**
   * @param {Document} ownerDocument
   */
  constructor(ownerDocument) {
    this.ownerDocument = ownerDocument;
    this.registry = /* @__PURE__ */ new Map();
    this.waiting = /* @__PURE__ */ new Map();
    this.active = false;
  }
  /**
   * @param {string} localName the custom element definition name
   * @param {Function} Class the custom element **Class** definition
   * @param {object?} options the optional object with an `extends` property
   */
  define(localName, Class, options = {}) {
    const { ownerDocument, registry, waiting } = this;
    if (registry.has(localName))
      throw new Error("unable to redefine " + localName);
    if (Classes.has(Class))
      throw new Error("unable to redefine the same class: " + Class);
    this.active = reactive = true;
    const { extends: extend } = options;
    Classes.set(Class, {
      ownerDocument,
      options: { is: extend ? localName : "" },
      localName: extend || localName
    });
    const check = extend ? (element) => {
      return element.localName === extend && element.getAttribute("is") === localName;
    } : (element) => element.localName === localName;
    registry.set(localName, { Class, check });
    if (waiting.has(localName)) {
      for (const resolve of waiting.get(localName))
        resolve(Class);
      waiting.delete(localName);
    }
    ownerDocument.querySelectorAll(
      extend ? `${extend}[is="${localName}"]` : localName
    ).forEach(this.upgrade, this);
  }
  /**
   * @param {Element} element
   */
  upgrade(element) {
    if (customElements.has(element))
      return;
    const { ownerDocument, registry } = this;
    const ce = element.getAttribute("is") || element.localName;
    if (registry.has(ce)) {
      const { Class, check } = registry.get(ce);
      if (check(element)) {
        const { attributes: attributes2, isConnected: isConnected2 } = element;
        for (const attr of attributes2)
          element.removeAttributeNode(attr);
        const values = entries(element);
        for (const [key2] of values)
          delete element[key2];
        setPrototypeOf(element, Class.prototype);
        ownerDocument[UPGRADE] = { element, values };
        new Class(ownerDocument, ce);
        customElements.set(element, { connected: isConnected2 });
        for (const attr of attributes2)
          element.setAttributeNode(attr);
        if (isConnected2 && element.connectedCallback)
          element.connectedCallback();
      }
    }
  }
  /**
   * @param {string} localName the custom element definition name
   */
  whenDefined(localName) {
    const { registry, waiting } = this;
    return new Promise((resolve) => {
      if (registry.has(localName))
        resolve(registry.get(localName).Class);
      else {
        if (!waiting.has(localName))
          waiting.set(localName, []);
        waiting.get(localName).push(resolve);
      }
    });
  }
  /**
   * @param {string} localName the custom element definition name
   * @returns {Function?} the custom element **Class**, if any
   */
  get(localName) {
    const info = this.registry.get(localName);
    return info && info.Class;
  }
  /**
   * @param {Function} Class **Class** of custom element
   * @returns {string?} found tag name or null
   */
  getName(Class) {
    if (Classes.has(Class)) {
      const { localName } = Classes.get(Class);
      return localName;
    }
    return null;
  }
};

// node_modules/linkedom/esm/shared/parse-from-string.js
var { Parser: Parser2 } = esm_exports3;
var notParsing = true;
var append2 = (self, node, active) => {
  const end = self[END];
  node.parentNode = self;
  knownBoundaries(end[PREV], node, end);
  if (active && node.nodeType === ELEMENT_NODE)
    connectedCallback(node);
  return node;
};
var attribute = (element, end, attribute2, value, active) => {
  attribute2[VALUE] = value;
  attribute2.ownerElement = element;
  knownSiblings(end[PREV], attribute2, end);
  if (attribute2.name === "class")
    element.className = value;
  if (active)
    attributeChangedCallback(element, attribute2.name, null, value);
};
var parseFromString = (document, isHTML, markupLanguage) => {
  const { active, registry } = document[CUSTOM_ELEMENTS];
  let node = document;
  let ownerSVGElement = null;
  let parsingCData = false;
  notParsing = false;
  const content = new Parser2({
    // <!DOCTYPE ...>
    onprocessinginstruction(name, data) {
      if (name.toLowerCase() === "!doctype")
        document.doctype = data.slice(name.length).trim();
    },
    // <tagName>
    onopentag(name, attributes2) {
      let create3 = true;
      if (isHTML) {
        if (ownerSVGElement) {
          node = append2(node, document.createElementNS(SVG_NAMESPACE, name), active);
          node.ownerSVGElement = ownerSVGElement;
          create3 = false;
        } else if (name === "svg" || name === "SVG") {
          ownerSVGElement = document.createElementNS(SVG_NAMESPACE, name);
          node = append2(node, ownerSVGElement, active);
          create3 = false;
        } else if (active) {
          const ce = name.includes("-") ? name : attributes2.is || "";
          if (ce && registry.has(ce)) {
            const { Class } = registry.get(ce);
            node = append2(node, new Class(), active);
            delete attributes2.is;
            create3 = false;
          }
        }
      }
      if (create3)
        node = append2(node, document.createElement(name), false);
      let end = node[END];
      for (const name2 of keys(attributes2))
        attribute(node, end, document.createAttribute(name2), attributes2[name2], active);
    },
    // #text, #comment
    oncomment(data) {
      append2(node, document.createComment(data), active);
    },
    ontext(text) {
      if (parsingCData) {
        append2(node, document.createCDATASection(text), active);
      } else {
        append2(node, document.createTextNode(text), active);
      }
    },
    // #cdata
    oncdatastart() {
      parsingCData = true;
    },
    oncdataend() {
      parsingCData = false;
    },
    // </tagName>
    onclosetag() {
      if (isHTML && node === ownerSVGElement)
        ownerSVGElement = null;
      node = node.parentNode;
    }
  }, {
    lowerCaseAttributeNames: false,
    decodeEntities: true,
    xmlMode: !isHTML
  });
  content.write(markupLanguage);
  content.end();
  notParsing = true;
  return document;
};

// node_modules/linkedom/esm/shared/register-html-class.js
var htmlClasses = /* @__PURE__ */ new Map();
var registerHTMLClass = (names, Class) => {
  for (const name of [].concat(names)) {
    htmlClasses.set(name, Class);
    htmlClasses.set(name.toUpperCase(), Class);
  }
};

// node_modules/linkedom/esm/interface/document.js
var import_perf_hooks = __toESM(require_perf_hooks(), 1);

// node_modules/linkedom/esm/shared/jsdon.js
var loopSegment = ({ [NEXT]: next, [END]: end }, json) => {
  while (next !== end) {
    switch (next.nodeType) {
      case ATTRIBUTE_NODE:
        attrAsJSON(next, json);
        break;
      case TEXT_NODE:
      case COMMENT_NODE:
      case CDATA_SECTION_NODE:
        characterDataAsJSON(next, json);
        break;
      case ELEMENT_NODE:
        elementAsJSON(next, json);
        next = getEnd(next);
        break;
      case DOCUMENT_TYPE_NODE:
        documentTypeAsJSON(next, json);
        break;
    }
    next = next[NEXT];
  }
  const last = json.length - 1;
  const value = json[last];
  if (typeof value === "number" && value < 0)
    json[last] += NODE_END;
  else
    json.push(NODE_END);
};
var attrAsJSON = (attr, json) => {
  json.push(ATTRIBUTE_NODE, attr.name);
  const value = attr[VALUE].trim();
  if (value)
    json.push(value);
};
var characterDataAsJSON = (node, json) => {
  const value = node[VALUE];
  if (value.trim())
    json.push(node.nodeType, value);
};
var nonElementAsJSON = (node, json) => {
  json.push(node.nodeType);
  loopSegment(node, json);
};
var documentTypeAsJSON = ({ name, publicId, systemId }, json) => {
  json.push(DOCUMENT_TYPE_NODE, name);
  if (publicId)
    json.push(publicId);
  if (systemId)
    json.push(systemId);
};
var elementAsJSON = (element, json) => {
  json.push(ELEMENT_NODE, element.localName);
  loopSegment(element, json);
};

// node_modules/linkedom/esm/interface/mutation-observer.js
var createRecord = (type, target, addedNodes, removedNodes, attributeName, oldValue) => ({ type, target, addedNodes, removedNodes, attributeName, oldValue });
var queueAttribute = (observer, target, attributeName, attributeFilter, attributeOldValue, oldValue) => {
  if (!attributeFilter || attributeFilter.includes(attributeName)) {
    const { callback, records, scheduled } = observer;
    records.push(createRecord(
      "attributes",
      target,
      [],
      [],
      attributeName,
      attributeOldValue ? oldValue : void 0
    ));
    if (!scheduled) {
      observer.scheduled = true;
      Promise.resolve().then(() => {
        observer.scheduled = false;
        callback(records.splice(0), observer);
      });
    }
  }
};
var attributeChangedCallback2 = (element, attributeName, oldValue) => {
  const { ownerDocument } = element;
  const { active, observers } = ownerDocument[MUTATION_OBSERVER];
  if (active) {
    for (const observer of observers) {
      for (const [
        target,
        {
          childList,
          subtree,
          attributes: attributes2,
          attributeFilter,
          attributeOldValue
        }
      ] of observer.nodes) {
        if (childList) {
          if (subtree && (target === ownerDocument || target.contains(element)) || !subtree && target.children.includes(element)) {
            queueAttribute(
              observer,
              element,
              attributeName,
              attributeFilter,
              attributeOldValue,
              oldValue
            );
            break;
          }
        } else if (attributes2 && target === element) {
          queueAttribute(
            observer,
            element,
            attributeName,
            attributeFilter,
            attributeOldValue,
            oldValue
          );
          break;
        }
      }
    }
  }
};
var moCallback = (element, parentNode) => {
  const { ownerDocument } = element;
  const { active, observers } = ownerDocument[MUTATION_OBSERVER];
  if (active) {
    for (const observer of observers) {
      for (const [target, { subtree, childList, characterData }] of observer.nodes) {
        if (childList) {
          if (parentNode && (target === parentNode || /* c8 ignore next */
          subtree && target.contains(parentNode)) || !parentNode && (subtree && (target === ownerDocument || /* c8 ignore next */
          target.contains(element)) || !subtree && target[characterData ? "childNodes" : "children"].includes(element))) {
            const { callback, records, scheduled } = observer;
            records.push(createRecord(
              "childList",
              target,
              parentNode ? [] : [element],
              parentNode ? [element] : []
            ));
            if (!scheduled) {
              observer.scheduled = true;
              Promise.resolve().then(() => {
                observer.scheduled = false;
                callback(records.splice(0), observer);
              });
            }
            break;
          }
        }
      }
    }
  }
};
var MutationObserverClass = class {
  constructor(ownerDocument) {
    const observers = /* @__PURE__ */ new Set();
    this.observers = observers;
    this.active = false;
    this.class = class MutationObserver {
      constructor(callback) {
        this.callback = callback;
        this.nodes = /* @__PURE__ */ new Map();
        this.records = [];
        this.scheduled = false;
      }
      disconnect() {
        this.records.splice(0);
        this.nodes.clear();
        observers.delete(this);
        ownerDocument[MUTATION_OBSERVER].active = !!observers.size;
      }
      /**
       * @param {Element} target
       * @param {MutationObserverInit} options
       */
      observe(target, options = {
        subtree: false,
        childList: false,
        attributes: false,
        attributeFilter: null,
        attributeOldValue: false,
        characterData: false
        // TODO: not implemented yet
        // characterDataOldValue: false
      }) {
        if ("attributeOldValue" in options || "attributeFilter" in options)
          options.attributes = true;
        options.childList = !!options.childList;
        options.subtree = !!options.subtree;
        this.nodes.set(target, options);
        observers.add(this);
        ownerDocument[MUTATION_OBSERVER].active = true;
      }
      /**
       * @returns {MutationRecord[]}
       */
      takeRecords() {
        return this.records.splice(0);
      }
    };
  }
};

// node_modules/linkedom/esm/shared/attributes.js
var emptyAttributes = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "class",
  "contenteditable",
  "controls",
  "default",
  "defer",
  "disabled",
  "draggable",
  "formnovalidate",
  "hidden",
  "id",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected",
  "style",
  "truespeed"
]);
var setAttribute = (element, attribute2) => {
  const { [VALUE]: value, name } = attribute2;
  attribute2.ownerElement = element;
  knownSiblings(element, attribute2, element[NEXT]);
  if (name === "class")
    element.className = value;
  attributeChangedCallback2(element, name, null);
  attributeChangedCallback(element, name, null, value);
};
var removeAttribute = (element, attribute2) => {
  const { [VALUE]: value, name } = attribute2;
  knownAdjacent(attribute2[PREV], attribute2[NEXT]);
  attribute2.ownerElement = attribute2[PREV] = attribute2[NEXT] = null;
  if (name === "class")
    element[CLASS_LIST] = null;
  attributeChangedCallback2(element, name, value);
  attributeChangedCallback(element, name, value, null);
};
var booleanAttribute = {
  get(element, name) {
    return element.hasAttribute(name);
  },
  set(element, name, value) {
    if (value)
      element.setAttribute(name, "");
    else
      element.removeAttribute(name);
  }
};
var numericAttribute = {
  get(element, name) {
    return parseFloat(element.getAttribute(name) || 0);
  },
  set(element, name, value) {
    element.setAttribute(name, value);
  }
};
var stringAttribute = {
  get(element, name) {
    return element.getAttribute(name) || "";
  },
  set(element, name, value) {
    element.setAttribute(name, value);
  }
};

// node_modules/linkedom/esm/interface/event-target.js
var wm = /* @__PURE__ */ new WeakMap();
function dispatch(event, listener) {
  if (typeof listener === "function")
    listener.call(event.target, event);
  else
    listener.handleEvent(event);
  return event._stopImmediatePropagationFlag;
}
function invokeListeners({ currentTarget, target }) {
  const map = wm.get(currentTarget);
  if (map && map.has(this.type)) {
    const listeners = map.get(this.type);
    if (currentTarget === target) {
      this.eventPhase = this.AT_TARGET;
    } else {
      this.eventPhase = this.BUBBLING_PHASE;
    }
    this.currentTarget = currentTarget;
    this.target = target;
    for (const [listener, options] of listeners) {
      if (options && options.once)
        listeners.delete(listener);
      if (dispatch(this, listener))
        break;
    }
    delete this.currentTarget;
    delete this.target;
    return this.cancelBubble;
  }
}
var DOMEventTarget = class {
  constructor() {
    wm.set(this, /* @__PURE__ */ new Map());
  }
  /**
   * @protected
   */
  _getParent() {
    return null;
  }
  addEventListener(type, listener, options) {
    const map = wm.get(this);
    if (!map.has(type))
      map.set(type, /* @__PURE__ */ new Map());
    map.get(type).set(listener, options);
  }
  removeEventListener(type, listener) {
    const map = wm.get(this);
    if (map.has(type)) {
      const listeners = map.get(type);
      if (listeners.delete(listener) && !listeners.size)
        map.delete(type);
    }
  }
  dispatchEvent(event) {
    let node = this;
    event.eventPhase = event.CAPTURING_PHASE;
    while (node) {
      if (node.dispatchEvent)
        event._path.push({ currentTarget: node, target: this });
      node = event.bubbles && node._getParent && node._getParent();
    }
    event._path.some(invokeListeners, event);
    event._path = [];
    event.eventPhase = event.NONE;
    return !event.defaultPrevented;
  }
};

// node_modules/linkedom/esm/interface/node-list.js
var NodeList = class extends Array {
  item(i) {
    return i < this.length ? this[i] : null;
  }
};

// node_modules/linkedom/esm/interface/node.js
var getParentNodeCount = ({ parentNode }) => {
  let count = 0;
  while (parentNode) {
    count++;
    parentNode = parentNode.parentNode;
  }
  return count;
};
var Node2 = class extends DOMEventTarget {
  static get ELEMENT_NODE() {
    return ELEMENT_NODE;
  }
  static get ATTRIBUTE_NODE() {
    return ATTRIBUTE_NODE;
  }
  static get TEXT_NODE() {
    return TEXT_NODE;
  }
  static get CDATA_SECTION_NODE() {
    return CDATA_SECTION_NODE;
  }
  static get COMMENT_NODE() {
    return COMMENT_NODE;
  }
  static get DOCUMENT_NODE() {
    return DOCUMENT_NODE;
  }
  static get DOCUMENT_FRAGMENT_NODE() {
    return DOCUMENT_FRAGMENT_NODE;
  }
  static get DOCUMENT_TYPE_NODE() {
    return DOCUMENT_TYPE_NODE;
  }
  constructor(ownerDocument, localName, nodeType) {
    super();
    this.ownerDocument = ownerDocument;
    this.localName = localName;
    this.nodeType = nodeType;
    this.parentNode = null;
    this[NEXT] = null;
    this[PREV] = null;
  }
  get ELEMENT_NODE() {
    return ELEMENT_NODE;
  }
  get ATTRIBUTE_NODE() {
    return ATTRIBUTE_NODE;
  }
  get TEXT_NODE() {
    return TEXT_NODE;
  }
  get CDATA_SECTION_NODE() {
    return CDATA_SECTION_NODE;
  }
  get COMMENT_NODE() {
    return COMMENT_NODE;
  }
  get DOCUMENT_NODE() {
    return DOCUMENT_NODE;
  }
  get DOCUMENT_FRAGMENT_NODE() {
    return DOCUMENT_FRAGMENT_NODE;
  }
  get DOCUMENT_TYPE_NODE() {
    return DOCUMENT_TYPE_NODE;
  }
  get baseURI() {
    const ownerDocument = this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument;
    if (ownerDocument) {
      const base = ownerDocument.querySelector("base");
      if (base)
        return base.getAttribute("href");
      const { location } = ownerDocument.defaultView;
      if (location)
        return location.href;
    }
    return null;
  }
  /* c8 ignore start */
  // mixin: node
  get isConnected() {
    return false;
  }
  get nodeName() {
    return this.localName;
  }
  get parentElement() {
    return null;
  }
  get previousSibling() {
    return null;
  }
  get previousElementSibling() {
    return null;
  }
  get nextSibling() {
    return null;
  }
  get nextElementSibling() {
    return null;
  }
  get childNodes() {
    return new NodeList();
  }
  get firstChild() {
    return null;
  }
  get lastChild() {
    return null;
  }
  // default values
  get nodeValue() {
    return null;
  }
  set nodeValue(value) {
  }
  get textContent() {
    return null;
  }
  set textContent(value) {
  }
  normalize() {
  }
  cloneNode() {
    return null;
  }
  contains() {
    return false;
  }
  /**
   * Inserts a node before a reference node as a child of this parent node.
   * @param {Node} newNode The node to be inserted.
   * @param {Node} referenceNode The node before which newNode is inserted. If this is null, then newNode is inserted at the end of node's child nodes.
   * @returns The added child
   */
  // eslint-disable-next-line no-unused-vars
  insertBefore(newNode, referenceNode) {
    return newNode;
  }
  /**
   * Adds a node to the end of the list of children of this node.
   * @param {Node} child The node to append to the given parent node.
   * @returns The appended child.
   */
  appendChild(child) {
    return child;
  }
  /**
   * Replaces a child node within this node
   * @param {Node} newChild The new node to replace oldChild.
   * @param {Node} oldChild The child to be replaced.
   * @returns The replaced Node. This is the same node as oldChild.
   */
  replaceChild(newChild, oldChild) {
    return oldChild;
  }
  /**
   * Removes a child node from the DOM.
   * @param {Node} child A Node that is the child node to be removed from the DOM.
   * @returns The removed node.
   */
  removeChild(child) {
    return child;
  }
  toString() {
    return "";
  }
  /* c8 ignore stop */
  hasChildNodes() {
    return !!this.lastChild;
  }
  isSameNode(node) {
    return this === node;
  }
  // TODO: attributes?
  compareDocumentPosition(target) {
    let result = 0;
    if (this !== target) {
      let self = getParentNodeCount(this);
      let other = getParentNodeCount(target);
      if (self < other) {
        result += DOCUMENT_POSITION_FOLLOWING;
        if (this.contains(target))
          result += DOCUMENT_POSITION_CONTAINED_BY;
      } else if (other < self) {
        result += DOCUMENT_POSITION_PRECEDING;
        if (target.contains(this))
          result += DOCUMENT_POSITION_CONTAINS;
      } else if (self && other) {
        const { childNodes } = this.parentNode;
        if (childNodes.indexOf(this) < childNodes.indexOf(target))
          result += DOCUMENT_POSITION_FOLLOWING;
        else
          result += DOCUMENT_POSITION_PRECEDING;
      }
      if (!self || !other) {
        result += DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
        result += DOCUMENT_POSITION_DISCONNECTED;
      }
    }
    return result;
  }
  isEqualNode(node) {
    if (this === node)
      return true;
    if (this.nodeType === node.nodeType) {
      switch (this.nodeType) {
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE: {
          const aNodes = this.childNodes;
          const bNodes = node.childNodes;
          return aNodes.length === bNodes.length && aNodes.every((node2, i) => node2.isEqualNode(bNodes[i]));
        }
      }
      return this.toString() === node.toString();
    }
    return false;
  }
  /**
   * @protected
   */
  _getParent() {
    return this.parentNode;
  }
  /**
   * Calling it on an element inside a standard web page will return an HTMLDocument object representing the entire page (or <iframe>).
   * Calling it on an element inside a shadow DOM will return the associated ShadowRoot.
   * @return {ShadowRoot | HTMLDocument}
   */
  getRootNode() {
    let root = this;
    while (root.parentNode)
      root = root.parentNode;
    return root;
  }
};

// node_modules/linkedom/esm/shared/text-escaper.js
var { replace } = "";
var ca = /[<>&\xA0]/g;
var esca = {
  "\xA0": "&#160;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
var pe = (m) => esca[m];
var escape2 = (es) => replace.call(es, ca, pe);

// node_modules/linkedom/esm/interface/attr.js
var QUOTE = /"/g;
var Attr = class _Attr extends Node2 {
  constructor(ownerDocument, name, value = "") {
    super(ownerDocument, name, ATTRIBUTE_NODE);
    this.ownerElement = null;
    this.name = $String(name);
    this[VALUE] = $String(value);
    this[CHANGED] = false;
  }
  get value() {
    return this[VALUE];
  }
  set value(newValue) {
    const { [VALUE]: oldValue, name, ownerElement } = this;
    this[VALUE] = $String(newValue);
    this[CHANGED] = true;
    if (ownerElement) {
      attributeChangedCallback2(ownerElement, name, oldValue);
      attributeChangedCallback(ownerElement, name, oldValue, this[VALUE]);
    }
  }
  cloneNode() {
    const { ownerDocument, name, [VALUE]: value } = this;
    return new _Attr(ownerDocument, name, value);
  }
  toString() {
    const { name, [VALUE]: value } = this;
    if (emptyAttributes.has(name) && !value) {
      return ignoreCase(this) ? name : `${name}=""`;
    }
    const escapedValue = ignoreCase(this) ? value.replace(QUOTE, "&quot;") : escape2(value);
    return `${name}="${escapedValue}"`;
  }
  toJSON() {
    const json = [];
    attrAsJSON(this, json);
    return json;
  }
};

// node_modules/linkedom/esm/shared/node.js
var isConnected = ({ ownerDocument, parentNode }) => {
  while (parentNode) {
    if (parentNode === ownerDocument)
      return true;
    parentNode = parentNode.parentNode || parentNode.host;
  }
  return false;
};
var parentElement = ({ parentNode }) => {
  if (parentNode) {
    switch (parentNode.nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        return null;
    }
  }
  return parentNode;
};
var previousSibling = ({ [PREV]: prev }) => {
  switch (prev ? prev.nodeType : 0) {
    case NODE_END:
      return prev[START];
    case TEXT_NODE:
    case COMMENT_NODE:
    case CDATA_SECTION_NODE:
      return prev;
  }
  return null;
};
var nextSibling = (node) => {
  const next = getEnd(node)[NEXT];
  return next && (next.nodeType === NODE_END ? null : next);
};

// node_modules/linkedom/esm/mixin/non-document-type-child-node.js
var nextElementSibling2 = (node) => {
  let next = nextSibling(node);
  while (next && next.nodeType !== ELEMENT_NODE)
    next = nextSibling(next);
  return next;
};
var previousElementSibling = (node) => {
  let prev = previousSibling(node);
  while (prev && prev.nodeType !== ELEMENT_NODE)
    prev = previousSibling(prev);
  return prev;
};

// node_modules/linkedom/esm/mixin/child-node.js
var asFragment = (ownerDocument, nodes) => {
  const fragment = ownerDocument.createDocumentFragment();
  fragment.append(...nodes);
  return fragment;
};
var before = (node, nodes) => {
  const { ownerDocument, parentNode } = node;
  if (parentNode)
    parentNode.insertBefore(
      asFragment(ownerDocument, nodes),
      node
    );
};
var after = (node, nodes) => {
  const { ownerDocument, parentNode } = node;
  if (parentNode)
    parentNode.insertBefore(
      asFragment(ownerDocument, nodes),
      getEnd(node)[NEXT]
    );
};
var replaceWith = (node, nodes) => {
  const { ownerDocument, parentNode } = node;
  if (parentNode) {
    if (nodes.includes(node))
      replaceWith(node, [node = node.cloneNode()]);
    parentNode.insertBefore(
      asFragment(ownerDocument, nodes),
      node
    );
    node.remove();
  }
};
var remove = (prev, current2, next) => {
  const { parentNode, nodeType } = current2;
  if (prev || next) {
    setAdjacent(prev, next);
    current2[PREV] = null;
    getEnd(current2)[NEXT] = null;
  }
  if (parentNode) {
    current2.parentNode = null;
    moCallback(current2, parentNode);
    if (nodeType === ELEMENT_NODE)
      disconnectedCallback(current2);
  }
};

// node_modules/linkedom/esm/interface/character-data.js
var CharacterData = class extends Node2 {
  constructor(ownerDocument, localName, nodeType, data) {
    super(ownerDocument, localName, nodeType);
    this[VALUE] = $String(data);
  }
  // <Mixins>
  get isConnected() {
    return isConnected(this);
  }
  get parentElement() {
    return parentElement(this);
  }
  get previousSibling() {
    return previousSibling(this);
  }
  get nextSibling() {
    return nextSibling(this);
  }
  get previousElementSibling() {
    return previousElementSibling(this);
  }
  get nextElementSibling() {
    return nextElementSibling2(this);
  }
  before(...nodes) {
    before(this, nodes);
  }
  after(...nodes) {
    after(this, nodes);
  }
  replaceWith(...nodes) {
    replaceWith(this, nodes);
  }
  remove() {
    remove(this[PREV], this, this[NEXT]);
  }
  // </Mixins>
  // CharacterData only
  /* c8 ignore start */
  get data() {
    return this[VALUE];
  }
  set data(value) {
    this[VALUE] = $String(value);
    moCallback(this, this.parentNode);
  }
  get nodeValue() {
    return this.data;
  }
  set nodeValue(value) {
    this.data = value;
  }
  get textContent() {
    return this.data;
  }
  set textContent(value) {
    this.data = value;
  }
  get length() {
    return this.data.length;
  }
  substringData(offset, count) {
    return this.data.substr(offset, count);
  }
  appendData(data) {
    this.data += data;
  }
  insertData(offset, data) {
    const { data: t } = this;
    this.data = t.slice(0, offset) + data + t.slice(offset);
  }
  deleteData(offset, count) {
    const { data: t } = this;
    this.data = t.slice(0, offset) + t.slice(offset + count);
  }
  replaceData(offset, count, data) {
    const { data: t } = this;
    this.data = t.slice(0, offset) + data + t.slice(offset + count);
  }
  /* c8 ignore stop */
  toJSON() {
    const json = [];
    characterDataAsJSON(this, json);
    return json;
  }
};

// node_modules/linkedom/esm/interface/cdata-section.js
var CDATASection = class _CDATASection extends CharacterData {
  constructor(ownerDocument, data = "") {
    super(ownerDocument, "#cdatasection", CDATA_SECTION_NODE, data);
  }
  cloneNode() {
    const { ownerDocument, [VALUE]: data } = this;
    return new _CDATASection(ownerDocument, data);
  }
  toString() {
    return `<![CDATA[${this[VALUE]}]]>`;
  }
};

// node_modules/linkedom/esm/interface/comment.js
var Comment3 = class _Comment extends CharacterData {
  constructor(ownerDocument, data = "") {
    super(ownerDocument, "#comment", COMMENT_NODE, data);
  }
  cloneNode() {
    const { ownerDocument, [VALUE]: data } = this;
    return new _Comment(ownerDocument, data);
  }
  toString() {
    return `<!--${this[VALUE]}-->`;
  }
};

// node_modules/css-select/lib/esm/index.js
var import_boolbase6 = __toESM(require_boolbase(), 1);

// node_modules/css-what/lib/es/types.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

// node_modules/css-what/lib/es/parse.js
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
var unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace2(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse(selector) {
  const subselects2 = [];
  const endIndex = parseSelector(subselects2, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector(subselects2, selector, selectorIndex) {
  let tokens = [];
  function getName3(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace2(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName3(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector.length) {
    const firstChar = selector.charCodeAt(selectorIndex);
    switch (firstChar) {
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
          ensureNotTraversal();
          tokens.push({ type: SelectorType.Descendant });
        }
        stripWhitespace(1);
        break;
      }
      case 62: {
        addTraversal(SelectorType.Child);
        stripWhitespace(1);
        break;
      }
      case 60: {
        addTraversal(SelectorType.Parent);
        stripWhitespace(1);
        break;
      }
      case 126: {
        addTraversal(SelectorType.Sibling);
        stripWhitespace(1);
        break;
      }
      case 43: {
        addTraversal(SelectorType.Adjacent);
        stripWhitespace(1);
        break;
      }
      case 46: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91: {
        stripWhitespace(1);
        let name;
        let namespace = null;
        if (selector.charCodeAt(selectorIndex) === 124) {
          name = getName3(1);
        } else if (selector.startsWith("*|", selectorIndex)) {
          namespace = "*";
          name = getName3(2);
        } else {
          name = getName3(0);
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
            namespace = name;
            name = getName3(1);
          }
        }
        stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
        if (possibleAction) {
          action = possibleAction;
          if (selector.charCodeAt(selectorIndex + 1) !== 61) {
            throw new Error("Expected `=`");
          }
          stripWhitespace(2);
        } else if (selector.charCodeAt(selectorIndex) === 61) {
          action = AttributeAction.Equals;
          stripWhitespace(1);
        }
        let value = "";
        let ignoreCase2 = null;
        if (action !== "exists") {
          if (isQuote(selector.charCodeAt(selectorIndex))) {
            const quote = selector.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
              sectionEnd += 1;
            }
            if (selector.charCodeAt(sectionEnd) !== quote) {
              throw new Error("Attribute value didn't end");
            }
            value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
            selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            while (selectorIndex < selector.length && (!isWhitespace2(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
              selectorIndex += 1;
            }
            value = unescapeCSS(selector.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
          if (forceIgnore === 115) {
            ignoreCase2 = false;
            stripWhitespace(1);
          } else if (forceIgnore === 105) {
            ignoreCase2 = true;
            stripWhitespace(1);
          }
        }
        if (selector.charCodeAt(selectorIndex) !== 93) {
          throw new Error("Attribute selector didn't terminate");
        }
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name,
          action,
          value,
          namespace,
          ignoreCase: ignoreCase2
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58: {
        if (selector.charCodeAt(selectorIndex + 1) === 58) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName3(2).toLowerCase(),
            data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
          });
          continue;
        }
        const name = getName3(1).toLowerCase();
        let data = null;
        if (selector.charCodeAt(selectorIndex) === 40) {
          if (unpackPseudos.has(name)) {
            if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
            }
            data = [];
            selectorIndex = parseSelector(data, selector, selectorIndex + 1);
            if (selector.charCodeAt(selectorIndex) !== 41) {
              throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
            }
            selectorIndex += 1;
          } else {
            data = readValueWithParenthesis();
            if (stripQuotesFromPseudos.has(name)) {
              const quot = data.charCodeAt(0);
              if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                data = data.slice(1, -1);
              }
            }
            data = unescapeCSS(data);
          }
        }
        tokens.push({ type: SelectorType.Pseudo, name, data });
        break;
      }
      case 44: {
        finalizeSubselector();
        tokens = [];
        stripWhitespace(1);
        break;
      }
      default: {
        if (selector.startsWith("/*", selectorIndex)) {
          const endIndex = selector.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0) {
            throw new Error("Comment was not terminated");
          }
          selectorIndex = endIndex + 2;
          if (tokens.length === 0) {
            stripWhitespace(0);
          }
          break;
        }
        let namespace = null;
        let name;
        if (firstChar === 42) {
          selectorIndex += 1;
          name = "*";
        } else if (firstChar === 124) {
          name = "";
          if (selector.charCodeAt(selectorIndex + 1) === 124) {
            addTraversal(SelectorType.ColumnCombinator);
            stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector.slice(selectorIndex))) {
          name = getName3(0);
        } else {
          break loop;
        }
        if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
          namespace = name;
          if (selector.charCodeAt(selectorIndex + 1) === 42) {
            name = "*";
            selectorIndex += 2;
          } else {
            name = getName3(1);
          }
        }
        tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
      }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}

// node_modules/css-select/lib/esm/compile.js
var import_boolbase5 = __toESM(require_boolbase(), 1);

// node_modules/css-select/lib/esm/sort.js
var procedure = /* @__PURE__ */ new Map([
  [SelectorType.Universal, 50],
  [SelectorType.Tag, 30],
  [SelectorType.Attribute, 1],
  [SelectorType.Pseudo, 0]
]);
function isTraversal2(token) {
  return !procedure.has(token.type);
}
var attributes = /* @__PURE__ */ new Map([
  [AttributeAction.Exists, 10],
  [AttributeAction.Equals, 8],
  [AttributeAction.Not, 7],
  [AttributeAction.Start, 6],
  [AttributeAction.End, 6],
  [AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  const procs = arr.map(getProcedure);
  for (let i = 1; i < arr.length; i++) {
    const procNew = procs[i];
    if (procNew < 0)
      continue;
    for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      const token = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
function getProcedure(token) {
  var _a2, _b;
  let proc = (_a2 = procedure.get(token.type)) !== null && _a2 !== void 0 ? _a2 : -1;
  if (token.type === SelectorType.Attribute) {
    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (token.action === AttributeAction.Equals && token.name === "id") {
      proc = 9;
    }
    if (token.ignoreCase) {
      proc >>= 1;
    }
  } else if (token.type === SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token.data)) {
      proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}

// node_modules/css-select/lib/esm/attributes.js
var import_boolbase = __toESM(require_boolbase(), 1);
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
var attributeRules = {
  equals(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter2.getAttributeValue(elem, name);
        return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name) === value && next(elem);
  },
  hyphen(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    const len = value.length;
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr = adapter2.getAttributeValue(elem, name);
        return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function hyphen(elem) {
      const attr = adapter2.getAttributeValue(elem, name);
      return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
    };
  },
  element(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name, value } = data;
    if (/\s/.test(value)) {
      return import_boolbase.default.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data, options) ? "i" : "");
    return function element(elem) {
      const attr = adapter2.getAttributeValue(elem, name);
      return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
    };
  },
  exists(next, { name }, { adapter: adapter2 }) {
    return (elem) => adapter2.hasAttrib(elem, name) && next(elem);
  },
  start(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    const len = value.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter2.getAttributeValue(elem, name);
        return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.startsWith(value)) && next(elem);
    };
  },
  end(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    const len = -value.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        var _a2;
        return ((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.substr(len).toLowerCase()) === value && next(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.endsWith(value)) && next(elem);
    };
  },
  any(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name, value } = data;
    if (value === "") {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      const regex = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        const attr = adapter2.getAttributeValue(elem, name);
        return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.includes(value)) && next(elem);
    };
  },
  not(next, data, options) {
    const { adapter: adapter2 } = options;
    const { name } = data;
    let { value } = data;
    if (value === "") {
      return (elem) => !!adapter2.getAttributeValue(elem, name) && next(elem);
    } else if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter2.getAttributeValue(elem, name);
        return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name) !== value && next(elem);
  }
};

// node_modules/nth-check/lib/esm/parse.js
var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
function parse2(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}

// node_modules/nth-check/lib/esm/compile.js
var import_boolbase2 = __toESM(require_boolbase(), 1);
function compile(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return import_boolbase2.default.falseFunc;
  if (a === -1)
    return (index) => index <= b;
  if (a === 0)
    return (index) => index === b;
  if (a === 1)
    return b < 0 ? import_boolbase2.default.trueFunc : (index) => index >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index) => index >= b && index % absA === bMod : (index) => index <= b && index % absA === bMod;
}

// node_modules/nth-check/lib/esm/index.js
function nthCheck(formula) {
  return compile(parse2(formula));
}

// node_modules/css-select/lib/esm/pseudo-selectors/filters.js
var import_boolbase3 = __toESM(require_boolbase(), 1);
function getChildFunc(next, adapter2) {
  return (elem) => {
    const parent = adapter2.getParent(elem);
    return parent != null && adapter2.isTag(parent) && next(elem);
  };
}
var filters = {
  contains(next, text, { adapter: adapter2 }) {
    return function contains(elem) {
      return next(elem) && adapter2.getText(elem).includes(text);
    };
  },
  icontains(next, text, { adapter: adapter2 }) {
    const itext = text.toLowerCase();
    return function icontains(elem) {
      return next(elem) && adapter2.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next, adapter2);
    return function nthChild(elem) {
      const siblings = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings.length; i++) {
        if (equals(elem, siblings[i]))
          break;
        if (adapter2.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-child"(next, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next, adapter2);
    return function nthLastChild(elem) {
      const siblings = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = siblings.length - 1; i >= 0; i--) {
        if (equals(elem, siblings[i]))
          break;
        if (adapter2.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-of-type"(next, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next, adapter2);
    return function nthOfType(elem) {
      const siblings = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings.length; i++) {
        const currentSibling = siblings[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-of-type"(next, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next, adapter2);
    return function nthLastOfType(elem) {
      const siblings = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = siblings.length - 1; i >= 0; i--) {
        const currentSibling = siblings[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  // TODO determine the actual root element
  root(next, _rule, { adapter: adapter2 }) {
    return (elem) => {
      const parent = adapter2.getParent(elem);
      return (parent == null || !adapter2.isTag(parent)) && next(elem);
    };
  },
  scope(next, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      return filters["root"](next, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals(context[0], elem) && next(elem);
    }
    return (elem) => context.includes(elem) && next(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name) {
  return function dynamicPseudo(next, _rule, { adapter: adapter2 }) {
    const func = adapter2[name];
    if (typeof func !== "function") {
      return import_boolbase3.default.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next(elem);
    };
  };
}

// node_modules/css-select/lib/esm/pseudo-selectors/pseudos.js
var pseudos = {
  empty(elem, { adapter: adapter2 }) {
    return !adapter2.getChildren(elem).some((elem2) => (
      // FIXME: `getText` call is potentially expensive.
      adapter2.isTag(elem2) || adapter2.getText(elem2) !== ""
    ));
  },
  "first-child"(elem, { adapter: adapter2, equals }) {
    if (adapter2.prevElementSibling) {
      return adapter2.prevElementSibling(elem) == null;
    }
    const firstChild = adapter2.getSiblings(elem).find((elem2) => adapter2.isTag(elem2));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter: adapter2, equals }) {
    const siblings = adapter2.getSiblings(elem);
    for (let i = siblings.length - 1; i >= 0; i--) {
      if (equals(elem, siblings[i]))
        return true;
      if (adapter2.isTag(siblings[i]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter: adapter2, equals }) {
    const siblings = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i = 0; i < siblings.length; i++) {
      const currentSibling = siblings[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter: adapter2, equals }) {
    const siblings = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i = siblings.length - 1; i >= 0; i--) {
      const currentSibling = siblings[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter: adapter2, equals }) {
    const elemName = adapter2.getName(elem);
    return adapter2.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter2.isTag(sibling) || adapter2.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter: adapter2, equals }) {
    return adapter2.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter2.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
  }
}

// node_modules/css-select/lib/esm/pseudo-selectors/aliases.js
var aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};

// node_modules/css-select/lib/esm/pseudo-selectors/subselects.js
var import_boolbase4 = __toESM(require_boolbase(), 1);
var PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter2) {
  if (next === import_boolbase4.default.falseFunc)
    return import_boolbase4.default.falseFunc;
  return (elem) => adapter2.isTag(elem) && next(elem);
}
function getNextSiblings(elem, adapter2) {
  const siblings = adapter2.getSiblings(elem);
  if (siblings.length <= 1)
    return [];
  const elemIndex = siblings.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings.length - 1)
    return [];
  return siblings.slice(elemIndex + 1).filter(adapter2.isTag);
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
var is = (next, token, options, context, compileToken2) => {
  const func = compileToken2(token, copyOptions(options), context);
  return func === import_boolbase4.default.trueFunc ? next : func === import_boolbase4.default.falseFunc ? import_boolbase4.default.falseFunc : (elem) => func(elem) && next(elem);
};
var subselects = {
  is,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is,
  where: is,
  not(next, token, options, context, compileToken2) {
    const func = compileToken2(token, copyOptions(options), context);
    return func === import_boolbase4.default.falseFunc ? next : func === import_boolbase4.default.trueFunc ? import_boolbase4.default.falseFunc : (elem) => !func(elem) && next(elem);
  },
  has(next, subselect, options, _context, compileToken2) {
    const { adapter: adapter2 } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal2)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT]
    ) : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === import_boolbase4.default.falseFunc)
      return import_boolbase4.default.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter2);
    if (context && compiled !== import_boolbase4.default.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next(elem))
          return false;
        context[0] = elem;
        const childs = adapter2.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter2)] : childs;
        return adapter2.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next(elem) && adapter2.existsOne(hasElement, adapter2.getChildren(elem));
  }
};

// node_modules/css-select/lib/esm/pseudo-selectors/index.js
function compilePseudoSelector(next, selector, options, context, compileToken2) {
  var _a2;
  const { name, data } = selector;
  if (Array.isArray(data)) {
    if (!(name in subselects)) {
      throw new Error(`Unknown pseudo-class :${name}(${data})`);
    }
    return subselects[name](next, data, options, context, compileToken2);
  }
  const userPseudo = (_a2 = options.pseudos) === null || _a2 === void 0 ? void 0 : _a2[name];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name];
  if (typeof stringPseudo === "string") {
    if (data != null) {
      throw new Error(`Pseudo ${name} doesn't have any arguments`);
    }
    const alias = parse(stringPseudo);
    return subselects["is"](next, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name, data, 1);
    return (elem) => userPseudo(elem, data) && next(elem);
  }
  if (name in filters) {
    return filters[name](next, data, options, context);
  }
  if (name in pseudos) {
    const pseudo = pseudos[name];
    verifyPseudoArgs(pseudo, name, data, 2);
    return (elem) => pseudo(elem, options, data) && next(elem);
  }
  throw new Error(`Unknown pseudo-class :${name}`);
}

// node_modules/css-select/lib/esm/general.js
function getElementParent(node, adapter2) {
  const parent = adapter2.getParent(node);
  if (parent && adapter2.isTag(parent)) {
    return parent;
  }
  return null;
}
function compileGeneralSelector(next, selector, options, context, compileToken2) {
  const { adapter: adapter2, equals } = options;
  switch (selector.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules[selector.action](next, selector, options);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(next, selector, options, context, compileToken2);
    }
    case SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name } = selector;
      if (!options.xmlMode || options.lowerCaseTags) {
        name = name.toLowerCase();
      }
      return function tag(elem) {
        return adapter2.getName(elem) === name && next(elem);
      };
    }
    case SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current2 = elem;
          while (current2 = getElementParent(current2, adapter2)) {
            if (next(current2)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current2 = elem;
        while (current2 = getElementParent(current2, adapter2)) {
          if (!isFalseCache.has(current2)) {
            if (adapter2.isTag(current2) && next(current2)) {
              return true;
            }
            isFalseCache.add(current2);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current2 = elem;
        do {
          if (next(current2))
            return true;
        } while (current2 = getElementParent(current2, adapter2));
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent(elem) {
        return adapter2.getChildren(elem).some((elem2) => adapter2.isTag(elem2) && next(elem2));
      };
    }
    case SelectorType.Child: {
      return function child(elem) {
        const parent = adapter2.getParent(elem);
        return parent != null && adapter2.isTag(parent) && next(parent);
      };
    }
    case SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings = adapter2.getSiblings(elem);
        for (let i = 0; i < siblings.length; i++) {
          const currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling) && next(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter2.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter2.prevElementSibling(elem);
          return previous != null && next(previous);
        };
      }
      return function adjacent(elem) {
        const siblings = adapter2.getSiblings(elem);
        let lastElement;
        for (let i = 0; i < siblings.length; i++) {
          const currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next;
    }
  }
}

// node_modules/css-select/lib/esm/compile.js
function compile2(selector, options, context) {
  const next = compileUnsafe(selector, options, context);
  return ensureIsTag(next, options.adapter);
}
function compileUnsafe(selector, options, context) {
  const token = typeof selector === "string" ? parse(selector) : selector;
  return compileToken(token, options, context);
}
function includesScopePseudo(t) {
  return t.type === SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((data) => data.some(includesScopePseudo)));
}
var DESCENDANT_TOKEN = { type: SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token, { adapter: adapter2 }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
    const parent = adapter2.isTag(e) && adapter2.getParent(e);
    return e === PLACEHOLDER_ELEMENT || parent && adapter2.isTag(parent);
  }));
  for (const t of token) {
    if (t.length > 0 && isTraversal2(t[0]) && t[0].type !== SelectorType.Descendant) {
    } else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, context) {
  var _a2;
  token.forEach(sortByProcedure);
  context = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token, options, finalContext);
  } else if (token.some((t) => t.length > 0 && isTraversal2(t[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query2 = token.map((rules) => {
    if (rules.length >= 2) {
      const [first, second] = rules;
      if (first.type !== SelectorType.Pseudo || first.name !== "scope") {
      } else if (isArrayContext && second.type === SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options, finalContext);
  }).reduce(reduceRules, import_boolbase5.default.falseFunc);
  query2.shouldTestNextSiblings = shouldTestNextSiblings;
  return query2;
}
function compileRules(rules, options, context) {
  var _a2;
  return rules.reduce((previous, rule) => previous === import_boolbase5.default.falseFunc ? import_boolbase5.default.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a2 = options.rootFunc) !== null && _a2 !== void 0 ? _a2 : import_boolbase5.default.trueFunc);
}
function reduceRules(a, b) {
  if (b === import_boolbase5.default.falseFunc || a === import_boolbase5.default.trueFunc) {
    return a;
  }
  if (a === import_boolbase5.default.falseFunc || b === import_boolbase5.default.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}

// node_modules/css-select/lib/esm/index.js
var defaultEquals = (a, b) => a === b;
var defaultOptions = {
  adapter: esm_exports2,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a2, _b, _c, _d;
  const opts = options !== null && options !== void 0 ? options : defaultOptions;
  (_a2 = opts.adapter) !== null && _a2 !== void 0 ? _a2 : opts.adapter = esm_exports2;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    const opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
var compile3 = wrapCompile(compile2);
var _compileUnsafe = wrapCompile(compileUnsafe);
var _compileToken = wrapCompile(compileToken);
function getSelectorFunc(searchFunc) {
  return function select(query2, elements, options) {
    const opts = convertOptionFormats(options);
    if (typeof query2 !== "function") {
      query2 = compileUnsafe(query2, opts, elements);
    }
    const filteredElements = prepareContext(elements, opts.adapter, query2.shouldTestNextSiblings);
    return searchFunc(query2, filteredElements, opts);
  };
}
function prepareContext(elems, adapter2, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter2);
  }
  return Array.isArray(elems) ? adapter2.removeSubsets(elems) : adapter2.getChildren(elems);
}
function appendNextSiblings(elem, adapter2) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i = 0; i < elemsLength; i++) {
    const nextSiblings = getNextSiblings(elems[i], adapter2);
    elems.push(...nextSiblings);
  }
  return elems;
}
var selectAll = getSelectorFunc((query2, elems, options) => query2 === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query2, elems));
var selectOne = getSelectorFunc((query2, elems, options) => query2 === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query2, elems));
function is2(elem, query2, options) {
  const opts = convertOptionFormats(options);
  return (typeof query2 === "function" ? query2 : compile2(query2, opts))(elem);
}

// node_modules/linkedom/esm/shared/matches.js
var { isArray } = Array;
var isTag3 = ({ nodeType }) => nodeType === ELEMENT_NODE;
var existsOne2 = (test, elements) => elements.some(
  (element) => isTag3(element) && (test(element) || existsOne2(test, getChildren2(element)))
);
var getAttributeValue2 = (element, name) => name === "class" ? element.classList.value : element.getAttribute(name);
var getChildren2 = ({ childNodes }) => childNodes;
var getName2 = (element) => {
  const { localName } = element;
  return ignoreCase(element) ? localName.toLowerCase() : localName;
};
var getParent2 = ({ parentNode }) => parentNode;
var getSiblings2 = (element) => {
  const { parentNode } = element;
  return parentNode ? getChildren2(parentNode) : element;
};
var getText2 = (node) => {
  if (isArray(node))
    return node.map(getText2).join("");
  if (isTag3(node))
    return getText2(getChildren2(node));
  if (node.nodeType === TEXT_NODE)
    return node.data;
  return "";
};
var hasAttrib2 = (element, name) => element.hasAttribute(name);
var removeSubsets2 = (nodes) => {
  let { length } = nodes;
  while (length--) {
    const node = nodes[length];
    if (length && -1 < nodes.lastIndexOf(node, length - 1)) {
      nodes.splice(length, 1);
      continue;
    }
    for (let { parentNode } = node; parentNode; parentNode = parentNode.parentNode) {
      if (nodes.includes(parentNode)) {
        nodes.splice(length, 1);
        break;
      }
    }
  }
  return nodes;
};
var findAll2 = (test, nodes) => {
  const matches2 = [];
  for (const node of nodes) {
    if (isTag3(node)) {
      if (test(node))
        matches2.push(node);
      matches2.push(...findAll2(test, getChildren2(node)));
    }
  }
  return matches2;
};
var findOne2 = (test, nodes) => {
  for (let node of nodes)
    if (test(node) || (node = findOne2(test, getChildren2(node))))
      return node;
  return null;
};
var adapter = {
  isTag: isTag3,
  existsOne: existsOne2,
  getAttributeValue: getAttributeValue2,
  getChildren: getChildren2,
  getName: getName2,
  getParent: getParent2,
  getSiblings: getSiblings2,
  getText: getText2,
  hasAttrib: hasAttrib2,
  removeSubsets: removeSubsets2,
  findAll: findAll2,
  findOne: findOne2
};
var prepareMatch = (element, selectors) => compile3(
  selectors,
  {
    context: selectors.includes(":scope") ? element : void 0,
    xmlMode: !ignoreCase(element),
    adapter
  }
);
var matches = (element, selectors) => is2(
  element,
  selectors,
  {
    strict: true,
    context: selectors.includes(":scope") ? element : void 0,
    xmlMode: !ignoreCase(element),
    adapter
  }
);

// node_modules/linkedom/esm/interface/text.js
var Text3 = class _Text extends CharacterData {
  constructor(ownerDocument, data = "") {
    super(ownerDocument, "#text", TEXT_NODE, data);
  }
  get wholeText() {
    const text = [];
    let { previousSibling: previousSibling2, nextSibling: nextSibling2 } = this;
    while (previousSibling2) {
      if (previousSibling2.nodeType === TEXT_NODE)
        text.unshift(previousSibling2[VALUE]);
      else
        break;
      previousSibling2 = previousSibling2.previousSibling;
    }
    text.push(this[VALUE]);
    while (nextSibling2) {
      if (nextSibling2.nodeType === TEXT_NODE)
        text.push(nextSibling2[VALUE]);
      else
        break;
      nextSibling2 = nextSibling2.nextSibling;
    }
    return text.join("");
  }
  cloneNode() {
    const { ownerDocument, [VALUE]: data } = this;
    return new _Text(ownerDocument, data);
  }
  toString() {
    return escape2(this[VALUE]);
  }
};

// node_modules/linkedom/esm/mixin/parent-node.js
var isNode = (node) => node instanceof Node2;
var insert = (parentNode, child, nodes) => {
  const { ownerDocument } = parentNode;
  for (const node of nodes)
    parentNode.insertBefore(
      isNode(node) ? node : new Text3(ownerDocument, node),
      child
    );
};
var ParentNode = class extends Node2 {
  constructor(ownerDocument, localName, nodeType) {
    super(ownerDocument, localName, nodeType);
    this[PRIVATE] = null;
    this[NEXT] = this[END] = {
      [NEXT]: null,
      [PREV]: this,
      [START]: this,
      nodeType: NODE_END,
      ownerDocument: this.ownerDocument,
      parentNode: null
    };
  }
  get childNodes() {
    const childNodes = new NodeList();
    let { firstChild } = this;
    while (firstChild) {
      childNodes.push(firstChild);
      firstChild = nextSibling(firstChild);
    }
    return childNodes;
  }
  get children() {
    const children = new NodeList();
    let { firstElementChild } = this;
    while (firstElementChild) {
      children.push(firstElementChild);
      firstElementChild = nextElementSibling2(firstElementChild);
    }
    return children;
  }
  /**
   * @returns {NodeStruct | null}
   */
  get firstChild() {
    let { [NEXT]: next, [END]: end } = this;
    while (next.nodeType === ATTRIBUTE_NODE)
      next = next[NEXT];
    return next === end ? null : next;
  }
  /**
   * @returns {NodeStruct | null}
   */
  get firstElementChild() {
    let { firstChild } = this;
    while (firstChild) {
      if (firstChild.nodeType === ELEMENT_NODE)
        return firstChild;
      firstChild = nextSibling(firstChild);
    }
    return null;
  }
  get lastChild() {
    const prev = this[END][PREV];
    switch (prev.nodeType) {
      case NODE_END:
        return prev[START];
      case ATTRIBUTE_NODE:
        return null;
    }
    return prev === this ? null : prev;
  }
  get lastElementChild() {
    let { lastChild } = this;
    while (lastChild) {
      if (lastChild.nodeType === ELEMENT_NODE)
        return lastChild;
      lastChild = previousSibling(lastChild);
    }
    return null;
  }
  get childElementCount() {
    return this.children.length;
  }
  prepend(...nodes) {
    insert(this, this.firstChild, nodes);
  }
  append(...nodes) {
    insert(this, this[END], nodes);
  }
  replaceChildren(...nodes) {
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end && next.nodeType === ATTRIBUTE_NODE)
      next = next[NEXT];
    while (next !== end) {
      const after2 = getEnd(next)[NEXT];
      next.remove();
      next = after2;
    }
    if (nodes.length)
      insert(this, end, nodes);
  }
  getElementsByClassName(className) {
    const elements = new NodeList();
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && next.hasAttribute("class") && next.classList.has(className))
        elements.push(next);
      next = next[NEXT];
    }
    return elements;
  }
  getElementsByTagName(tagName19) {
    const elements = new NodeList();
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && (next.localName === tagName19 || localCase(next) === tagName19))
        elements.push(next);
      next = next[NEXT];
    }
    return elements;
  }
  querySelector(selectors) {
    const matches2 = prepareMatch(this, selectors);
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && matches2(next))
        return next;
      next = next.nodeType === ELEMENT_NODE && next.localName === "template" ? next[END] : next[NEXT];
    }
    return null;
  }
  querySelectorAll(selectors) {
    const matches2 = prepareMatch(this, selectors);
    const elements = new NodeList();
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && matches2(next))
        elements.push(next);
      next = next.nodeType === ELEMENT_NODE && next.localName === "template" ? next[END] : next[NEXT];
    }
    return elements;
  }
  appendChild(node) {
    return this.insertBefore(node, this[END]);
  }
  contains(node) {
    let parentNode = node;
    while (parentNode && parentNode !== this)
      parentNode = parentNode.parentNode;
    return parentNode === this;
  }
  insertBefore(node, before2 = null) {
    if (node === before2)
      return node;
    if (node === this)
      throw new Error("unable to append a node to itself");
    const next = before2 || this[END];
    switch (node.nodeType) {
      case ELEMENT_NODE:
        node.remove();
        node.parentNode = this;
        knownBoundaries(next[PREV], node, next);
        moCallback(node, null);
        connectedCallback(node);
        break;
      case DOCUMENT_FRAGMENT_NODE: {
        let { [PRIVATE]: parentNode, firstChild, lastChild } = node;
        if (firstChild) {
          knownSegment(next[PREV], firstChild, lastChild, next);
          knownAdjacent(node, node[END]);
          if (parentNode)
            parentNode.replaceChildren();
          do {
            firstChild.parentNode = this;
            moCallback(firstChild, null);
            if (firstChild.nodeType === ELEMENT_NODE)
              connectedCallback(firstChild);
          } while (firstChild !== lastChild && (firstChild = nextSibling(firstChild)));
        }
        break;
      }
      case TEXT_NODE:
      case COMMENT_NODE:
      case CDATA_SECTION_NODE:
        node.remove();
      default:
        node.parentNode = this;
        knownSiblings(next[PREV], node, next);
        moCallback(node, null);
        break;
    }
    return node;
  }
  normalize() {
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      const { [NEXT]: $next, [PREV]: $prev, nodeType } = next;
      if (nodeType === TEXT_NODE) {
        if (!next[VALUE])
          next.remove();
        else if ($prev && $prev.nodeType === TEXT_NODE) {
          $prev.textContent += next.textContent;
          next.remove();
        }
      }
      next = $next;
    }
  }
  removeChild(node) {
    if (node.parentNode !== this)
      throw new Error("node is not a child");
    node.remove();
    return node;
  }
  replaceChild(node, replaced) {
    const next = getEnd(replaced)[NEXT];
    replaced.remove();
    this.insertBefore(node, next);
    return replaced;
  }
};

// node_modules/linkedom/esm/mixin/non-element-parent-node.js
var NonElementParentNode = class extends ParentNode {
  getElementById(id) {
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === ELEMENT_NODE && next.id === id)
        return next;
      next = next[NEXT];
    }
    return null;
  }
  cloneNode(deep) {
    const { ownerDocument, constructor } = this;
    const nonEPN = new constructor(ownerDocument);
    if (deep) {
      const { [END]: end } = nonEPN;
      for (const node of this.childNodes)
        nonEPN.insertBefore(node.cloneNode(deep), end);
    }
    return nonEPN;
  }
  toString() {
    const { childNodes, localName } = this;
    return `<${localName}>${childNodes.join("")}</${localName}>`;
  }
  toJSON() {
    const json = [];
    nonElementAsJSON(this, json);
    return json;
  }
};

// node_modules/linkedom/esm/interface/document-fragment.js
var DocumentFragment = class extends NonElementParentNode {
  constructor(ownerDocument) {
    super(ownerDocument, "#document-fragment", DOCUMENT_FRAGMENT_NODE);
  }
};

// node_modules/linkedom/esm/interface/document-type.js
var DocumentType = class _DocumentType extends Node2 {
  constructor(ownerDocument, name, publicId = "", systemId = "") {
    super(ownerDocument, "#document-type", DOCUMENT_TYPE_NODE);
    this.name = name;
    this.publicId = publicId;
    this.systemId = systemId;
  }
  cloneNode() {
    const { ownerDocument, name, publicId, systemId } = this;
    return new _DocumentType(ownerDocument, name, publicId, systemId);
  }
  toString() {
    const { name, publicId, systemId } = this;
    const hasPublic = 0 < publicId.length;
    const str = [name];
    if (hasPublic)
      str.push("PUBLIC", `"${publicId}"`);
    if (systemId.length) {
      if (!hasPublic)
        str.push("SYSTEM");
      str.push(`"${systemId}"`);
    }
    return `<!DOCTYPE ${str.join(" ")}>`;
  }
  toJSON() {
    const json = [];
    documentTypeAsJSON(this, json);
    return json;
  }
};

// node_modules/linkedom/esm/mixin/inner-html.js
var getInnerHtml = (node) => node.childNodes.join("");
var setInnerHtml = (node, html) => {
  const { ownerDocument } = node;
  const { constructor } = ownerDocument;
  const document = new constructor();
  document[CUSTOM_ELEMENTS] = ownerDocument[CUSTOM_ELEMENTS];
  const { childNodes } = parseFromString(document, ignoreCase(node), html);
  node.replaceChildren(...childNodes.map(setOwnerDocument, ownerDocument));
};
function setOwnerDocument(node) {
  node.ownerDocument = this;
  switch (node.nodeType) {
    case ELEMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      node.childNodes.forEach(setOwnerDocument, this);
      break;
  }
  return node;
}

// node_modules/uhyphen/esm/index.js
var esm_default2 = (camel) => camel.replace(/(([A-Z0-9])([A-Z0-9][a-z]))|(([a-z0-9]+)([A-Z]))/g, "$2$5-$3$6").toLowerCase();

// node_modules/linkedom/esm/dom/string-map.js
var refs = /* @__PURE__ */ new WeakMap();
var key = (name) => `data-${esm_default2(name)}`;
var prop = (name) => name.slice(5).replace(/-([a-z])/g, (_, $1) => $1.toUpperCase());
var handler = {
  get(dataset, name) {
    if (name in dataset)
      return refs.get(dataset).getAttribute(key(name));
  },
  set(dataset, name, value) {
    dataset[name] = value;
    refs.get(dataset).setAttribute(key(name), value);
    return true;
  },
  deleteProperty(dataset, name) {
    if (name in dataset)
      refs.get(dataset).removeAttribute(key(name));
    return delete dataset[name];
  }
};
var DOMStringMap = class {
  /**
   * @param {Element} ref
   */
  constructor(ref) {
    for (const { name, value } of ref.attributes) {
      if (/^data-/.test(name))
        this[prop(name)] = value;
    }
    refs.set(this, ref);
    return new Proxy(this, handler);
  }
};
setPrototypeOf(DOMStringMap.prototype, null);

// node_modules/linkedom/esm/dom/token-list.js
var { add } = Set.prototype;
var addTokens = (self, tokens) => {
  for (const token of tokens) {
    if (token)
      add.call(self, token);
  }
};
var update = ({ [OWNER_ELEMENT]: ownerElement, value }) => {
  const attribute2 = ownerElement.getAttributeNode("class");
  if (attribute2)
    attribute2.value = value;
  else
    setAttribute(
      ownerElement,
      new Attr(ownerElement.ownerDocument, "class", value)
    );
};
var DOMTokenList = class extends Set {
  constructor(ownerElement) {
    super();
    this[OWNER_ELEMENT] = ownerElement;
    const attribute2 = ownerElement.getAttributeNode("class");
    if (attribute2)
      addTokens(this, attribute2.value.split(/\s+/));
  }
  get length() {
    return this.size;
  }
  get value() {
    return [...this].join(" ");
  }
  /**
   * @param  {...string} tokens
   */
  add(...tokens) {
    addTokens(this, tokens);
    update(this);
  }
  /**
   * @param {string} token
   */
  contains(token) {
    return this.has(token);
  }
  /**
   * @param  {...string} tokens
   */
  remove(...tokens) {
    for (const token of tokens)
      this.delete(token);
    update(this);
  }
  /**
   * @param {string} token
   * @param {boolean?} force
   */
  toggle(token, force) {
    if (this.has(token)) {
      if (force)
        return true;
      this.delete(token);
      update(this);
    } else if (force || arguments.length === 1) {
      super.add(token);
      update(this);
      return true;
    }
    return false;
  }
  /**
   * @param {string} token
   * @param {string} newToken
   */
  replace(token, newToken) {
    if (this.has(token)) {
      this.delete(token);
      super.add(newToken);
      update(this);
      return true;
    }
    return false;
  }
  /**
   * @param {string} token
   */
  supports() {
    return true;
  }
};

// node_modules/linkedom/esm/interface/css-style-declaration.js
var refs2 = /* @__PURE__ */ new WeakMap();
var getKeys = (style) => [...style.keys()].filter((key2) => key2 !== PRIVATE);
var updateKeys = (style) => {
  const attr = refs2.get(style).getAttributeNode("style");
  if (!attr || attr[CHANGED] || style.get(PRIVATE) !== attr) {
    style.clear();
    if (attr) {
      style.set(PRIVATE, attr);
      for (const rule of attr[VALUE].split(/\s*;\s*/)) {
        let [key2, ...rest] = rule.split(":");
        if (rest.length > 0) {
          key2 = key2.trim();
          const value = rest.join(":").trim();
          if (key2 && value)
            style.set(key2, value);
        }
      }
    }
  }
  return attr;
};
var handler2 = {
  get(style, name) {
    if (name in prototype)
      return style[name];
    updateKeys(style);
    if (name === "length")
      return getKeys(style).length;
    if (/^\d+$/.test(name))
      return getKeys(style)[name];
    return style.get(esm_default2(name));
  },
  set(style, name, value) {
    if (name === "cssText")
      style[name] = value;
    else {
      let attr = updateKeys(style);
      if (value == null)
        style.delete(esm_default2(name));
      else
        style.set(esm_default2(name), value);
      if (!attr) {
        const element = refs2.get(style);
        attr = element.ownerDocument.createAttribute("style");
        element.setAttributeNode(attr);
        style.set(PRIVATE, attr);
      }
      attr[CHANGED] = false;
      attr[VALUE] = style.toString();
    }
    return true;
  }
};
var CSSStyleDeclaration = class extends Map {
  constructor(element) {
    super();
    refs2.set(this, element);
    return new Proxy(this, handler2);
  }
  get cssText() {
    return this.toString();
  }
  set cssText(value) {
    refs2.get(this).setAttribute("style", value);
  }
  getPropertyValue(name) {
    const self = this[PRIVATE];
    return handler2.get(self, name);
  }
  setProperty(name, value) {
    const self = this[PRIVATE];
    handler2.set(self, name, value);
  }
  removeProperty(name) {
    const self = this[PRIVATE];
    handler2.set(self, name, null);
  }
  [Symbol.iterator]() {
    const self = this[PRIVATE];
    updateKeys(self);
    const keys2 = getKeys(self);
    const { length } = keys2;
    let i = 0;
    return {
      next() {
        const done = i === length;
        return { done, value: done ? null : keys2[i++] };
      }
    };
  }
  get [PRIVATE]() {
    return this;
  }
  toString() {
    const self = this[PRIVATE];
    updateKeys(self);
    const cssText = [];
    self.forEach(push, cssText);
    return cssText.join(";");
  }
};
var { prototype } = CSSStyleDeclaration;
function push(value, key2) {
  if (key2 !== PRIVATE)
    this.push(`${key2}:${value}`);
}

// node_modules/linkedom/esm/interface/event.js
var BUBBLING_PHASE = 3;
var AT_TARGET = 2;
var CAPTURING_PHASE = 1;
var NONE = 0;
function getCurrentTarget(ev) {
  return ev.currentTarget;
}
var GlobalEvent = class {
  static get BUBBLING_PHASE() {
    return BUBBLING_PHASE;
  }
  static get AT_TARGET() {
    return AT_TARGET;
  }
  static get CAPTURING_PHASE() {
    return CAPTURING_PHASE;
  }
  static get NONE() {
    return NONE;
  }
  constructor(type, eventInitDict = {}) {
    this.type = type;
    this.bubbles = !!eventInitDict.bubbles;
    this.cancelBubble = false;
    this._stopImmediatePropagationFlag = false;
    this.cancelable = !!eventInitDict.cancelable;
    this.eventPhase = this.NONE;
    this.timeStamp = Date.now();
    this.defaultPrevented = false;
    this.originalTarget = null;
    this.returnValue = null;
    this.srcElement = null;
    this.target = null;
    this._path = [];
  }
  get BUBBLING_PHASE() {
    return BUBBLING_PHASE;
  }
  get AT_TARGET() {
    return AT_TARGET;
  }
  get CAPTURING_PHASE() {
    return CAPTURING_PHASE;
  }
  get NONE() {
    return NONE;
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  // simplified implementation, should be https://dom.spec.whatwg.org/#dom-event-composedpath
  composedPath() {
    return this._path.map(getCurrentTarget);
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
  stopImmediatePropagation() {
    this.stopPropagation();
    this._stopImmediatePropagationFlag = true;
  }
};

// node_modules/linkedom/esm/interface/named-node-map.js
var NamedNodeMap = class extends Array {
  constructor(ownerElement) {
    super();
    this.ownerElement = ownerElement;
  }
  getNamedItem(name) {
    return this.ownerElement.getAttributeNode(name);
  }
  setNamedItem(attr) {
    this.ownerElement.setAttributeNode(attr);
    this.unshift(attr);
  }
  removeNamedItem(name) {
    const item = this.getNamedItem(name);
    this.ownerElement.removeAttribute(name);
    this.splice(this.indexOf(item), 1);
  }
  item(index) {
    return index < this.length ? this[index] : null;
  }
  /* c8 ignore start */
  getNamedItemNS(_, name) {
    return this.getNamedItem(name);
  }
  setNamedItemNS(_, attr) {
    return this.setNamedItem(attr);
  }
  removeNamedItemNS(_, name) {
    return this.removeNamedItem(name);
  }
  /* c8 ignore stop */
};

// node_modules/linkedom/esm/interface/shadow-root.js
var ShadowRoot = class extends NonElementParentNode {
  constructor(host) {
    super(host.ownerDocument, "#shadow-root", DOCUMENT_FRAGMENT_NODE);
    this.host = host;
  }
  get innerHTML() {
    return getInnerHtml(this);
  }
  set innerHTML(html) {
    setInnerHtml(this, html);
  }
};

// node_modules/linkedom/esm/interface/element.js
var attributesHandler = {
  get(target, key2) {
    return key2 in target ? target[key2] : target.find(({ name }) => name === key2);
  }
};
var create2 = (ownerDocument, element, localName) => {
  if ("ownerSVGElement" in element) {
    const svg = ownerDocument.createElementNS(SVG_NAMESPACE, localName);
    svg.ownerSVGElement = element.ownerSVGElement;
    return svg;
  }
  return ownerDocument.createElement(localName);
};
var isVoid = ({ localName, ownerDocument }) => {
  return ownerDocument[MIME].voidElements.test(localName);
};
var Element2 = class extends ParentNode {
  constructor(ownerDocument, localName) {
    super(ownerDocument, localName, ELEMENT_NODE);
    this[CLASS_LIST] = null;
    this[DATASET] = null;
    this[STYLE] = null;
  }
  // <Mixins>
  get isConnected() {
    return isConnected(this);
  }
  get parentElement() {
    return parentElement(this);
  }
  get previousSibling() {
    return previousSibling(this);
  }
  get nextSibling() {
    return nextSibling(this);
  }
  get namespaceURI() {
    return "http://www.w3.org/1999/xhtml";
  }
  get previousElementSibling() {
    return previousElementSibling(this);
  }
  get nextElementSibling() {
    return nextElementSibling2(this);
  }
  before(...nodes) {
    before(this, nodes);
  }
  after(...nodes) {
    after(this, nodes);
  }
  replaceWith(...nodes) {
    replaceWith(this, nodes);
  }
  remove() {
    remove(this[PREV], this, this[END][NEXT]);
  }
  // </Mixins>
  // <specialGetters>
  get id() {
    return stringAttribute.get(this, "id");
  }
  set id(value) {
    stringAttribute.set(this, "id", value);
  }
  get className() {
    return this.classList.value;
  }
  set className(value) {
    const { classList } = this;
    classList.clear();
    classList.add(...$String(value).split(/\s+/));
  }
  get nodeName() {
    return localCase(this);
  }
  get tagName() {
    return localCase(this);
  }
  get classList() {
    return this[CLASS_LIST] || (this[CLASS_LIST] = new DOMTokenList(this));
  }
  get dataset() {
    return this[DATASET] || (this[DATASET] = new DOMStringMap(this));
  }
  getBoundingClientRect() {
    return {
      x: 0,
      y: 0,
      bottom: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0,
      width: 0
    };
  }
  get nonce() {
    return stringAttribute.get(this, "nonce");
  }
  set nonce(value) {
    stringAttribute.set(this, "nonce", value);
  }
  get style() {
    return this[STYLE] || (this[STYLE] = new CSSStyleDeclaration(this));
  }
  get tabIndex() {
    return numericAttribute.get(this, "tabindex") || -1;
  }
  set tabIndex(value) {
    numericAttribute.set(this, "tabindex", value);
  }
  get slot() {
    return stringAttribute.get(this, "slot");
  }
  set slot(value) {
    stringAttribute.set(this, "slot", value);
  }
  // </specialGetters>
  // <contentRelated>
  get innerText() {
    const text = [];
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === TEXT_NODE) {
        text.push(next.textContent.replace(/\s+/g, " "));
      } else if (text.length && next[NEXT] != end && BLOCK_ELEMENTS.has(next.tagName)) {
        text.push("\n");
      }
      next = next[NEXT];
    }
    return text.join("");
  }
  /**
   * @returns {String}
   */
  get textContent() {
    const text = [];
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      if (next.nodeType === TEXT_NODE)
        text.push(next.textContent);
      next = next[NEXT];
    }
    return text.join("");
  }
  set textContent(text) {
    this.replaceChildren();
    if (text != null && text !== "")
      this.appendChild(new Text3(this.ownerDocument, text));
  }
  get innerHTML() {
    return getInnerHtml(this);
  }
  set innerHTML(html) {
    setInnerHtml(this, html);
  }
  get outerHTML() {
    return this.toString();
  }
  set outerHTML(html) {
    const template = this.ownerDocument.createElement("");
    template.innerHTML = html;
    this.replaceWith(...template.childNodes);
  }
  // </contentRelated>
  // <attributes>
  get attributes() {
    const attributes2 = new NamedNodeMap(this);
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      attributes2.push(next);
      next = next[NEXT];
    }
    return new Proxy(attributes2, attributesHandler);
  }
  focus() {
    this.dispatchEvent(new GlobalEvent("focus"));
  }
  getAttribute(name) {
    if (name === "class")
      return this.className;
    const attribute2 = this.getAttributeNode(name);
    return attribute2 && (ignoreCase(this) ? attribute2.value : escape2(attribute2.value));
  }
  getAttributeNode(name) {
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      if (next.name === name)
        return next;
      next = next[NEXT];
    }
    return null;
  }
  getAttributeNames() {
    const attributes2 = new NodeList();
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      attributes2.push(next.name);
      next = next[NEXT];
    }
    return attributes2;
  }
  hasAttribute(name) {
    return !!this.getAttributeNode(name);
  }
  hasAttributes() {
    return this[NEXT].nodeType === ATTRIBUTE_NODE;
  }
  removeAttribute(name) {
    if (name === "class" && this[CLASS_LIST])
      this[CLASS_LIST].clear();
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      if (next.name === name) {
        removeAttribute(this, next);
        return;
      }
      next = next[NEXT];
    }
  }
  removeAttributeNode(attribute2) {
    let next = this[NEXT];
    while (next.nodeType === ATTRIBUTE_NODE) {
      if (next === attribute2) {
        removeAttribute(this, next);
        return;
      }
      next = next[NEXT];
    }
  }
  setAttribute(name, value) {
    if (name === "class")
      this.className = value;
    else {
      const attribute2 = this.getAttributeNode(name);
      if (attribute2)
        attribute2.value = value;
      else
        setAttribute(this, new Attr(this.ownerDocument, name, value));
    }
  }
  setAttributeNode(attribute2) {
    const { name } = attribute2;
    const previously = this.getAttributeNode(name);
    if (previously !== attribute2) {
      if (previously)
        this.removeAttributeNode(previously);
      const { ownerElement } = attribute2;
      if (ownerElement)
        ownerElement.removeAttributeNode(attribute2);
      setAttribute(this, attribute2);
    }
    return previously;
  }
  toggleAttribute(name, force) {
    if (this.hasAttribute(name)) {
      if (!force) {
        this.removeAttribute(name);
        return false;
      }
      return true;
    } else if (force || arguments.length === 1) {
      this.setAttribute(name, "");
      return true;
    }
    return false;
  }
  // </attributes>
  // <ShadowDOM>
  get shadowRoot() {
    if (shadowRoots.has(this)) {
      const { mode, shadowRoot } = shadowRoots.get(this);
      if (mode === "open")
        return shadowRoot;
    }
    return null;
  }
  attachShadow(init) {
    if (shadowRoots.has(this))
      throw new Error("operation not supported");
    const shadowRoot = new ShadowRoot(this);
    shadowRoots.set(this, {
      mode: init.mode,
      shadowRoot
    });
    return shadowRoot;
  }
  // </ShadowDOM>
  // <selectors>
  matches(selectors) {
    return matches(this, selectors);
  }
  closest(selectors) {
    let parentElement2 = this;
    const matches2 = prepareMatch(parentElement2, selectors);
    while (parentElement2 && !matches2(parentElement2))
      parentElement2 = parentElement2.parentElement;
    return parentElement2;
  }
  // </selectors>
  // <insertAdjacent>
  insertAdjacentElement(position, element) {
    const { parentElement: parentElement2 } = this;
    switch (position) {
      case "beforebegin":
        if (parentElement2) {
          parentElement2.insertBefore(element, this);
          break;
        }
        return null;
      case "afterbegin":
        this.insertBefore(element, this.firstChild);
        break;
      case "beforeend":
        this.insertBefore(element, null);
        break;
      case "afterend":
        if (parentElement2) {
          parentElement2.insertBefore(element, this.nextSibling);
          break;
        }
        return null;
    }
    return element;
  }
  insertAdjacentHTML(position, html) {
    const template = this.ownerDocument.createElement("template");
    template.innerHTML = html;
    this.insertAdjacentElement(position, template.content);
  }
  insertAdjacentText(position, text) {
    const node = this.ownerDocument.createTextNode(text);
    this.insertAdjacentElement(position, node);
  }
  // </insertAdjacent>
  cloneNode(deep = false) {
    const { ownerDocument, localName } = this;
    const addNext = (next2) => {
      next2.parentNode = parentNode;
      knownAdjacent($next, next2);
      $next = next2;
    };
    const clone = create2(ownerDocument, this, localName);
    let parentNode = clone, $next = clone;
    let { [NEXT]: next, [END]: prev } = this;
    while (next !== prev && (deep || next.nodeType === ATTRIBUTE_NODE)) {
      switch (next.nodeType) {
        case NODE_END:
          knownAdjacent($next, parentNode[END]);
          $next = parentNode[END];
          parentNode = parentNode.parentNode;
          break;
        case ELEMENT_NODE: {
          const node = create2(ownerDocument, next, next.localName);
          addNext(node);
          parentNode = node;
          break;
        }
        case ATTRIBUTE_NODE: {
          const attr = next.cloneNode(deep);
          attr.ownerElement = parentNode;
          addNext(attr);
          break;
        }
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
          addNext(next.cloneNode(deep));
          break;
      }
      next = next[NEXT];
    }
    knownAdjacent($next, clone[END]);
    return clone;
  }
  // <custom>
  toString() {
    const out = [];
    const { [END]: end } = this;
    let next = { [NEXT]: this };
    let isOpened = false;
    do {
      next = next[NEXT];
      switch (next.nodeType) {
        case ATTRIBUTE_NODE: {
          const attr = " " + next;
          switch (attr) {
            case " id":
            case " class":
            case " style":
              break;
            default:
              out.push(attr);
          }
          break;
        }
        case NODE_END: {
          const start = next[START];
          if (isOpened) {
            if ("ownerSVGElement" in start)
              out.push(" />");
            else if (isVoid(start))
              out.push(ignoreCase(start) ? ">" : " />");
            else
              out.push(`></${start.localName}>`);
            isOpened = false;
          } else
            out.push(`</${start.localName}>`);
          break;
        }
        case ELEMENT_NODE:
          if (isOpened)
            out.push(">");
          if (next.toString !== this.toString) {
            out.push(next.toString());
            next = next[END];
            isOpened = false;
          } else {
            out.push(`<${next.localName}`);
            isOpened = true;
          }
          break;
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
          out.push((isOpened ? ">" : "") + next);
          isOpened = false;
          break;
      }
    } while (next !== end);
    return out.join("");
  }
  toJSON() {
    const json = [];
    elementAsJSON(this, json);
    return json;
  }
  // </custom>
  /* c8 ignore start */
  getAttributeNS(_, name) {
    return this.getAttribute(name);
  }
  getElementsByTagNameNS(_, name) {
    return this.getElementsByTagName(name);
  }
  hasAttributeNS(_, name) {
    return this.hasAttribute(name);
  }
  removeAttributeNS(_, name) {
    this.removeAttribute(name);
  }
  setAttributeNS(_, name, value) {
    this.setAttribute(name, value);
  }
  setAttributeNodeNS(attr) {
    return this.setAttributeNode(attr);
  }
  /* c8 ignore stop */
};

// node_modules/linkedom/esm/svg/element.js
var classNames = /* @__PURE__ */ new WeakMap();
var handler3 = {
  get(target, name) {
    return target[name];
  },
  set(target, name, value) {
    target[name] = value;
    return true;
  }
};
var SVGElement = class extends Element2 {
  constructor(ownerDocument, localName, ownerSVGElement = null) {
    super(ownerDocument, localName);
    this.ownerSVGElement = ownerSVGElement;
  }
  get className() {
    if (!classNames.has(this))
      classNames.set(this, new Proxy({ baseVal: "", animVal: "" }, handler3));
    return classNames.get(this);
  }
  /* c8 ignore start */
  set className(value) {
    const { classList } = this;
    classList.clear();
    classList.add(...$String(value).split(/\s+/));
  }
  /* c8 ignore stop */
  get namespaceURI() {
    return "http://www.w3.org/2000/svg";
  }
  getAttribute(name) {
    return name === "class" ? [...this.classList].join(" ") : super.getAttribute(name);
  }
  setAttribute(name, value) {
    if (name === "class")
      this.className = value;
    else if (name === "style") {
      const { className } = this;
      className.baseVal = className.animVal = value;
    }
    super.setAttribute(name, value);
  }
};

// node_modules/linkedom/esm/shared/facades.js
var illegalConstructor = () => {
  throw new TypeError("Illegal constructor");
};
function Attr2() {
  illegalConstructor();
}
setPrototypeOf(Attr2, Attr);
Attr2.prototype = Attr.prototype;
function CDATASection2() {
  illegalConstructor();
}
setPrototypeOf(CDATASection2, CDATASection);
CDATASection2.prototype = CDATASection.prototype;
function CharacterData2() {
  illegalConstructor();
}
setPrototypeOf(CharacterData2, CharacterData);
CharacterData2.prototype = CharacterData.prototype;
function Comment4() {
  illegalConstructor();
}
setPrototypeOf(Comment4, Comment3);
Comment4.prototype = Comment3.prototype;
function DocumentFragment2() {
  illegalConstructor();
}
setPrototypeOf(DocumentFragment2, DocumentFragment);
DocumentFragment2.prototype = DocumentFragment.prototype;
function DocumentType2() {
  illegalConstructor();
}
setPrototypeOf(DocumentType2, DocumentType);
DocumentType2.prototype = DocumentType.prototype;
function Element3() {
  illegalConstructor();
}
setPrototypeOf(Element3, Element2);
Element3.prototype = Element2.prototype;
function Node3() {
  illegalConstructor();
}
setPrototypeOf(Node3, Node2);
Node3.prototype = Node2.prototype;
function ShadowRoot2() {
  illegalConstructor();
}
setPrototypeOf(ShadowRoot2, ShadowRoot);
ShadowRoot2.prototype = ShadowRoot.prototype;
function Text4() {
  illegalConstructor();
}
setPrototypeOf(Text4, Text3);
Text4.prototype = Text3.prototype;
function SVGElement2() {
  illegalConstructor();
}
setPrototypeOf(SVGElement2, SVGElement);
SVGElement2.prototype = SVGElement.prototype;
var Facades = {
  Attr: Attr2,
  CDATASection: CDATASection2,
  CharacterData: CharacterData2,
  Comment: Comment4,
  DocumentFragment: DocumentFragment2,
  DocumentType: DocumentType2,
  Element: Element3,
  Node: Node3,
  ShadowRoot: ShadowRoot2,
  Text: Text4,
  SVGElement: SVGElement2
};

// node_modules/linkedom/esm/html/element.js
var Level0 = /* @__PURE__ */ new WeakMap();
var level0 = {
  get(element, name) {
    return Level0.has(element) && Level0.get(element)[name] || null;
  },
  set(element, name, value) {
    if (!Level0.has(element))
      Level0.set(element, {});
    const handlers = Level0.get(element);
    const type = name.slice(2);
    if (handlers[name])
      element.removeEventListener(type, handlers[name], false);
    if (handlers[name] = value)
      element.addEventListener(type, value, false);
  }
};
var HTMLElement = class extends Element2 {
  static get observedAttributes() {
    return [];
  }
  constructor(ownerDocument = null, localName = "") {
    super(ownerDocument, localName);
    const ownerLess = !ownerDocument;
    let options;
    if (ownerLess) {
      const { constructor: Class } = this;
      if (!Classes.has(Class))
        throw new Error("unable to initialize this Custom Element");
      ({ ownerDocument, localName, options } = Classes.get(Class));
    }
    if (ownerDocument[UPGRADE]) {
      const { element, values } = ownerDocument[UPGRADE];
      ownerDocument[UPGRADE] = null;
      for (const [key2, value] of values)
        element[key2] = value;
      return element;
    }
    if (ownerLess) {
      this.ownerDocument = this[END].ownerDocument = ownerDocument;
      this.localName = localName;
      customElements.set(this, { connected: false });
      if (options.is)
        this.setAttribute("is", options.is);
    }
  }
  /* c8 ignore start */
  /* TODO: what about these?
  offsetHeight
  offsetLeft
  offsetParent
  offsetTop
  offsetWidth
  */
  blur() {
    this.dispatchEvent(new GlobalEvent("blur"));
  }
  click() {
    const clickEvent = new GlobalEvent("click", { bubbles: true, cancelable: true });
    clickEvent.button = 0;
    this.dispatchEvent(clickEvent);
  }
  // Boolean getters
  get accessKeyLabel() {
    const { accessKey } = this;
    return accessKey && `Alt+Shift+${accessKey}`;
  }
  get isContentEditable() {
    return this.hasAttribute("contenteditable");
  }
  // Boolean Accessors
  get contentEditable() {
    return booleanAttribute.get(this, "contenteditable");
  }
  set contentEditable(value) {
    booleanAttribute.set(this, "contenteditable", value);
  }
  get draggable() {
    return booleanAttribute.get(this, "draggable");
  }
  set draggable(value) {
    booleanAttribute.set(this, "draggable", value);
  }
  get hidden() {
    return booleanAttribute.get(this, "hidden");
  }
  set hidden(value) {
    booleanAttribute.set(this, "hidden", value);
  }
  get spellcheck() {
    return booleanAttribute.get(this, "spellcheck");
  }
  set spellcheck(value) {
    booleanAttribute.set(this, "spellcheck", value);
  }
  // String Accessors
  get accessKey() {
    return stringAttribute.get(this, "accesskey");
  }
  set accessKey(value) {
    stringAttribute.set(this, "accesskey", value);
  }
  get dir() {
    return stringAttribute.get(this, "dir");
  }
  set dir(value) {
    stringAttribute.set(this, "dir", value);
  }
  get lang() {
    return stringAttribute.get(this, "lang");
  }
  set lang(value) {
    stringAttribute.set(this, "lang", value);
  }
  get title() {
    return stringAttribute.get(this, "title");
  }
  set title(value) {
    stringAttribute.set(this, "title", value);
  }
  // DOM Level 0
  get onabort() {
    return level0.get(this, "onabort");
  }
  set onabort(value) {
    level0.set(this, "onabort", value);
  }
  get onblur() {
    return level0.get(this, "onblur");
  }
  set onblur(value) {
    level0.set(this, "onblur", value);
  }
  get oncancel() {
    return level0.get(this, "oncancel");
  }
  set oncancel(value) {
    level0.set(this, "oncancel", value);
  }
  get oncanplay() {
    return level0.get(this, "oncanplay");
  }
  set oncanplay(value) {
    level0.set(this, "oncanplay", value);
  }
  get oncanplaythrough() {
    return level0.get(this, "oncanplaythrough");
  }
  set oncanplaythrough(value) {
    level0.set(this, "oncanplaythrough", value);
  }
  get onchange() {
    return level0.get(this, "onchange");
  }
  set onchange(value) {
    level0.set(this, "onchange", value);
  }
  get onclick() {
    return level0.get(this, "onclick");
  }
  set onclick(value) {
    level0.set(this, "onclick", value);
  }
  get onclose() {
    return level0.get(this, "onclose");
  }
  set onclose(value) {
    level0.set(this, "onclose", value);
  }
  get oncontextmenu() {
    return level0.get(this, "oncontextmenu");
  }
  set oncontextmenu(value) {
    level0.set(this, "oncontextmenu", value);
  }
  get oncuechange() {
    return level0.get(this, "oncuechange");
  }
  set oncuechange(value) {
    level0.set(this, "oncuechange", value);
  }
  get ondblclick() {
    return level0.get(this, "ondblclick");
  }
  set ondblclick(value) {
    level0.set(this, "ondblclick", value);
  }
  get ondrag() {
    return level0.get(this, "ondrag");
  }
  set ondrag(value) {
    level0.set(this, "ondrag", value);
  }
  get ondragend() {
    return level0.get(this, "ondragend");
  }
  set ondragend(value) {
    level0.set(this, "ondragend", value);
  }
  get ondragenter() {
    return level0.get(this, "ondragenter");
  }
  set ondragenter(value) {
    level0.set(this, "ondragenter", value);
  }
  get ondragleave() {
    return level0.get(this, "ondragleave");
  }
  set ondragleave(value) {
    level0.set(this, "ondragleave", value);
  }
  get ondragover() {
    return level0.get(this, "ondragover");
  }
  set ondragover(value) {
    level0.set(this, "ondragover", value);
  }
  get ondragstart() {
    return level0.get(this, "ondragstart");
  }
  set ondragstart(value) {
    level0.set(this, "ondragstart", value);
  }
  get ondrop() {
    return level0.get(this, "ondrop");
  }
  set ondrop(value) {
    level0.set(this, "ondrop", value);
  }
  get ondurationchange() {
    return level0.get(this, "ondurationchange");
  }
  set ondurationchange(value) {
    level0.set(this, "ondurationchange", value);
  }
  get onemptied() {
    return level0.get(this, "onemptied");
  }
  set onemptied(value) {
    level0.set(this, "onemptied", value);
  }
  get onended() {
    return level0.get(this, "onended");
  }
  set onended(value) {
    level0.set(this, "onended", value);
  }
  get onerror() {
    return level0.get(this, "onerror");
  }
  set onerror(value) {
    level0.set(this, "onerror", value);
  }
  get onfocus() {
    return level0.get(this, "onfocus");
  }
  set onfocus(value) {
    level0.set(this, "onfocus", value);
  }
  get oninput() {
    return level0.get(this, "oninput");
  }
  set oninput(value) {
    level0.set(this, "oninput", value);
  }
  get oninvalid() {
    return level0.get(this, "oninvalid");
  }
  set oninvalid(value) {
    level0.set(this, "oninvalid", value);
  }
  get onkeydown() {
    return level0.get(this, "onkeydown");
  }
  set onkeydown(value) {
    level0.set(this, "onkeydown", value);
  }
  get onkeypress() {
    return level0.get(this, "onkeypress");
  }
  set onkeypress(value) {
    level0.set(this, "onkeypress", value);
  }
  get onkeyup() {
    return level0.get(this, "onkeyup");
  }
  set onkeyup(value) {
    level0.set(this, "onkeyup", value);
  }
  get onload() {
    return level0.get(this, "onload");
  }
  set onload(value) {
    level0.set(this, "onload", value);
  }
  get onloadeddata() {
    return level0.get(this, "onloadeddata");
  }
  set onloadeddata(value) {
    level0.set(this, "onloadeddata", value);
  }
  get onloadedmetadata() {
    return level0.get(this, "onloadedmetadata");
  }
  set onloadedmetadata(value) {
    level0.set(this, "onloadedmetadata", value);
  }
  get onloadstart() {
    return level0.get(this, "onloadstart");
  }
  set onloadstart(value) {
    level0.set(this, "onloadstart", value);
  }
  get onmousedown() {
    return level0.get(this, "onmousedown");
  }
  set onmousedown(value) {
    level0.set(this, "onmousedown", value);
  }
  get onmouseenter() {
    return level0.get(this, "onmouseenter");
  }
  set onmouseenter(value) {
    level0.set(this, "onmouseenter", value);
  }
  get onmouseleave() {
    return level0.get(this, "onmouseleave");
  }
  set onmouseleave(value) {
    level0.set(this, "onmouseleave", value);
  }
  get onmousemove() {
    return level0.get(this, "onmousemove");
  }
  set onmousemove(value) {
    level0.set(this, "onmousemove", value);
  }
  get onmouseout() {
    return level0.get(this, "onmouseout");
  }
  set onmouseout(value) {
    level0.set(this, "onmouseout", value);
  }
  get onmouseover() {
    return level0.get(this, "onmouseover");
  }
  set onmouseover(value) {
    level0.set(this, "onmouseover", value);
  }
  get onmouseup() {
    return level0.get(this, "onmouseup");
  }
  set onmouseup(value) {
    level0.set(this, "onmouseup", value);
  }
  get onmousewheel() {
    return level0.get(this, "onmousewheel");
  }
  set onmousewheel(value) {
    level0.set(this, "onmousewheel", value);
  }
  get onpause() {
    return level0.get(this, "onpause");
  }
  set onpause(value) {
    level0.set(this, "onpause", value);
  }
  get onplay() {
    return level0.get(this, "onplay");
  }
  set onplay(value) {
    level0.set(this, "onplay", value);
  }
  get onplaying() {
    return level0.get(this, "onplaying");
  }
  set onplaying(value) {
    level0.set(this, "onplaying", value);
  }
  get onprogress() {
    return level0.get(this, "onprogress");
  }
  set onprogress(value) {
    level0.set(this, "onprogress", value);
  }
  get onratechange() {
    return level0.get(this, "onratechange");
  }
  set onratechange(value) {
    level0.set(this, "onratechange", value);
  }
  get onreset() {
    return level0.get(this, "onreset");
  }
  set onreset(value) {
    level0.set(this, "onreset", value);
  }
  get onresize() {
    return level0.get(this, "onresize");
  }
  set onresize(value) {
    level0.set(this, "onresize", value);
  }
  get onscroll() {
    return level0.get(this, "onscroll");
  }
  set onscroll(value) {
    level0.set(this, "onscroll", value);
  }
  get onseeked() {
    return level0.get(this, "onseeked");
  }
  set onseeked(value) {
    level0.set(this, "onseeked", value);
  }
  get onseeking() {
    return level0.get(this, "onseeking");
  }
  set onseeking(value) {
    level0.set(this, "onseeking", value);
  }
  get onselect() {
    return level0.get(this, "onselect");
  }
  set onselect(value) {
    level0.set(this, "onselect", value);
  }
  get onshow() {
    return level0.get(this, "onshow");
  }
  set onshow(value) {
    level0.set(this, "onshow", value);
  }
  get onstalled() {
    return level0.get(this, "onstalled");
  }
  set onstalled(value) {
    level0.set(this, "onstalled", value);
  }
  get onsubmit() {
    return level0.get(this, "onsubmit");
  }
  set onsubmit(value) {
    level0.set(this, "onsubmit", value);
  }
  get onsuspend() {
    return level0.get(this, "onsuspend");
  }
  set onsuspend(value) {
    level0.set(this, "onsuspend", value);
  }
  get ontimeupdate() {
    return level0.get(this, "ontimeupdate");
  }
  set ontimeupdate(value) {
    level0.set(this, "ontimeupdate", value);
  }
  get ontoggle() {
    return level0.get(this, "ontoggle");
  }
  set ontoggle(value) {
    level0.set(this, "ontoggle", value);
  }
  get onvolumechange() {
    return level0.get(this, "onvolumechange");
  }
  set onvolumechange(value) {
    level0.set(this, "onvolumechange", value);
  }
  get onwaiting() {
    return level0.get(this, "onwaiting");
  }
  set onwaiting(value) {
    level0.set(this, "onwaiting", value);
  }
  get onauxclick() {
    return level0.get(this, "onauxclick");
  }
  set onauxclick(value) {
    level0.set(this, "onauxclick", value);
  }
  get ongotpointercapture() {
    return level0.get(this, "ongotpointercapture");
  }
  set ongotpointercapture(value) {
    level0.set(this, "ongotpointercapture", value);
  }
  get onlostpointercapture() {
    return level0.get(this, "onlostpointercapture");
  }
  set onlostpointercapture(value) {
    level0.set(this, "onlostpointercapture", value);
  }
  get onpointercancel() {
    return level0.get(this, "onpointercancel");
  }
  set onpointercancel(value) {
    level0.set(this, "onpointercancel", value);
  }
  get onpointerdown() {
    return level0.get(this, "onpointerdown");
  }
  set onpointerdown(value) {
    level0.set(this, "onpointerdown", value);
  }
  get onpointerenter() {
    return level0.get(this, "onpointerenter");
  }
  set onpointerenter(value) {
    level0.set(this, "onpointerenter", value);
  }
  get onpointerleave() {
    return level0.get(this, "onpointerleave");
  }
  set onpointerleave(value) {
    level0.set(this, "onpointerleave", value);
  }
  get onpointermove() {
    return level0.get(this, "onpointermove");
  }
  set onpointermove(value) {
    level0.set(this, "onpointermove", value);
  }
  get onpointerout() {
    return level0.get(this, "onpointerout");
  }
  set onpointerout(value) {
    level0.set(this, "onpointerout", value);
  }
  get onpointerover() {
    return level0.get(this, "onpointerover");
  }
  set onpointerover(value) {
    level0.set(this, "onpointerover", value);
  }
  get onpointerup() {
    return level0.get(this, "onpointerup");
  }
  set onpointerup(value) {
    level0.set(this, "onpointerup", value);
  }
  /* c8 ignore stop */
};

// node_modules/linkedom/esm/html/template-element.js
var tagName = "template";
var HTMLTemplateElement = class extends HTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, tagName);
    const content = this.ownerDocument.createDocumentFragment();
    (this[CONTENT] = content)[PRIVATE] = this;
  }
  get content() {
    if (this.hasChildNodes() && !this[CONTENT].hasChildNodes()) {
      for (const node of this.childNodes)
        this[CONTENT].appendChild(node.cloneNode(true));
    }
    return this[CONTENT];
  }
};
registerHTMLClass(tagName, HTMLTemplateElement);

// node_modules/linkedom/esm/html/html-element.js
var HTMLHtmlElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "html") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/text-element.js
var { toString } = HTMLElement.prototype;
var TextElement = class extends HTMLElement {
  get innerHTML() {
    return this.textContent;
  }
  set innerHTML(html) {
    this.textContent = html;
  }
  toString() {
    const outerHTML = toString.call(this.cloneNode());
    return outerHTML.replace(/></, `>${this.textContent}<`);
  }
};

// node_modules/linkedom/esm/html/script-element.js
var tagName2 = "script";
var HTMLScriptElement = class extends TextElement {
  constructor(ownerDocument, localName = tagName2) {
    super(ownerDocument, localName);
  }
  get type() {
    return stringAttribute.get(this, "type");
  }
  set type(value) {
    stringAttribute.set(this, "type", value);
  }
  get src() {
    return stringAttribute.get(this, "src");
  }
  set src(value) {
    stringAttribute.set(this, "src", value);
  }
  get defer() {
    return booleanAttribute.get(this, "defer");
  }
  set defer(value) {
    booleanAttribute.set(this, "defer", value);
  }
  get crossOrigin() {
    return stringAttribute.get(this, "crossorigin");
  }
  set crossOrigin(value) {
    stringAttribute.set(this, "crossorigin", value);
  }
  get nomodule() {
    return booleanAttribute.get(this, "nomodule");
  }
  set nomodule(value) {
    booleanAttribute.set(this, "nomodule", value);
  }
  get referrerPolicy() {
    return stringAttribute.get(this, "referrerpolicy");
  }
  set referrerPolicy(value) {
    stringAttribute.set(this, "referrerpolicy", value);
  }
  get nonce() {
    return stringAttribute.get(this, "nonce");
  }
  set nonce(value) {
    stringAttribute.set(this, "nonce", value);
  }
  get async() {
    return booleanAttribute.get(this, "async");
  }
  set async(value) {
    booleanAttribute.set(this, "async", value);
  }
  get text() {
    return this.textContent;
  }
  set text(content) {
    this.textContent = content;
  }
};
registerHTMLClass(tagName2, HTMLScriptElement);

// node_modules/linkedom/esm/html/frame-element.js
var HTMLFrameElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "frame") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/i-frame-element.js
var tagName3 = "iframe";
var HTMLIFrameElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName3) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get src() {
    return stringAttribute.get(this, "src");
  }
  set src(value) {
    stringAttribute.set(this, "src", value);
  }
  get srcdoc() {
    return stringAttribute.get(this, "srcdoc");
  }
  set srcdoc(value) {
    stringAttribute.set(this, "srcdoc", value);
  }
  get name() {
    return stringAttribute.get(this, "name");
  }
  set name(value) {
    stringAttribute.set(this, "name", value);
  }
  get allow() {
    return stringAttribute.get(this, "allow");
  }
  set allow(value) {
    stringAttribute.set(this, "allow", value);
  }
  get allowFullscreen() {
    return booleanAttribute.get(this, "allowfullscreen");
  }
  set allowFullscreen(value) {
    booleanAttribute.set(this, "allowfullscreen", value);
  }
  get referrerPolicy() {
    return stringAttribute.get(this, "referrerpolicy");
  }
  set referrerPolicy(value) {
    stringAttribute.set(this, "referrerpolicy", value);
  }
  get loading() {
    return stringAttribute.get(this, "loading");
  }
  set loading(value) {
    stringAttribute.set(this, "loading", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName3, HTMLIFrameElement);

// node_modules/linkedom/esm/html/object-element.js
var HTMLObjectElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "object") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/head-element.js
var HTMLHeadElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "head") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/body-element.js
var HTMLBodyElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "body") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/style-element.js
var import_cssom = __toESM(require_lib(), 1);
var tagName4 = "style";
var HTMLStyleElement = class extends TextElement {
  constructor(ownerDocument, localName = tagName4) {
    super(ownerDocument, localName);
    this[SHEET] = null;
  }
  get sheet() {
    const sheet = this[SHEET];
    if (sheet !== null) {
      return sheet;
    }
    return this[SHEET] = (0, import_cssom.parse)(this.textContent);
  }
  get innerHTML() {
    return super.innerHTML || "";
  }
  set innerHTML(value) {
    super.textContent = value;
    this[SHEET] = null;
  }
  get innerText() {
    return super.innerText || "";
  }
  set innerText(value) {
    super.textContent = value;
    this[SHEET] = null;
  }
  get textContent() {
    return super.textContent || "";
  }
  set textContent(value) {
    super.textContent = value;
    this[SHEET] = null;
  }
};
registerHTMLClass(tagName4, HTMLStyleElement);

// node_modules/linkedom/esm/html/time-element.js
var HTMLTimeElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "time") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/field-set-element.js
var HTMLFieldSetElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "fieldset") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/embed-element.js
var HTMLEmbedElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "embed") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/hr-element.js
var HTMLHRElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "hr") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/progress-element.js
var HTMLProgressElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "progress") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/paragraph-element.js
var HTMLParagraphElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "p") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/table-element.js
var HTMLTableElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "table") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/frame-set-element.js
var HTMLFrameSetElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "frameset") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/li-element.js
var HTMLLIElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "li") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/base-element.js
var HTMLBaseElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "base") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/data-list-element.js
var HTMLDataListElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "datalist") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/input-element.js
var tagName5 = "input";
var HTMLInputElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName5) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get autofocus() {
    return booleanAttribute.get(this, "autofocus") || -1;
  }
  set autofocus(value) {
    booleanAttribute.set(this, "autofocus", value);
  }
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  get placeholder() {
    return this.getAttribute("placeholder");
  }
  set placeholder(value) {
    this.setAttribute("placeholder", value);
  }
  get type() {
    return this.getAttribute("type");
  }
  set type(value) {
    this.setAttribute("type", value);
  }
  get value() {
    return stringAttribute.get(this, "value");
  }
  set value(value) {
    stringAttribute.set(this, "value", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName5, HTMLInputElement);

// node_modules/linkedom/esm/html/param-element.js
var HTMLParamElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "param") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/media-element.js
var HTMLMediaElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "media") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/audio-element.js
var HTMLAudioElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "audio") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/heading-element.js
var tagName6 = "h1";
var HTMLHeadingElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName6) {
    super(ownerDocument, localName);
  }
};
registerHTMLClass([tagName6, "h2", "h3", "h4", "h5", "h6"], HTMLHeadingElement);

// node_modules/linkedom/esm/html/directory-element.js
var HTMLDirectoryElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "dir") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/quote-element.js
var HTMLQuoteElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "quote") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/canvas-element.js
var import_canvas = __toESM(require_canvas(), 1);
var { createCanvas } = import_canvas.default;
var tagName7 = "canvas";
var HTMLCanvasElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName7) {
    super(ownerDocument, localName);
    this[IMAGE] = createCanvas(300, 150);
  }
  get width() {
    return this[IMAGE].width;
  }
  set width(value) {
    numericAttribute.set(this, "width", value);
    this[IMAGE].width = value;
  }
  get height() {
    return this[IMAGE].height;
  }
  set height(value) {
    numericAttribute.set(this, "height", value);
    this[IMAGE].height = value;
  }
  getContext(type) {
    return this[IMAGE].getContext(type);
  }
  toDataURL(...args) {
    return this[IMAGE].toDataURL(...args);
  }
};
registerHTMLClass(tagName7, HTMLCanvasElement);

// node_modules/linkedom/esm/html/legend-element.js
var HTMLLegendElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "legend") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/option-element.js
var tagName8 = "option";
var HTMLOptionElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName8) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get value() {
    return stringAttribute.get(this, "value");
  }
  set value(value) {
    stringAttribute.set(this, "value", value);
  }
  /* c8 ignore stop */
  get selected() {
    return booleanAttribute.get(this, "selected");
  }
  set selected(value) {
    const option = this.parentElement?.querySelector("option[selected]");
    if (option && option !== this)
      option.selected = false;
    booleanAttribute.set(this, "selected", value);
  }
};
registerHTMLClass(tagName8, HTMLOptionElement);

// node_modules/linkedom/esm/html/span-element.js
var HTMLSpanElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "span") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/meter-element.js
var HTMLMeterElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "meter") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/video-element.js
var HTMLVideoElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "video") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/table-cell-element.js
var HTMLTableCellElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "td") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/title-element.js
var tagName9 = "title";
var HTMLTitleElement = class extends TextElement {
  constructor(ownerDocument, localName = tagName9) {
    super(ownerDocument, localName);
  }
};
registerHTMLClass(tagName9, HTMLTitleElement);

// node_modules/linkedom/esm/html/output-element.js
var HTMLOutputElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "output") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/table-row-element.js
var HTMLTableRowElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "tr") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/data-element.js
var HTMLDataElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "data") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/menu-element.js
var HTMLMenuElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "menu") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/select-element.js
var tagName10 = "select";
var HTMLSelectElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName10) {
    super(ownerDocument, localName);
  }
  get options() {
    let children = new NodeList();
    let { firstElementChild } = this;
    while (firstElementChild) {
      if (firstElementChild.tagName === "OPTGROUP")
        children.push(...firstElementChild.children);
      else
        children.push(firstElementChild);
      firstElementChild = firstElementChild.nextElementSibling;
    }
    return children;
  }
  /* c8 ignore start */
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  /* c8 ignore stop */
  get value() {
    return this.querySelector("option[selected]")?.value;
  }
};
registerHTMLClass(tagName10, HTMLSelectElement);

// node_modules/linkedom/esm/html/br-element.js
var HTMLBRElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "br") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/button-element.js
var tagName11 = "button";
var HTMLButtonElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName11) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  get type() {
    return this.getAttribute("type");
  }
  set type(value) {
    this.setAttribute("type", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName11, HTMLButtonElement);

// node_modules/linkedom/esm/html/map-element.js
var HTMLMapElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "map") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/opt-group-element.js
var HTMLOptGroupElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "optgroup") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/d-list-element.js
var HTMLDListElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "dl") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/text-area-element.js
var tagName12 = "textarea";
var HTMLTextAreaElement = class extends TextElement {
  constructor(ownerDocument, localName = tagName12) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  get placeholder() {
    return this.getAttribute("placeholder");
  }
  set placeholder(value) {
    this.setAttribute("placeholder", value);
  }
  get type() {
    return this.getAttribute("type");
  }
  set type(value) {
    this.setAttribute("type", value);
  }
  get value() {
    return this.textContent;
  }
  set value(content) {
    this.textContent = content;
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName12, HTMLTextAreaElement);

// node_modules/linkedom/esm/html/font-element.js
var HTMLFontElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "font") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/div-element.js
var HTMLDivElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "div") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/link-element.js
var tagName13 = "link";
var HTMLLinkElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName13) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  // copy paste from img.src, already covered
  get disabled() {
    return booleanAttribute.get(this, "disabled");
  }
  set disabled(value) {
    booleanAttribute.set(this, "disabled", value);
  }
  get href() {
    return stringAttribute.get(this, "href");
  }
  set href(value) {
    stringAttribute.set(this, "href", value);
  }
  get hreflang() {
    return stringAttribute.get(this, "hreflang");
  }
  set hreflang(value) {
    stringAttribute.set(this, "hreflang", value);
  }
  get media() {
    return stringAttribute.get(this, "media");
  }
  set media(value) {
    stringAttribute.set(this, "media", value);
  }
  get rel() {
    return stringAttribute.get(this, "rel");
  }
  set rel(value) {
    stringAttribute.set(this, "rel", value);
  }
  get type() {
    return stringAttribute.get(this, "type");
  }
  set type(value) {
    stringAttribute.set(this, "type", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName13, HTMLLinkElement);

// node_modules/linkedom/esm/html/slot-element.js
var tagName14 = "slot";
var HTMLSlotElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName14) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get name() {
    return this.getAttribute("name");
  }
  set name(value) {
    this.setAttribute("name", value);
  }
  assign() {
  }
  assignedNodes(options) {
    const isNamedSlot = !!this.name;
    const hostChildNodes = this.getRootNode().host?.childNodes ?? [];
    let slottables;
    if (isNamedSlot) {
      slottables = [...hostChildNodes].filter((node) => node.slot === this.name);
    } else {
      slottables = [...hostChildNodes].filter((node) => !node.slot);
    }
    if (options?.flatten) {
      const result = [];
      for (let slottable of slottables) {
        if (slottable.localName === "slot") {
          result.push(...slottable.assignedNodes({ flatten: true }));
        } else {
          result.push(slottable);
        }
      }
      slottables = result;
    }
    return slottables.length ? slottables : [...this.childNodes];
  }
  assignedElements(options) {
    const slottables = this.assignedNodes(options).filter((n) => n.nodeType === 1);
    return slottables.length ? slottables : [...this.children];
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName14, HTMLSlotElement);

// node_modules/linkedom/esm/html/form-element.js
var HTMLFormElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "form") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/image-element.js
var tagName15 = "img";
var HTMLImageElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName15) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get alt() {
    return stringAttribute.get(this, "alt");
  }
  set alt(value) {
    stringAttribute.set(this, "alt", value);
  }
  get sizes() {
    return stringAttribute.get(this, "sizes");
  }
  set sizes(value) {
    stringAttribute.set(this, "sizes", value);
  }
  get src() {
    return stringAttribute.get(this, "src");
  }
  set src(value) {
    stringAttribute.set(this, "src", value);
  }
  get srcset() {
    return stringAttribute.get(this, "srcset");
  }
  set srcset(value) {
    stringAttribute.set(this, "srcset", value);
  }
  get title() {
    return stringAttribute.get(this, "title");
  }
  set title(value) {
    stringAttribute.set(this, "title", value);
  }
  get width() {
    return numericAttribute.get(this, "width");
  }
  set width(value) {
    numericAttribute.set(this, "width", value);
  }
  get height() {
    return numericAttribute.get(this, "height");
  }
  set height(value) {
    numericAttribute.set(this, "height", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName15, HTMLImageElement);

// node_modules/linkedom/esm/html/pre-element.js
var HTMLPreElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "pre") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/u-list-element.js
var HTMLUListElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "ul") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/meta-element.js
var tagName16 = "meta";
var HTMLMetaElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName16) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get name() {
    return stringAttribute.get(this, "name");
  }
  set name(value) {
    stringAttribute.set(this, "name", value);
  }
  get httpEquiv() {
    return stringAttribute.get(this, "http-equiv");
  }
  set httpEquiv(value) {
    stringAttribute.set(this, "http-equiv", value);
  }
  get content() {
    return stringAttribute.get(this, "content");
  }
  set content(value) {
    stringAttribute.set(this, "content", value);
  }
  get charset() {
    return stringAttribute.get(this, "charset");
  }
  set charset(value) {
    stringAttribute.set(this, "charset", value);
  }
  get media() {
    return stringAttribute.get(this, "media");
  }
  set media(value) {
    stringAttribute.set(this, "media", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName16, HTMLMetaElement);

// node_modules/linkedom/esm/html/picture-element.js
var HTMLPictureElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "picture") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/area-element.js
var HTMLAreaElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "area") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/o-list-element.js
var HTMLOListElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "ol") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/table-caption-element.js
var HTMLTableCaptionElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "caption") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/anchor-element.js
var tagName17 = "a";
var HTMLAnchorElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName17) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  // copy paste from img.src, already covered
  get href() {
    return encodeURI(decodeURI(stringAttribute.get(this, "href")));
  }
  set href(value) {
    stringAttribute.set(this, "href", decodeURI(value));
  }
  get download() {
    return encodeURI(decodeURI(stringAttribute.get(this, "download")));
  }
  set download(value) {
    stringAttribute.set(this, "download", decodeURI(value));
  }
  get target() {
    return stringAttribute.get(this, "target");
  }
  set target(value) {
    stringAttribute.set(this, "target", value);
  }
  get type() {
    return stringAttribute.get(this, "type");
  }
  set type(value) {
    stringAttribute.set(this, "type", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName17, HTMLAnchorElement);

// node_modules/linkedom/esm/html/label-element.js
var HTMLLabelElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "label") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/unknown-element.js
var HTMLUnknownElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "unknown") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/mod-element.js
var HTMLModElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "mod") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/details-element.js
var HTMLDetailsElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "details") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/source-element.js
var tagName18 = "source";
var HTMLSourceElement = class extends HTMLElement {
  constructor(ownerDocument, localName = tagName18) {
    super(ownerDocument, localName);
  }
  /* c8 ignore start */
  get src() {
    return stringAttribute.get(this, "src");
  }
  set src(value) {
    stringAttribute.set(this, "src", value);
  }
  get srcset() {
    return stringAttribute.get(this, "srcset");
  }
  set srcset(value) {
    stringAttribute.set(this, "srcset", value);
  }
  get sizes() {
    return stringAttribute.get(this, "sizes");
  }
  set sizes(value) {
    stringAttribute.set(this, "sizes", value);
  }
  get type() {
    return stringAttribute.get(this, "type");
  }
  set type(value) {
    stringAttribute.set(this, "type", value);
  }
  /* c8 ignore stop */
};
registerHTMLClass(tagName18, HTMLSourceElement);

// node_modules/linkedom/esm/html/track-element.js
var HTMLTrackElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "track") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/html/marquee-element.js
var HTMLMarqueeElement = class extends HTMLElement {
  constructor(ownerDocument, localName = "marquee") {
    super(ownerDocument, localName);
  }
};

// node_modules/linkedom/esm/shared/html-classes.js
var HTMLClasses = {
  HTMLElement,
  HTMLTemplateElement,
  HTMLHtmlElement,
  HTMLScriptElement,
  HTMLFrameElement,
  HTMLIFrameElement,
  HTMLObjectElement,
  HTMLHeadElement,
  HTMLBodyElement,
  HTMLStyleElement,
  HTMLTimeElement,
  HTMLFieldSetElement,
  HTMLEmbedElement,
  HTMLHRElement,
  HTMLProgressElement,
  HTMLParagraphElement,
  HTMLTableElement,
  HTMLFrameSetElement,
  HTMLLIElement,
  HTMLBaseElement,
  HTMLDataListElement,
  HTMLInputElement,
  HTMLParamElement,
  HTMLMediaElement,
  HTMLAudioElement,
  HTMLHeadingElement,
  HTMLDirectoryElement,
  HTMLQuoteElement,
  HTMLCanvasElement,
  HTMLLegendElement,
  HTMLOptionElement,
  HTMLSpanElement,
  HTMLMeterElement,
  HTMLVideoElement,
  HTMLTableCellElement,
  HTMLTitleElement,
  HTMLOutputElement,
  HTMLTableRowElement,
  HTMLDataElement,
  HTMLMenuElement,
  HTMLSelectElement,
  HTMLBRElement,
  HTMLButtonElement,
  HTMLMapElement,
  HTMLOptGroupElement,
  HTMLDListElement,
  HTMLTextAreaElement,
  HTMLFontElement,
  HTMLDivElement,
  HTMLLinkElement,
  HTMLSlotElement,
  HTMLFormElement,
  HTMLImageElement,
  HTMLPreElement,
  HTMLUListElement,
  HTMLMetaElement,
  HTMLPictureElement,
  HTMLAreaElement,
  HTMLOListElement,
  HTMLTableCaptionElement,
  HTMLAnchorElement,
  HTMLLabelElement,
  HTMLUnknownElement,
  HTMLModElement,
  HTMLDetailsElement,
  HTMLSourceElement,
  HTMLTrackElement,
  HTMLMarqueeElement
};

// node_modules/linkedom/esm/shared/mime.js
var voidElements2 = { test: () => true };
var Mime = {
  "text/html": {
    docType: "<!DOCTYPE html>",
    ignoreCase: true,
    voidElements: /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i
  },
  "image/svg+xml": {
    docType: '<?xml version="1.0" encoding="utf-8"?>',
    ignoreCase: false,
    voidElements: voidElements2
  },
  "text/xml": {
    docType: '<?xml version="1.0" encoding="utf-8"?>',
    ignoreCase: false,
    voidElements: voidElements2
  },
  "application/xml": {
    docType: '<?xml version="1.0" encoding="utf-8"?>',
    ignoreCase: false,
    voidElements: voidElements2
  },
  "application/xhtml+xml": {
    docType: '<?xml version="1.0" encoding="utf-8"?>',
    ignoreCase: false,
    voidElements: voidElements2
  }
};

// node_modules/linkedom/esm/interface/custom-event.js
var CustomEvent = class extends GlobalEvent {
  constructor(type, eventInitDict = {}) {
    super(type, eventInitDict);
    this.detail = eventInitDict.detail;
  }
};

// node_modules/linkedom/esm/interface/input-event.js
var InputEvent = class extends GlobalEvent {
  constructor(type, inputEventInit = {}) {
    super(type, inputEventInit);
    this.inputType = inputEventInit.inputType;
    this.data = inputEventInit.data;
    this.dataTransfer = inputEventInit.dataTransfer;
    this.isComposing = inputEventInit.isComposing || false;
    this.ranges = inputEventInit.ranges;
  }
};

// node_modules/linkedom/esm/interface/image.js
var ImageClass = (ownerDocument) => (
  /**
   * @implements globalThis.Image
   */
  class Image extends HTMLImageElement {
    constructor(width, height) {
      super(ownerDocument);
      switch (arguments.length) {
        case 1:
          this.height = width;
          this.width = width;
          break;
        case 2:
          this.height = height;
          this.width = width;
          break;
      }
    }
  }
);

// node_modules/linkedom/esm/interface/range.js
var deleteContents = ({ [START]: start, [END]: end }, fragment = null) => {
  setAdjacent(start[PREV], end[NEXT]);
  do {
    const after2 = getEnd(start);
    const next = after2 === end ? after2 : after2[NEXT];
    if (fragment)
      fragment.insertBefore(start, fragment[END]);
    else
      start.remove();
    start = next;
  } while (start !== end);
};
var Range = class _Range {
  constructor() {
    this[START] = null;
    this[END] = null;
    this.commonAncestorContainer = null;
  }
  /* TODO: this is more complicated than it looks
    setStart(node, offset) {
      this[START] = node.childNodes[offset];
    }
  
    setEnd(node, offset) {
      this[END] = getEnd(node.childNodes[offset]);
    }
    //*/
  insertNode(newNode) {
    this[END].parentNode.insertBefore(newNode, this[START]);
  }
  selectNode(node) {
    this[START] = node;
    this[END] = getEnd(node);
  }
  // TODO: SVG elements should then create contextual fragments
  //       that return SVG nodes
  selectNodeContents(node) {
    this.selectNode(node);
    this.commonAncestorContainer = node;
  }
  surroundContents(parentNode) {
    parentNode.replaceChildren(this.extractContents());
  }
  setStartBefore(node) {
    this[START] = node;
  }
  setStartAfter(node) {
    this[START] = node.nextSibling;
  }
  setEndBefore(node) {
    this[END] = getEnd(node.previousSibling);
  }
  setEndAfter(node) {
    this[END] = getEnd(node);
  }
  cloneContents() {
    let { [START]: start, [END]: end } = this;
    const fragment = start.ownerDocument.createDocumentFragment();
    while (start !== end) {
      fragment.insertBefore(start.cloneNode(true), fragment[END]);
      start = getEnd(start);
      if (start !== end)
        start = start[NEXT];
    }
    return fragment;
  }
  deleteContents() {
    deleteContents(this);
  }
  extractContents() {
    const fragment = this[START].ownerDocument.createDocumentFragment();
    deleteContents(this, fragment);
    return fragment;
  }
  createContextualFragment(html) {
    const { commonAncestorContainer: doc } = this;
    const isSVG = "ownerSVGElement" in doc;
    const document = isSVG ? doc.ownerDocument : doc;
    const template = document.createElement("template");
    template.innerHTML = html;
    let { content } = template;
    if (isSVG) {
      const childNodes = [...content.childNodes];
      content = document.createDocumentFragment();
      Object.setPrototypeOf(content, SVGElement.prototype);
      content.ownerSVGElement = document;
      for (const child of childNodes) {
        Object.setPrototypeOf(child, SVGElement.prototype);
        child.ownerSVGElement = document;
        content.appendChild(child);
      }
    } else
      this.selectNode(content);
    return content;
  }
  cloneRange() {
    const range = new _Range();
    range[START] = this[START];
    range[END] = this[END];
    return range;
  }
};

// node_modules/linkedom/esm/interface/tree-walker.js
var isOK = ({ nodeType }, mask) => {
  switch (nodeType) {
    case ELEMENT_NODE:
      return mask & SHOW_ELEMENT;
    case TEXT_NODE:
      return mask & SHOW_TEXT;
    case COMMENT_NODE:
      return mask & SHOW_COMMENT;
    case CDATA_SECTION_NODE:
      return mask & SHOW_CDATA_SECTION;
  }
  return 0;
};
var TreeWalker = class {
  constructor(root, whatToShow = SHOW_ALL) {
    this.root = root;
    this.currentNode = root;
    this.whatToShow = whatToShow;
    let { [NEXT]: next, [END]: end } = root;
    if (root.nodeType === DOCUMENT_NODE) {
      const { documentElement } = root;
      next = documentElement;
      end = documentElement[END];
    }
    const nodes = [];
    while (next !== end) {
      if (isOK(next, whatToShow))
        nodes.push(next);
      next = next[NEXT];
    }
    this[PRIVATE] = { i: 0, nodes };
  }
  nextNode() {
    const $ = this[PRIVATE];
    this.currentNode = $.i < $.nodes.length ? $.nodes[$.i++] : null;
    return this.currentNode;
  }
};

// node_modules/linkedom/esm/interface/document.js
var query = (method, ownerDocument, selectors) => {
  let { [NEXT]: next, [END]: end } = ownerDocument;
  return method.call({ ownerDocument, [NEXT]: next, [END]: end }, selectors);
};
var globalExports = assign(
  {},
  Facades,
  HTMLClasses,
  {
    CustomEvent,
    Event: GlobalEvent,
    EventTarget: DOMEventTarget,
    InputEvent,
    NamedNodeMap,
    NodeList
  }
);
var window2 = /* @__PURE__ */ new WeakMap();
var Document2 = class extends NonElementParentNode {
  constructor(type) {
    super(null, "#document", DOCUMENT_NODE);
    this[CUSTOM_ELEMENTS] = { active: false, registry: null };
    this[MUTATION_OBSERVER] = { active: false, class: null };
    this[MIME] = Mime[type];
    this[DOCTYPE] = null;
    this[DOM_PARSER] = null;
    this[GLOBALS] = null;
    this[IMAGE] = null;
    this[UPGRADE] = null;
  }
  /**
   * @type {globalThis.Document['defaultView']}
   */
  get defaultView() {
    if (!window2.has(this))
      window2.set(this, new Proxy(globalThis, {
        set: (target, name, value) => {
          switch (name) {
            case "addEventListener":
            case "removeEventListener":
            case "dispatchEvent":
              this[EVENT_TARGET][name] = value;
              break;
            default:
              target[name] = value;
              break;
          }
          return true;
        },
        get: (globalThis2, name) => {
          switch (name) {
            case "addEventListener":
            case "removeEventListener":
            case "dispatchEvent":
              if (!this[EVENT_TARGET]) {
                const et = this[EVENT_TARGET] = new DOMEventTarget();
                et.dispatchEvent = et.dispatchEvent.bind(et);
                et.addEventListener = et.addEventListener.bind(et);
                et.removeEventListener = et.removeEventListener.bind(et);
              }
              return this[EVENT_TARGET][name];
            case "document":
              return this;
            case "navigator":
              return {
                userAgent: "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"
              };
            case "window":
              return window2.get(this);
            case "customElements":
              if (!this[CUSTOM_ELEMENTS].registry)
                this[CUSTOM_ELEMENTS] = new CustomElementRegistry(this);
              return this[CUSTOM_ELEMENTS];
            case "performance":
              return import_perf_hooks.performance;
            case "DOMParser":
              return this[DOM_PARSER];
            case "Image":
              if (!this[IMAGE])
                this[IMAGE] = ImageClass(this);
              return this[IMAGE];
            case "MutationObserver":
              if (!this[MUTATION_OBSERVER].class)
                this[MUTATION_OBSERVER] = new MutationObserverClass(this);
              return this[MUTATION_OBSERVER].class;
          }
          return this[GLOBALS] && this[GLOBALS][name] || globalExports[name] || globalThis2[name];
        }
      }));
    return window2.get(this);
  }
  get doctype() {
    const docType = this[DOCTYPE];
    if (docType)
      return docType;
    const { firstChild } = this;
    if (firstChild && firstChild.nodeType === DOCUMENT_TYPE_NODE)
      return this[DOCTYPE] = firstChild;
    return null;
  }
  set doctype(value) {
    if (/^([a-z:]+)(\s+system|\s+public(\s+"([^"]+)")?)?(\s+"([^"]+)")?/i.test(value)) {
      const { $1: name, $4: publicId, $6: systemId } = RegExp;
      this[DOCTYPE] = new DocumentType(this, name, publicId, systemId);
      knownSiblings(this, this[DOCTYPE], this[NEXT]);
    }
  }
  get documentElement() {
    return this.firstElementChild;
  }
  get isConnected() {
    return true;
  }
  /**
   * @protected
   */
  _getParent() {
    return this[EVENT_TARGET];
  }
  createAttribute(name) {
    return new Attr(this, name);
  }
  createCDATASection(data) {
    return new CDATASection(this, data);
  }
  createComment(textContent2) {
    return new Comment3(this, textContent2);
  }
  createDocumentFragment() {
    return new DocumentFragment(this);
  }
  createDocumentType(name, publicId, systemId) {
    return new DocumentType(this, name, publicId, systemId);
  }
  createElement(localName) {
    return new Element2(this, localName);
  }
  createRange() {
    const range = new Range();
    range.commonAncestorContainer = this;
    return range;
  }
  createTextNode(textContent2) {
    return new Text3(this, textContent2);
  }
  createTreeWalker(root, whatToShow = -1) {
    return new TreeWalker(root, whatToShow);
  }
  createNodeIterator(root, whatToShow = -1) {
    return this.createTreeWalker(root, whatToShow);
  }
  createEvent(name) {
    const event = create(name === "Event" ? new GlobalEvent("") : new CustomEvent(""));
    event.initEvent = event.initCustomEvent = (type, canBubble = false, cancelable = false, detail) => {
      event.bubbles = !!canBubble;
      defineProperties(event, {
        type: { value: type },
        canBubble: { value: canBubble },
        cancelable: { value: cancelable },
        detail: { value: detail }
      });
    };
    return event;
  }
  cloneNode(deep = false) {
    const {
      constructor,
      [CUSTOM_ELEMENTS]: customElements2,
      [DOCTYPE]: doctype
    } = this;
    const document = new constructor();
    document[CUSTOM_ELEMENTS] = customElements2;
    if (deep) {
      const end = document[END];
      const { childNodes } = this;
      for (let { length } = childNodes, i = 0; i < length; i++)
        document.insertBefore(childNodes[i].cloneNode(true), end);
      if (doctype)
        document[DOCTYPE] = childNodes[0];
    }
    return document;
  }
  importNode(externalNode) {
    const deep = 1 < arguments.length && !!arguments[1];
    const node = externalNode.cloneNode(deep);
    const { [CUSTOM_ELEMENTS]: customElements2 } = this;
    const { active } = customElements2;
    const upgrade = (element) => {
      const { ownerDocument, nodeType } = element;
      element.ownerDocument = this;
      if (active && ownerDocument !== this && nodeType === ELEMENT_NODE)
        customElements2.upgrade(element);
    };
    upgrade(node);
    if (deep) {
      switch (node.nodeType) {
        case ELEMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE: {
          let { [NEXT]: next, [END]: end } = node;
          while (next !== end) {
            if (next.nodeType === ELEMENT_NODE)
              upgrade(next);
            next = next[NEXT];
          }
          break;
        }
      }
    }
    return node;
  }
  toString() {
    return this.childNodes.join("");
  }
  querySelector(selectors) {
    return query(super.querySelector, this, selectors);
  }
  querySelectorAll(selectors) {
    return query(super.querySelectorAll, this, selectors);
  }
  /* c8 ignore start */
  getElementsByTagNameNS(_, name) {
    return this.getElementsByTagName(name);
  }
  createAttributeNS(_, name) {
    return this.createAttribute(name);
  }
  createElementNS(nsp, localName, options) {
    return nsp === SVG_NAMESPACE ? new SVGElement(this, localName, null) : this.createElement(localName, options);
  }
  /* c8 ignore stop */
};
setPrototypeOf(
  globalExports.Document = function Document3() {
    illegalConstructor();
  },
  Document2
).prototype = Document2.prototype;

// node_modules/linkedom/esm/html/document.js
var createHTMLElement = (ownerDocument, builtin, localName, options) => {
  if (!builtin && htmlClasses.has(localName)) {
    const Class = htmlClasses.get(localName);
    return new Class(ownerDocument, localName);
  }
  const { [CUSTOM_ELEMENTS]: { active, registry } } = ownerDocument;
  if (active) {
    const ce = builtin ? options.is : localName;
    if (registry.has(ce)) {
      const { Class } = registry.get(ce);
      const element = new Class(ownerDocument, localName);
      customElements.set(element, { connected: false });
      return element;
    }
  }
  return new HTMLElement(ownerDocument, localName);
};
var HTMLDocument = class extends Document2 {
  constructor() {
    super("text/html");
  }
  get all() {
    const nodeList = new NodeList();
    let { [NEXT]: next, [END]: end } = this;
    while (next !== end) {
      switch (next.nodeType) {
        case ELEMENT_NODE:
          nodeList.push(next);
          break;
      }
      next = next[NEXT];
    }
    return nodeList;
  }
  /**
   * @type HTMLHeadElement
   */
  get head() {
    const { documentElement } = this;
    let { firstElementChild } = documentElement;
    if (!firstElementChild || firstElementChild.tagName !== "HEAD") {
      firstElementChild = this.createElement("head");
      documentElement.prepend(firstElementChild);
    }
    return firstElementChild;
  }
  /**
   * @type HTMLBodyElement
   */
  get body() {
    const { head } = this;
    let { nextElementSibling: nextElementSibling3 } = head;
    if (!nextElementSibling3 || nextElementSibling3.tagName !== "BODY") {
      nextElementSibling3 = this.createElement("body");
      head.after(nextElementSibling3);
    }
    return nextElementSibling3;
  }
  /**
   * @type HTMLTitleElement
   */
  get title() {
    const { head } = this;
    return head.getElementsByTagName("title").at(0)?.textContent || "";
  }
  set title(textContent2) {
    const { head } = this;
    let title = head.getElementsByTagName("title").at(0);
    if (title)
      title.textContent = textContent2;
    else {
      head.insertBefore(
        this.createElement("title"),
        head.firstChild
      ).textContent = textContent2;
    }
  }
  createElement(localName, options) {
    const builtin = !!(options && options.is);
    const element = createHTMLElement(this, builtin, localName, options);
    if (builtin)
      element.setAttribute("is", options.is);
    return element;
  }
};

// node_modules/linkedom/esm/svg/document.js
var SVGDocument = class extends Document2 {
  constructor() {
    super("image/svg+xml");
  }
  toString() {
    return this[MIME].docType + super.toString();
  }
};

// node_modules/linkedom/esm/xml/document.js
var XMLDocument = class extends Document2 {
  constructor() {
    super("text/xml");
  }
  toString() {
    return this[MIME].docType + super.toString();
  }
};

// node_modules/linkedom/esm/dom/parser.js
var DOMParser = class _DOMParser {
  /** @typedef {{ "text/html": HTMLDocument, "image/svg+xml": SVGDocument, "text/xml": XMLDocument }} MimeToDoc */
  /**
   * @template {keyof MimeToDoc} MIME
   * @param {string} markupLanguage
   * @param {MIME} mimeType
   * @returns {MimeToDoc[MIME]}
   */
  parseFromString(markupLanguage, mimeType, globals = null) {
    let isHTML = false, document;
    if (mimeType === "text/html") {
      isHTML = true;
      document = new HTMLDocument();
    } else if (mimeType === "image/svg+xml")
      document = new SVGDocument();
    else
      document = new XMLDocument();
    document[DOM_PARSER] = _DOMParser;
    if (globals)
      document[GLOBALS] = globals;
    if (isHTML && markupLanguage === "...")
      markupLanguage = "<!doctype html><html><head></head><body></body></html>";
    return markupLanguage ? parseFromString(document, isHTML, markupLanguage) : document;
  }
};

// node_modules/linkedom/esm/shared/parse-json.js
var { parse: parse4 } = JSON;

// node_modules/linkedom/esm/index.js
var parseHTML = (html, globals = null) => new DOMParser().parseFromString(
  html,
  "text/html",
  globals
).defaultView;
function Document4() {
  illegalConstructor();
}
setPrototypeOf(Document4, Document2).prototype = Document2.prototype;

// src/html-to-pdf.ts
init_empty();
init_url_empty();

// src/types/fonts.ts
var TtfFontMetrics = class {
  constructor(metrics, glyphMetrics, cmap, headBBox, getGlyphOutline, kerning) {
    this.metrics = metrics;
    this.glyphMetrics = glyphMetrics;
    this.cmap = cmap;
    this.headBBox = headBBox;
    this.getGlyphOutline = getGlyphOutline;
    this.kerning = kerning;
  }
};

// src/logging/debug.ts
var LEVEL_COLORS = {
  trace: "\x1B[90m",
  debug: "\x1B[36m",
  info: "\x1B[32m",
  warn: "\x1B[33m",
  error: "\x1B[31m"
};
var CATEGORY_COLORS = {
  parse: "\x1B[95m",
  style: "\x1B[94m",
  layout: "\x1B[96m",
  paint: "\x1B[93m",
  font: "\x1B[92m",
  encoding: "\x1B[35m",
  pdf: "\x1B[91m"
};
var LOG_CATEGORIES = Object.keys(CATEGORY_COLORS);
var RESET = "\x1B[0m";
var DEFAULT_CAT_COLOR = "\x1B[37m";
var order = ["trace", "debug", "info", "warn", "error"];
var current = { level: "warn", cats: /* @__PURE__ */ new Set() };
function configureDebug(opts) {
  if (!opts) return;
  if (opts.level) current.level = opts.level;
  if (opts.cats) current.cats = new Set(opts.cats.map((cat) => cat.toLowerCase()));
}
function log(cat, level, msg, obj) {
  const levelKey = level.toLowerCase();
  const normalizedCat = cat.toLowerCase();
  const configuredLevel = order.includes(current.level) ? current.level : "warn";
  if (!order.includes(levelKey)) return;
  if (order.indexOf(levelKey) < order.indexOf(configuredLevel)) return;
  if (current.cats.size && !current.cats.has(normalizedCat)) return;
  const levelColor = LEVEL_COLORS[levelKey] ?? "";
  const catColor = CATEGORY_COLORS[normalizedCat] ?? DEFAULT_CAT_COLOR;
  const prefix = `${levelColor}[${levelKey.toUpperCase()}]${RESET} ${catColor}${cat}${RESET}`;
  if (obj !== void 0) {
    console.log(prefix, msg, obj);
  } else {
    console.log(prefix, msg);
  }
}

// src/html/css/parse-css.ts
var cssParser = __toESM(require_css(), 1);

// src/css/selectors/parser.ts
function parseSelector2(selector) {
  if (!selector?.trim()) {
    return null;
  }
  function parseNth(expr) {
    const s2 = expr.replace(/\s+/g, "");
    if (s2 === "odd") {
      return { a: 2, b: 1 };
    }
    if (s2 === "even") {
      return { a: 2, b: 0 };
    }
    if (/^[+-]?\d+$/.test(s2)) {
      const result3 = { a: 0, b: parseInt(s2, 10) };
      return result3;
    }
    const m = /^([+-]?\d*)n([+-]?\d+)?$/.exec(s2);
    if (!m) {
      return null;
    }
    const a = m[1] === "" || m[1] === "+" ? 1 : m[1] === "-" ? -1 : parseInt(m[1], 10);
    const b = m[2] ? parseInt(m[2], 10) : 0;
    const result2 = { a, b };
    return result2;
  }
  function parseSimpleToken(tok) {
    let rest = tok.trim();
    if (!rest) {
      return null;
    }
    let tag = null;
    if (rest[0] === "*") {
      tag = null;
      rest = rest.slice(1);
    } else if (!["#", ".", "[", ":"].includes(rest[0])) {
      const m = /^[a-zA-Z][a-zA-Z0-9-]*/.exec(rest);
      if (m) {
        tag = m[0].toLowerCase();
        rest = rest.slice(m[0].length);
      }
    }
    let id = null;
    const classes = [];
    const attrs = [];
    const pseudos2 = [];
    while (rest.length) {
      const ch = rest[0];
      if (ch === "#") {
        const m = /^#[^.#\[\]:\s>+~]+/.exec(rest);
        if (!m) break;
        id = m[0].slice(1);
        rest = rest.slice(m[0].length);
        continue;
      }
      if (ch === ".") {
        const m = /^\.[^.#\[\]:\s>+~]+/.exec(rest);
        if (!m) break;
        classes.push(m[0].slice(1));
        rest = rest.slice(m[0].length);
        continue;
      }
      if (ch === "[") {
        const m = /^\[(\s*[-\w:]+\s*(?:([~|^$*]?=)\s*(?:"([^"]*)"|'([^']*)'|([^\]\s]+))\s*)?)\]/.exec(rest);
        if (!m) break;
        const name = m[1].match(/^[-\w:]+/)[0];
        const op = m[2] ?? "exists";
        const val = m[3] ?? m[4] ?? m[5];
        const attr = op === "exists" ? { name, op } : { name, op, value: val };
        attrs.push(attr);
        rest = rest.slice(m[0].length);
        continue;
      }
      if (ch === ":") {
        let m = /^:first-child/.exec(rest);
        if (m) {
          pseudos2.push({ kind: "first-child" });
          rest = rest.slice(m[0].length);
          continue;
        }
        m = /^:last-child/.exec(rest);
        if (m) {
          pseudos2.push({ kind: "last-child" });
          rest = rest.slice(m[0].length);
          continue;
        }
        m = /^:root\b/.exec(rest);
        if (m) {
          pseudos2.push({ kind: "root" });
          rest = rest.slice(m[0].length);
          continue;
        }
        m = /^:nth-child\(\s*([^)]+)\s*\)/.exec(rest);
        if (m) {
          const nb = parseNth(m[1]);
          if (nb) {
            pseudos2.push({ kind: "nth-child", a: nb.a, b: nb.b });
          }
          rest = rest.slice(m[0].length);
          continue;
        }
        m = /^:not\(\s*([^)]+)\s*\)/.exec(rest);
        if (m) {
          const innerTok = m[1];
          const inner = parseSimpleToken(innerTok);
          if (inner) pseudos2.push({ kind: "not", inner });
          rest = rest.slice(m[0].length);
          continue;
        }
        return null;
      }
      break;
    }
    const result2 = { tag, id, classes, attrs, pseudos: pseudos2 };
    return result2;
  }
  const s = selector.trim().replace(/\s+/g, " ");
  const tokens = [];
  let i = 0;
  while (i < s.length) {
    const c = s[i];
    if (c === " " || c === ">" || c === "+" || c === "~") {
      if (c === " ") {
        while (s[i] === " ") i++;
        tokens.push(" ");
      } else {
        tokens.push(c);
        i++;
        if (s[i] === " ") i++;
      }
      continue;
    }
    let j = i, depthSq = 0, depthPar = 0;
    while (j < s.length) {
      const ch = s[j];
      if (ch === "[") depthSq++;
      else if (ch === "]") depthSq = Math.max(0, depthSq - 1);
      else if (ch === "(") depthPar++;
      else if (ch === ")") depthPar = Math.max(0, depthPar - 1);
      else if (depthSq === 0 && depthPar === 0 && (ch === " " || ch === ">" || ch === "+" || ch === "~")) break;
      j++;
    }
    const raw = s.slice(i, j);
    const simp = parseSimpleToken(raw);
    if (!simp) {
      return null;
    }
    tokens.push(simp);
    i = j;
  }
  const parts = [];
  for (let k = 0; k < tokens.length; k++) {
    const t = tokens[k];
    if (typeof t !== "string") {
      let comb = void 0;
      let p = k - 1;
      while (p >= 0 && tokens[p] === " ") {
        comb = " ";
        p--;
        break;
      }
      if (p >= 0 && typeof tokens[p] === "string" && tokens[p] !== " ") comb = tokens[p];
      const part = { simple: t, combinatorToLeft: comb };
      parts.push(part);
    }
  }
  const result = parts.length ? parts : null;
  return result;
}

// src/css/selectors/simple-key.ts
function simpleKey(s) {
  const cls = s.classes.length ? "." + s.classes.slice().sort().join(".") : "";
  const attrs = s.attrs.length ? "[" + s.attrs.map((a) => a.op === "exists" ? a.name : `${a.name}${a.op}"${a.value}"`).sort().join("][") + "]" : "";
  const pseu = s.pseudos.length ? ":" + s.pseudos.map((p) => {
    switch (p.kind) {
      case "first-child":
        return "first-child";
      case "last-child":
        return "last-child";
      case "nth-child":
        return `nth-child(${p.a}n+${p.b})`;
      case "not": {
        const innerKey = simpleKey(p.inner);
        return `not(${innerKey})`;
      }
      default:
        return "";
    }
  }).filter((p) => p !== "").sort().join(":") : "";
  const tag = s.tag ?? "*";
  const id = s.id ? `#${s.id}` : "";
  const key2 = `${tag}${id}${cls}${attrs}${pseu}`;
  return key2;
}

// src/css/selectors/matcher.ts
function createSelectorMatcher(selector) {
  const chain = parseSelector2(selector);
  if (!chain) return null;
  const cache = /* @__PURE__ */ new WeakMap();
  function memo(el, s, raw) {
    let m = cache.get(el);
    if (!m) {
      m = /* @__PURE__ */ new Map();
      cache.set(el, m);
    }
    const k = simpleKey(s);
    if (m.has(k)) return m.get(k);
    const ok = raw(el, s);
    m.set(k, ok);
    return ok;
  }
  function getAttr(el, name) {
    const value = el.getAttribute ? el.getAttribute(name) : null;
    return value;
  }
  function matchAttr(el, cond) {
    const v = getAttr(el, cond.name);
    if (cond.op === "exists") {
      const result2 = v !== null;
      return result2;
    }
    if (v === null) {
      return false;
    }
    let result;
    switch (cond.op) {
      case "=":
        result = v === cond.value;
        break;
      case "~=":
        result = v.split(/\s+/).includes(cond.value);
        break;
      case "|=":
        result = v === cond.value || v.startsWith(cond.value + "-");
        break;
      case "^=":
        result = v.startsWith(cond.value);
        break;
      case "$=":
        result = v.endsWith(cond.value);
        break;
      case "*=":
        result = v.includes(cond.value);
        break;
      default:
        result = false;
        break;
    }
    return result;
  }
  function indexInParent(el) {
    const p = el.parentElement;
    if (!p) {
      return -1;
    }
    let idx = 0;
    for (let n = p.firstElementChild; n; n = n.nextElementSibling) {
      idx++;
      if (n === el) {
        return idx;
      }
    }
    return -1;
  }
  function matchesPseudo(el, p) {
    if (p.kind === "first-child") {
      const result = indexInParent(el) === 1;
      return result;
    }
    if (p.kind === "last-child") {
      const parent = el.parentElement;
      if (!parent) {
        return false;
      }
      const result = parent.lastElementChild === el;
      return result;
    }
    if (p.kind === "nth-child") {
      const k = indexInParent(el);
      if (k < 1) {
        return false;
      }
      const { a, b } = p;
      let result;
      if (a === 0) {
        result = k === b;
      } else {
        result = (k - b) % a === 0 && (k - b) / a >= 0;
      }
      return result;
    }
    if (p.kind === "not") {
      const result = !matchesSimple(el, p.inner);
      return result;
    }
    if (p.kind === "root") {
      const doc = el.ownerDocument;
      if (!doc || !doc.documentElement) {
        return false;
      }
      return doc.documentElement === el;
    }
    return false;
  }
  function matchesSimple(el, s) {
    if (s.tag && el.tagName.toLowerCase() !== s.tag) {
      return false;
    }
    if (s.id && el.id !== s.id) {
      return false;
    }
    const cl = el.classList;
    for (const cls of s.classes) {
      if (!cl?.contains?.(cls)) {
        return false;
      }
    }
    for (const a of s.attrs) {
      if (!matchAttr(el, a)) {
        return false;
      }
    }
    for (const z of s.pseudos) {
      if (!matchesPseudo(el, z)) {
        return false;
      }
    }
    return true;
  }
  return function match(el) {
    let current2 = el;
    let i = chain.length - 1;
    if (!current2) {
      return false;
    }
    if (!memo(current2, chain[i].simple, matchesSimple)) {
      return false;
    }
    i--;
    while (i >= 0) {
      const needed = chain[i];
      const comb = chain[i + 1].combinatorToLeft;
      if (comb === ">") {
        current2 = current2.parentElement;
        if (!current2) {
          return false;
        }
        if (!memo(current2, needed.simple, matchesSimple)) {
          return false;
        }
        i--;
        continue;
      }
      if (comb === " ") {
        let anc = current2.parentElement, found = false;
        while (anc) {
          if (memo(anc, needed.simple, matchesSimple)) {
            current2 = anc;
            found = true;
            break;
          }
          anc = anc.parentElement;
        }
        if (!found) {
          return false;
        }
        i--;
        continue;
      }
      if (comb === "+") {
        const sib = current2.previousElementSibling;
        if (!sib) {
          return false;
        }
        if (!memo(sib, needed.simple, matchesSimple)) {
          return false;
        }
        current2 = sib;
        i--;
        continue;
      }
      if (comb === "~") {
        let sib = current2.previousElementSibling, found = false;
        while (sib) {
          if (memo(sib, needed.simple, matchesSimple)) {
            current2 = sib;
            found = true;
            break;
          }
          sib = sib.previousElementSibling;
        }
        if (!found) {
          return false;
        }
        i--;
        continue;
      }
      if (!memo(current2, needed.simple, matchesSimple)) {
        return false;
      }
      i--;
    }
    return true;
  };
}

// src/html/css/parse-css.ts
function buildCssRules(cssText) {
  const result = { styleRules: [], fontFaceRules: [] };
  if (!cssText.trim()) {
    return result;
  }
  const stylesheet = cssParser.parse(cssText);
  const rules = stylesheet.stylesheet?.rules ?? [];
  for (const rule of rules) {
    if (rule.type === "rule") {
      const typedRule = rule;
      const selectors = typedRule.selectors ?? [];
      const decls = typedRule.declarations ?? [];
      const declarations = {};
      for (const decl of decls) {
        if (decl.type !== "declaration") continue;
        const declaration = decl;
        if (!declaration.property || declaration.value === void 0) {
          continue;
        }
        const prop2 = declaration.property.trim();
        if (prop2.startsWith("--")) {
          declarations[prop2] = declaration.value.trim();
        } else {
          declarations[prop2.toLowerCase()] = declaration.value.trim();
        }
      }
      for (const selector of selectors) {
        const matcher = createSelectorMatcher(selector.trim());
        if (!matcher) {
          console.warn(`Invalid CSS selector: ${selector.trim()}`);
          continue;
        }
        result.styleRules.push({ selector, declarations: { ...declarations }, match: matcher });
      }
    } else if (rule.type === "font-face") {
      const typedRule = rule;
      const decls = typedRule.declarations ?? [];
      const declarations = {};
      for (const decl of decls) {
        if (decl.type !== "declaration") continue;
        const declaration = decl;
        if (!declaration.property || declaration.value === void 0) {
          continue;
        }
        const prop2 = declaration.property.trim();
        if (prop2.startsWith("--")) {
          declarations[prop2] = declaration.value.trim();
        } else {
          declarations[prop2.toLowerCase()] = declaration.value.trim();
        }
      }
      result.fontFaceRules.push({ declarations });
    }
  }
  return result;
}
function parseCss(cssText) {
  return buildCssRules(cssText);
}

// src/css/viewport.ts
var CURRENT_VIEWPORT_WIDTH_PX = 0;
var CURRENT_VIEWPORT_HEIGHT_PX = 0;
function setViewportSize(width, height) {
  CURRENT_VIEWPORT_WIDTH_PX = Number.isFinite(width) && width > 0 ? width : 0;
  CURRENT_VIEWPORT_HEIGHT_PX = Number.isFinite(height) && height > 0 ? height : 0;
}
function getViewportWidth() {
  return CURRENT_VIEWPORT_WIDTH_PX;
}
function getViewportHeight() {
  return CURRENT_VIEWPORT_HEIGHT_PX;
}

// src/css/length.ts
var AUTO_LENGTH = { kind: "auto" };
function percent(ratio) {
  return { kind: "absolute", unit: "percent", value: ratio };
}
function relativeLength(unit, value) {
  return { kind: "relative", unit, value };
}
function isRelativeLength(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  return value.kind === "relative";
}
function resolveRelativeLength(value, fontSize, rootFontSize) {
  return value.unit === "em" ? value.value * fontSize : value.value * rootFontSize;
}
function resolveNumberLike(value, fontSize, rootFontSize) {
  if (value === void 0) {
    return void 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return resolveRelativeLength(value, fontSize, rootFontSize);
}
function resolveLengthInput(value, fontSize, rootFontSize) {
  if (value === void 0) {
    return void 0;
  }
  if (isRelativeLength(value)) {
    return resolveRelativeLength(value, fontSize, rootFontSize);
  }
  return value;
}
function isAutoLength(value) {
  if (typeof value === "string") {
    return value === "auto";
  }
  if (typeof value === "number") {
    return false;
  }
  return value.kind === "auto";
}
function resolveLength(value, reference, options = { auto: "reference" }) {
  const autoBehavior = options.auto ?? "reference";
  if (value === void 0) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  if (value === "auto") {
    return resolveAuto(autoBehavior, reference);
  }
  if (value.kind === "auto") {
    return resolveAuto(autoBehavior, reference);
  }
  if (value.unit === "percent") {
    return value.value * reference;
  }
  return value.value;
}
function clampMinMax(value, minValue, maxValue) {
  const upper = maxValue ?? Number.POSITIVE_INFINITY;
  const lower = minValue ?? Number.NEGATIVE_INFINITY;
  return Math.min(Math.max(value, lower), upper);
}
function resolveAuto(autoBehavior, reference) {
  if (autoBehavior === "reference") {
    return reference;
  }
  if (autoBehavior === "zero") {
    return 0;
  }
  return autoBehavior;
}

// src/css/parsers/length-parser.ts
var PERCENT_LENGTH_REGEX = /^(-?\d+(?:\.\d+)?)%$/;
function parseLength(value) {
  if (!value) {
    return void 0;
  }
  const normalized = value.trim().toLowerCase();
  if (!normalized || normalized === "auto") {
    return void 0;
  }
  const match = normalized.match(/^(-?\d+(?:\.\d+)?)(px|pt|vh|vw|em|rem|cm|mm|q|in|pc)?$/);
  if (!match) {
    return void 0;
  }
  const numeric = Number.parseFloat(match[1]);
  if (Number.isNaN(numeric)) {
    return void 0;
  }
  const unit = match[2] ?? "px";
  switch (unit) {
    case "px":
      return numeric;
    case "pt":
      return ptToPx(numeric);
    case "cm":
      return cmToPx(numeric);
    case "mm":
      return mmToPx(numeric);
    case "q":
      return qToPx(numeric);
    case "in":
      return inToPx(numeric);
    case "pc":
      return pcToPx(numeric);
    case "vh":
      return numeric / 100 * getViewportHeight();
    case "vw":
      return numeric / 100 * getViewportWidth();
    case "em":
    case "rem":
      return relativeLength(unit, numeric);
    default:
      return void 0;
  }
}
function parseNumeric(value) {
  const match = value.trim().match(/^(-?\d+(?:\.\d+)?)(px|pt|em|rem)?$/i);
  if (!match) {
    return void 0;
  }
  let n = Number.parseFloat(match[1]);
  const unit = (match[2] ?? "px").toLowerCase();
  if (unit === "pt") {
    n = ptToPx(n);
    return n;
  }
  if (unit === "em" || unit === "rem") {
    return relativeLength(unit, n);
  }
  return n;
}
function parseLengthOrPercent(value) {
  const parsed = parseLength(value);
  if (parsed !== void 0) {
    return parsed;
  }
  const match = PERCENT_LENGTH_REGEX.exec(value.trim());
  if (!match) {
    return void 0;
  }
  const numeric = Number.parseFloat(match[1]);
  if (Number.isNaN(numeric)) {
    return void 0;
  }
  return percent(numeric / 100);
}
function parseLengthOrAuto(value) {
  if (!value) {
    return void 0;
  }
  const normalized = value.trim().toLowerCase();
  if (normalized === "auto") {
    return "auto";
  }
  return parseLength(normalized);
}

// src/units/units.ts
var DPI = 96;
var INCHES_PER_CM = 1 / 2.54;
function cmToPx(cm) {
  return cm * INCHES_PER_CM * DPI;
}
function mmToPx(mm) {
  return mm / 10 * INCHES_PER_CM * DPI;
}
function qToPx(q) {
  return q / 40 * INCHES_PER_CM * DPI;
}
function inToPx(inches) {
  return inches * DPI;
}
function pcToPx(pc) {
  return pc * (DPI / 6);
}
function ptToPx(pt) {
  return pt * (DPI / 72);
}
function pxToPt(px) {
  return px * (72 / DPI);
}
function makeUnitParsers(ctx) {
  return {
    parseLength: (value) => parseLength(value),
    parseLengthOrPercent: (value) => parseLengthOrPercent(value)
  };
}

// src/css/line-height.ts
var DEFAULT_NORMAL_LINE_HEIGHT = 1.2;
function createNormalLineHeight() {
  return { kind: "normal" };
}
function createUnitlessLineHeight(value) {
  return { kind: "unitless", value };
}
function createLengthLineHeight(value) {
  return { kind: "length", value };
}
function cloneLineHeight(value) {
  switch (value.kind) {
    case "normal":
      return createNormalLineHeight();
    case "unitless":
      return createUnitlessLineHeight(value.value);
    case "length":
      return createLengthLineHeight(value.value);
    default:
      return createNormalLineHeight();
  }
}
function resolveLineHeightInput(input, fontSize, rootFontSize) {
  switch (input.kind) {
    case "normal":
      return createNormalLineHeight();
    case "unitless":
      return createUnitlessLineHeight(input.value);
    case "length": {
      const raw = input.value;
      const pxValue = typeof raw === "number" ? raw : resolveRelativeLength(raw, fontSize, rootFontSize);
      return createLengthLineHeight(pxValue);
    }
    default:
      return createNormalLineHeight();
  }
}
function lineHeightEquals(a, b) {
  if (a.kind !== b.kind) {
    return false;
  }
  if (a.kind === "unitless" || a.kind === "length") {
    return a.value === b.value;
  }
  return true;
}
function lineHeightToPx(value, fontSize, normalRatio = DEFAULT_NORMAL_LINE_HEIGHT) {
  const size = fontSize ?? 16;
  if (!value) {
    return size * normalRatio;
  }
  switch (value.kind) {
    case "normal":
      return size * normalRatio;
    case "unitless":
      return value.value * size;
    case "length":
      return value.value;
    default:
      return size * normalRatio;
  }
}

// src/css/unit-conversion.ts
function remToPx(remValue, baseFontSize) {
  return remValue * baseFontSize;
}
function emToPx(emValue, currentFontSize) {
  return emValue * currentFontSize;
}

// src/css/ua-defaults/base-defaults.ts
var TypographyDefaults = class {
  static getFontFamily() {
    return "'Times New Roman', Times, serif";
  }
  static getFontSize() {
    return 1;
  }
  static getBaseFontSize() {
    return 16;
  }
  static getLineHeight() {
    return DEFAULT_NORMAL_LINE_HEIGHT;
  }
  static getColor() {
    return "#000000";
  }
  static getLetterSpacing() {
    return 0;
  }
  static getWordSpacing() {
    return 0;
  }
  static getFontWeight() {
    return 400;
  }
};
var BoxModelDefaults = class {
  static getMargin() {
    return 0;
  }
  static getPadding() {
    return 0;
  }
  static getBorder() {
    return 0;
  }
  static getWidth() {
    return "auto";
  }
  static getHeight() {
    return "auto";
  }
  static getMinWidth() {
    return void 0;
  }
  static getMaxWidth() {
    return void 0;
  }
  static getMinHeight() {
    return void 0;
  }
  static getMaxHeight() {
    return void 0;
  }
};
var LayoutDefaults = class {
  static getDisplay() {
    return "block" /* Block */;
  }
  static getPosition() {
    return "static" /* Static */;
  }
  static getFloat() {
    return "none";
  }
  static getClear() {
    return "none" /* None */;
  }
  static getOverflowX() {
    return "visible" /* Visible */;
  }
  static getOverflowY() {
    return "visible" /* Visible */;
  }
};
var TextLayoutDefaults = class {
  static getWhiteSpace() {
    return "normal" /* Normal */;
  }
  static getOverflowWrap() {
    return "normal";
  }
  static getTextWrap() {
    return "wrap" /* Wrap */;
  }
  static getWritingMode() {
    return "horizontal-tb" /* HorizontalTb */;
  }
  static getTextAlign() {
    return "start";
  }
  static getVerticalAlign() {
    return "baseline";
  }
  static getTextIndent() {
    return 0;
  }
  static getTextTransform() {
    return "none";
  }
};
function createBaseDefaultsObject() {
  const baseFontSize = TypographyDefaults.getBaseFontSize();
  return {
    // Typography
    fontFamily: TypographyDefaults.getFontFamily(),
    fontSize: remToPx(TypographyDefaults.getFontSize(), baseFontSize),
    fontStyle: "normal",
    fontWeight: TypographyDefaults.getFontWeight(),
    lineHeight: createNormalLineHeight(),
    color: TypographyDefaults.getColor(),
    borderColor: TypographyDefaults.getColor(),
    letterSpacing: TypographyDefaults.getLetterSpacing(),
    wordSpacing: TypographyDefaults.getWordSpacing(),
    textDecorationLine: "none",
    textDecorationColor: "currentcolor",
    textDecorationStyle: "solid",
    listStyleType: "disc",
    // Box model
    marginTop: emToPx(BoxModelDefaults.getMargin(), remToPx(TypographyDefaults.getFontSize(), baseFontSize)),
    marginRight: emToPx(BoxModelDefaults.getMargin(), remToPx(TypographyDefaults.getFontSize(), baseFontSize)),
    marginBottom: emToPx(BoxModelDefaults.getMargin(), remToPx(TypographyDefaults.getFontSize(), baseFontSize)),
    marginLeft: emToPx(BoxModelDefaults.getMargin(), remToPx(TypographyDefaults.getFontSize(), baseFontSize)),
    paddingTop: BoxModelDefaults.getPadding(),
    paddingRight: BoxModelDefaults.getPadding(),
    paddingBottom: BoxModelDefaults.getPadding(),
    paddingLeft: BoxModelDefaults.getPadding(),
    borderTop: BoxModelDefaults.getBorder(),
    borderRight: BoxModelDefaults.getBorder(),
    borderBottom: BoxModelDefaults.getBorder(),
    borderLeft: BoxModelDefaults.getBorder(),
    borderTopLeftRadiusX: 0,
    borderTopLeftRadiusY: 0,
    borderTopRightRadiusX: 0,
    borderTopRightRadiusY: 0,
    borderBottomRightRadiusX: 0,
    borderBottomRightRadiusY: 0,
    borderBottomLeftRadiusX: 0,
    borderBottomLeftRadiusY: 0,
    boxShadows: [],
    width: BoxModelDefaults.getWidth(),
    height: BoxModelDefaults.getHeight(),
    minWidth: BoxModelDefaults.getMinWidth(),
    maxWidth: BoxModelDefaults.getMaxWidth(),
    minHeight: BoxModelDefaults.getMinHeight(),
    maxHeight: BoxModelDefaults.getMaxHeight(),
    // Layout
    display: LayoutDefaults.getDisplay(),
    position: LayoutDefaults.getPosition(),
    float: "none",
    clear: LayoutDefaults.getClear(),
    overflowX: LayoutDefaults.getOverflowX(),
    overflowY: LayoutDefaults.getOverflowY(),
    // Text layout
    whiteSpace: TextLayoutDefaults.getWhiteSpace(),
    overflowWrap: TextLayoutDefaults.getOverflowWrap(),
    textWrap: TextLayoutDefaults.getTextWrap(),
    writingMode: TextLayoutDefaults.getWritingMode(),
    textAlign: TextLayoutDefaults.getTextAlign(),
    verticalAlign: TextLayoutDefaults.getVerticalAlign(),
    textIndent: TextLayoutDefaults.getTextIndent(),
    textTransform: TextLayoutDefaults.getTextTransform(),
    // Flexbox (defaults)
    flexGrow: 0,
    flexShrink: 1,
    flexBasis: AUTO_LENGTH,
    alignItems: "stretch" /* Stretch */,
    alignSelf: "auto",
    justifyContent: "flex-start" /* FlexStart */,
    alignContent: "stretch" /* Stretch */,
    flexDirection: "row",
    flexWrap: false,
    // Grid (defaults)
    trackListColumns: [],
    trackListRows: [],
    autoFlow: "row",
    rowGap: 0,
    columnGap: 0,
    // Table (defaults)
    tableLayout: "auto" /* Auto */,
    borderModel: "separate" /* Separate */,
    // Fragmentation (defaults)
    breakBefore: "auto",
    breakAfter: "auto",
    breakInside: "auto",
    widows: 2,
    orphans: 2,
    // Opacity
    opacity: 1
  };
}

// src/css/ua-defaults/element-defaults.ts
var ElementSpecificDefaultsImpl = class {
  constructor() {
    this.elementDefaults = {
      // Root element
      html: {
        display: "block" /* Block */,
        fontSize: 16,
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      // Body element
      body: {
        display: "block" /* Block */,
        margin: 8,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      // Headings
      h1: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 0.67),
        marginBottom: relativeLength("em", 0.67),
        marginLeft: 0,
        marginRight: 0,
        fontSize: relativeLength("em", 2),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        fontWeight: 700,
        color: TypographyDefaults.getColor()
      },
      h2: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 0.83),
        marginBottom: relativeLength("em", 0.83),
        marginLeft: 0,
        marginRight: 0,
        fontSize: relativeLength("em", 1.5),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        fontWeight: 700,
        color: TypographyDefaults.getColor()
      },
      h3: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 1),
        marginBottom: relativeLength("em", 1),
        marginLeft: 0,
        marginRight: 0,
        fontSize: relativeLength("em", 1.17),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        fontWeight: 700,
        color: TypographyDefaults.getColor()
      },
      h4: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 1.33),
        marginBottom: relativeLength("em", 1.33),
        marginLeft: 0,
        marginRight: 0,
        fontSize: relativeLength("em", 1),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        fontWeight: 700,
        color: TypographyDefaults.getColor()
      },
      h5: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 1.67),
        marginBottom: relativeLength("em", 1.67),
        marginLeft: 0,
        marginRight: 0,
        fontSize: relativeLength("em", 0.83),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        fontWeight: 700,
        color: TypographyDefaults.getColor()
      },
      h6: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 2.33),
        marginBottom: relativeLength("em", 2.33),
        marginLeft: 0,
        marginRight: 0,
        fontSize: relativeLength("em", 0.67),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        fontWeight: 700,
        color: TypographyDefaults.getColor()
      },
      // Paragraphs
      p: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 1),
        marginRight: 0,
        marginBottom: relativeLength("em", 1),
        marginLeft: 0,
        fontSize: relativeLength("em", 1),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      // Lists
      ul: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 1),
        marginBottom: relativeLength("em", 1),
        paddingLeft: 40,
        // px
        listStyleType: "disc",
        fontSize: relativeLength("em", 1),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      ol: {
        display: "block" /* Block */,
        marginTop: relativeLength("em", 1),
        marginBottom: relativeLength("em", 1),
        paddingLeft: 40,
        // px
        listStyleType: "decimal",
        fontSize: relativeLength("em", 1),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      li: {
        display: "block" /* Block */,
        fontSize: relativeLength("em", 1),
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      // Links
      a: {
        display: "inline" /* Inline */,
        color: "#0000EE",
        textAlign: "start",
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily()
      },
      // Text formatting
      strong: {
        display: "inline" /* Inline */,
        fontSize: 16,
        fontWeight: 700,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      em: {
        display: "inline" /* Inline */,
        fontSize: 16,
        fontStyle: "italic",
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      b: {
        display: "inline" /* Inline */,
        fontSize: 16,
        fontWeight: 700,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      i: {
        display: "inline" /* Inline */,
        fontSize: 16,
        fontStyle: "italic",
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      s: {
        display: "inline" /* Inline */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor(),
        textDecorationLine: "line-through"
      },
      del: {
        display: "inline" /* Inline */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor(),
        textDecorationLine: "line-through"
      },
      u: {
        display: "inline" /* Inline */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor(),
        textDecorationLine: "underline"
      },
      strike: {
        display: "inline" /* Inline */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor(),
        textDecorationLine: "line-through"
      },
      code: {
        display: "inline" /* Inline */,
        fontSize: 14,
        lineHeight: createNormalLineHeight(),
        fontFamily: "Monaco, 'Courier New', monospace",
        color: TypographyDefaults.getColor()
      },
      // Tables
      table: {
        display: "table" /* Table */,
        borderCollapse: "separate",
        borderSpacing: 2,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      thead: {
        display: "table-header-group" /* TableHeaderGroup */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      tbody: {
        display: "table-row-group" /* TableRowGroup */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      tfoot: {
        display: "table-footer-group" /* TableFooterGroup */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      tr: {
        display: "table-row" /* TableRow */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      th: {
        display: "table-cell" /* TableCell */,
        padding: 8,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor(),
        fontWeight: 700,
        textAlign: "center",
        verticalAlign: "middle"
      },
      td: {
        display: "table-cell" /* TableCell */,
        padding: 8,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor(),
        verticalAlign: "middle"
      },
      // Form elements
      input: {
        display: "inline-block" /* InlineBlock */,
        padding: 2,
        border: 1,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      button: {
        display: "inline-block" /* InlineBlock */,
        padding: 2,
        border: 1,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      textarea: {
        display: "inline-block" /* InlineBlock */,
        padding: 2,
        border: 1,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      // Divs and containers
      div: {
        display: "block" /* Block */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      span: {
        display: "inline" /* Inline */,
        fontSize: 16,
        lineHeight: createNormalLineHeight(),
        fontFamily: TypographyDefaults.getFontFamily(),
        color: TypographyDefaults.getColor()
      },
      // Images
      img: {
        display: "inline-block" /* InlineBlock */,
        border: 0
      },
      // Breaks
      br: {
        display: "inline" /* Inline */
      }
    };
  }
  getDefaultsForElement(tagName19) {
    const normalizedTag = tagName19.toLowerCase();
    return this.elementDefaults[normalizedTag] || {};
  }
  getAllDefaults() {
    return { ...this.elementDefaults };
  }
};
var instance = new ElementSpecificDefaultsImpl();
var ElementSpecificDefaults = class {
  static getDefaultsForElement(tagName19) {
    return instance.getDefaultsForElement(tagName19);
  }
  static getAllDefaults() {
    return instance.getAllDefaults();
  }
};

// src/css/ua-defaults/browser-defaults.ts
var BrowserDefaults = class {
  static createBaseDefaults() {
    return createBaseDefaultsObject();
  }
  static mergeElementDefaults(baseDefaults, elementDefaults) {
    const merged = { ...baseDefaults };
    if (elementDefaults.fontSize !== void 0) {
      merged.fontSize = elementDefaults.fontSize;
    }
    if (elementDefaults.fontStyle !== void 0) {
      merged.fontStyle = elementDefaults.fontStyle;
    }
    if (elementDefaults.lineHeight !== void 0) {
      merged.lineHeight = cloneLineHeight(elementDefaults.lineHeight);
    }
    if (elementDefaults.fontFamily !== void 0) {
      merged.fontFamily = elementDefaults.fontFamily;
    }
    if (elementDefaults.fontWeight !== void 0) {
      merged.fontWeight = elementDefaults.fontWeight;
    }
    if (elementDefaults.color !== void 0) {
      merged.color = elementDefaults.color;
    }
    if (elementDefaults.borderColor !== void 0) {
      merged.borderColor = elementDefaults.borderColor;
    }
    if (elementDefaults.margin !== void 0) {
      merged.marginTop = elementDefaults.margin;
      merged.marginRight = elementDefaults.margin;
      merged.marginBottom = elementDefaults.margin;
      merged.marginLeft = elementDefaults.margin;
    }
    if (elementDefaults.marginTop !== void 0) {
      merged.marginTop = elementDefaults.marginTop;
    }
    if (elementDefaults.marginRight !== void 0) {
      merged.marginRight = elementDefaults.marginRight;
    }
    if (elementDefaults.marginBottom !== void 0) {
      merged.marginBottom = elementDefaults.marginBottom;
    }
    if (elementDefaults.marginLeft !== void 0) {
      merged.marginLeft = elementDefaults.marginLeft;
    }
    if (elementDefaults.padding !== void 0) {
      merged.paddingTop = elementDefaults.padding;
      merged.paddingRight = elementDefaults.padding;
      merged.paddingBottom = elementDefaults.padding;
      merged.paddingLeft = elementDefaults.padding;
    }
    if (elementDefaults.paddingTop !== void 0) {
      merged.paddingTop = elementDefaults.paddingTop;
    }
    if (elementDefaults.paddingRight !== void 0) {
      merged.paddingRight = elementDefaults.paddingRight;
    }
    if (elementDefaults.paddingBottom !== void 0) {
      merged.paddingBottom = elementDefaults.paddingBottom;
    }
    if (elementDefaults.paddingLeft !== void 0) {
      merged.paddingLeft = elementDefaults.paddingLeft;
    }
    if (elementDefaults.border !== void 0) {
      merged.borderTop = elementDefaults.border;
      merged.borderRight = elementDefaults.border;
      merged.borderBottom = elementDefaults.border;
      merged.borderLeft = elementDefaults.border;
    }
    if (elementDefaults.borderTop !== void 0) {
      merged.borderTop = elementDefaults.borderTop;
    }
    if (elementDefaults.borderRight !== void 0) {
      merged.borderRight = elementDefaults.borderRight;
    }
    if (elementDefaults.borderBottom !== void 0) {
      merged.borderBottom = elementDefaults.borderBottom;
    }
    if (elementDefaults.borderLeft !== void 0) {
      merged.borderLeft = elementDefaults.borderLeft;
    }
    if (elementDefaults.display !== void 0) {
      merged.display = elementDefaults.display;
    }
    if (elementDefaults.objectFit !== void 0) {
      merged.objectFit = elementDefaults.objectFit;
    }
    if (elementDefaults.textAlign !== void 0) {
      merged.textAlign = elementDefaults.textAlign;
    }
    if (elementDefaults.textIndent !== void 0) {
      merged.textIndent = elementDefaults.textIndent;
    }
    if (elementDefaults.verticalAlign !== void 0) {
      merged.verticalAlign = elementDefaults.verticalAlign;
    }
    if (elementDefaults.listStyleType !== void 0) {
      merged.listStyleType = elementDefaults.listStyleType;
    }
    if (elementDefaults.textDecorationLine !== void 0) {
      merged.textDecorationLine = elementDefaults.textDecorationLine;
    }
    if (elementDefaults.overflowWrap !== void 0) {
      merged.overflowWrap = elementDefaults.overflowWrap;
    }
    if (elementDefaults.textTransform !== void 0) {
      merged.textTransform = elementDefaults.textTransform;
    }
    if (elementDefaults.borderCollapse !== void 0) {
      merged.borderCollapse = elementDefaults.borderCollapse;
    }
    if (elementDefaults.borderSpacing !== void 0) {
      merged.borderSpacing = elementDefaults.borderSpacing;
    }
    return merged;
  }
};

// src/css/custom-properties.ts
var CustomPropertiesMap = class _CustomPropertiesMap {
  constructor() {
    this.properties = /* @__PURE__ */ new Map();
  }
  /**
   * Set a custom property value
   */
  set(name, value) {
    if (!name.startsWith("--")) {
      return;
    }
    this.properties.set(name, value.trim());
  }
  /**
   * Get a custom property value
   */
  get(name) {
    return this.properties.get(name);
  }
  /**
   * Check if a custom property exists
   */
  has(name) {
    return this.properties.has(name);
  }
  /**
   * Clone the custom properties map
   */
  clone() {
    const cloned = new _CustomPropertiesMap();
    this.properties.forEach((value, key2) => {
      cloned.set(key2, value);
    });
    return cloned;
  }
  /**
   * Inherit properties from a parent map
   * Child properties override parent properties
   */
  inherit(parent) {
    if (!parent) {
      return this.clone();
    }
    const inherited = parent.clone();
    this.properties.forEach((value, key2) => {
      inherited.set(key2, value);
    });
    return inherited;
  }
  /**
   * Get all property names
   */
  keys() {
    return Array.from(this.properties.keys());
  }
  /**
   * Get the number of properties
   */
  get size() {
    return this.properties.size;
  }
};
var VAR_FUNCTION_REGEX = /var\s*\(\s*(--[a-zA-Z0-9_-]+)\s*(?:,\s*([^)]+))?\s*\)/g;
function containsVariableReference(value) {
  return value.includes("var(");
}
function resolveVariableReferences(value, customProperties, maxDepth = 10) {
  if (!containsVariableReference(value)) {
    return value;
  }
  if (maxDepth <= 0) {
    console.warn("CSS variable resolution depth limit reached");
    return value;
  }
  let resolved = value;
  const matches2 = value.matchAll(VAR_FUNCTION_REGEX);
  for (const match of matches2) {
    const fullMatch = match[0];
    const varName = match[1];
    const fallback = match[2]?.trim();
    let replacement = customProperties.get(varName);
    if (replacement === void 0) {
      if (fallback !== void 0) {
        replacement = fallback;
      } else {
        console.warn(`CSS variable ${varName} not found and no fallback provided`);
        continue;
      }
    }
    resolved = resolved.replace(fullMatch, replacement);
  }
  if (containsVariableReference(resolved)) {
    resolved = resolveVariableReferences(resolved, customProperties, maxDepth - 1);
  }
  return resolved.trim();
}
function extractCustomProperties(declarations) {
  const customProps = new CustomPropertiesMap();
  for (const [property, value] of Object.entries(declarations)) {
    if (property.startsWith("--")) {
      customProps.set(property, value);
    }
  }
  return customProps;
}
function resolveDeclarationsWithVariables(declarations, customProperties) {
  const resolved = {};
  for (const [property, value] of Object.entries(declarations)) {
    if (property.startsWith("--")) {
      resolved[property] = value;
    } else {
      resolved[property] = resolveVariableReferences(value, customProperties);
    }
  }
  return resolved;
}

// src/css/style.ts
var defaultStyle = BrowserDefaults.createBaseDefaults();
var ComputedStyle = class {
  constructor(init) {
    const data = {
      ...defaultStyle,
      ...init,
      flexBasis: init?.flexBasis ?? defaultStyle.flexBasis,
      trackListColumns: [...init?.trackListColumns ?? defaultStyle.trackListColumns],
      trackListRows: [...init?.trackListRows ?? defaultStyle.trackListRows],
      backgroundLayers: init?.backgroundLayers ? [...init.backgroundLayers] : [],
      textShadows: init?.textShadows ? [...init.textShadows] : []
    };
    this.display = data.display;
    this.position = data.position;
    this.zIndex = data.zIndex;
    this.float = data.float;
    this.clear = data.clear;
    this.overflowX = data.overflowX;
    this.overflowY = data.overflowY;
    this.whiteSpace = data.whiteSpace;
    this.overflowWrap = data.overflowWrap;
    this.textWrap = data.textWrap;
    this.writingMode = data.writingMode;
    this.width = data.width;
    this.height = data.height;
    this.minWidth = data.minWidth;
    this.maxWidth = data.maxWidth;
    this.minHeight = data.minHeight;
    this.maxHeight = data.maxHeight;
    this.marginTop = data.marginTop;
    this.marginRight = data.marginRight;
    this.marginBottom = data.marginBottom;
    this.marginLeft = data.marginLeft;
    this.paddingTop = data.paddingTop;
    this.paddingRight = data.paddingRight;
    this.paddingBottom = data.paddingBottom;
    this.paddingLeft = data.paddingLeft;
    this.borderTop = data.borderTop;
    this.borderRight = data.borderRight;
    this.borderBottom = data.borderBottom;
    this.borderLeft = data.borderLeft;
    this.borderTopLeftRadiusX = data.borderTopLeftRadiusX;
    this.borderTopLeftRadiusY = data.borderTopLeftRadiusY;
    this.borderTopRightRadiusX = data.borderTopRightRadiusX;
    this.borderTopRightRadiusY = data.borderTopRightRadiusY;
    this.borderBottomRightRadiusX = data.borderBottomRightRadiusX;
    this.borderBottomRightRadiusY = data.borderBottomRightRadiusY;
    this.borderBottomLeftRadiusX = data.borderBottomLeftRadiusX;
    this.borderBottomLeftRadiusY = data.borderBottomLeftRadiusY;
    this.borderStyleTop = data.borderStyleTop;
    this.borderStyleRight = data.borderStyleRight;
    this.borderStyleBottom = data.borderStyleBottom;
    this.borderStyleLeft = data.borderStyleLeft;
    this.backgroundLayers = data.backgroundLayers;
    this.borderColor = data.borderColor;
    this.boxShadows = [...data.boxShadows];
    this.textShadows = [...data.textShadows];
    this.color = data.color;
    this.fontFamily = data.fontFamily;
    this.fontWeight = data.fontWeight;
    this.fontStyle = data.fontStyle;
    this.fontVariant = data.fontVariant;
    this.clipPath = data.clipPath;
    this.objectFit = data.objectFit;
    this.zIndex = data.zIndex;
    this.left = data.left;
    this.right = data.right;
    this.top = data.top;
    this.bottom = data.bottom;
    this.insetInlineStart = data.insetInlineStart;
    this.insetInlineEnd = data.insetInlineEnd;
    this.insetBlockStart = data.insetBlockStart;
    this.insetBlockEnd = data.insetBlockEnd;
    this.fontSize = data.fontSize;
    this.lineHeight = cloneLineHeight(data.lineHeight);
    this.letterSpacing = data.letterSpacing;
    this.wordSpacing = data.wordSpacing;
    this.flexGrow = data.flexGrow;
    this.flexShrink = data.flexShrink;
    this.flexBasis = data.flexBasis;
    this.listStyleType = data.listStyleType;
    this.alignItems = data.alignItems;
    this.alignSelf = data.alignSelf;
    this.justifyContent = data.justifyContent;
    this.alignContent = data.alignContent;
    this.flexDirection = data.flexDirection;
    this.flexWrap = data.flexWrap;
    this.trackListColumns = data.trackListColumns;
    this.trackListRows = data.trackListRows;
    this.autoFlow = data.autoFlow;
    this.rowGap = data.rowGap;
    this.columnGap = data.columnGap;
    this.tableLayout = data.tableLayout;
    this.borderModel = data.borderModel;
    this.breakBefore = data.breakBefore;
    this.breakAfter = data.breakAfter;
    this.breakInside = data.breakInside;
    this.widows = data.widows;
    this.orphans = data.orphans;
    this.textIndent = data.textIndent;
    this.textTransform = data.textTransform;
    this.transform = init?.transform ?? void 0;
    this.textAlign = init?.textAlign ?? void 0;
    this.verticalAlign = init?.verticalAlign ?? void 0;
    this.textDecorationLine = init?.textDecorationLine ?? defaultStyle.textDecorationLine;
    this.textDecorationColor = init?.textDecorationColor ?? defaultStyle.textDecorationColor;
    this.textDecorationStyle = init?.textDecorationStyle ?? defaultStyle.textDecorationStyle;
    this.opacity = data.opacity;
    this.customProperties = init?.customProperties ?? new CustomPropertiesMap();
  }
  get backgroundColor() {
    if (!this.backgroundLayers) return void 0;
    for (let i = this.backgroundLayers.length - 1; i >= 0; i--) {
      const layer = this.backgroundLayers[i];
      if (layer.kind === "color") {
        return layer.color;
      }
    }
    return void 0;
  }
};
function resolvedLineHeight(style) {
  return lineHeightToPx(style?.lineHeight, style?.fontSize);
}

// src/geometry/box.ts
var Box = class _Box {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.scrollWidth = 0;
    this.scrollHeight = 0;
    this.borderBoxWidth = 0;
    this.borderBoxHeight = 0;
    this.marginBoxWidth = 0;
    this.marginBoxHeight = 0;
    this.baseline = 0;
  }
  clone() {
    const box = new _Box();
    box.x = this.x;
    box.y = this.y;
    box.contentWidth = this.contentWidth;
    box.contentHeight = this.contentHeight;
    box.scrollWidth = this.scrollWidth;
    box.scrollHeight = this.scrollHeight;
    box.borderBoxWidth = this.borderBoxWidth;
    box.borderBoxHeight = this.borderBoxHeight;
    box.marginBoxWidth = this.marginBoxWidth;
    box.marginBoxHeight = this.marginBoxHeight;
    box.baseline = this.baseline;
    box.usedMarginLeft = this.usedMarginLeft;
    box.usedMarginRight = this.usedMarginRight;
    return box;
  }
};

// src/dom/node.ts
var LayoutNode = class {
  constructor(style, children = [], options) {
    this.style = style;
    this.box = new Box();
    this.parent = null;
    this.childrenInternal = [];
    this.establishesBFC = false;
    this.establishesIFC = false;
    this.establishesFFC = false;
    this.establishesGFC = false;
    this.establishesTFC = false;
    this.intrinsicInlineSize = options?.intrinsicInlineSize;
    this.intrinsicBlockSize = options?.intrinsicBlockSize;
    this.textContent = options?.textContent;
    this.tagName = options?.tagName;
    this.lineBoxes = options?.lineBoxes;
    this.inlineRuns = options?.inlineRuns;
    this.customData = options?.customData;
    this.tableColSpan = options?.tableColSpan;
    this.tableRowSpan = options?.tableRowSpan;
    this.tableCellOrigin = options?.tableCellOrigin;
    for (const child of children) {
      this.appendChild(child);
    }
  }
  get children() {
    return this.childrenInternal;
  }
  appendChild(child) {
    child.parent = this;
    this.childrenInternal.push(child);
    return this;
  }
  removeChild(child) {
    const idx = this.childrenInternal.indexOf(child);
    if (idx >= 0) {
      this.childrenInternal.splice(idx, 1);
      child.parent = null;
    }
  }
  nearestAncestor(predicate) {
    let current2 = this.parent;
    while (current2) {
      if (predicate(current2)) {
        return current2;
      }
      current2 = current2.parent;
    }
    return null;
  }
  walk(visitor, includeSelf = true) {
    if (includeSelf) {
      visitor(this);
    }
    for (const child of this.childrenInternal) {
      child.walk(visitor, true);
    }
  }
  postOrder(visitor) {
    for (const child of this.childrenInternal) {
      child.postOrder(visitor);
    }
    visitor(this);
  }
  shift(dx, dy) {
    this.box.x += dx;
    this.box.y += dy;
    this.box.baseline += dy;
    if (this.inlineRuns) {
      for (const run of this.inlineRuns) {
        run.startX += dx;
        run.baseline += dy;
      }
    }
    for (const child of this.childrenInternal) {
      child.shift(dx, dy);
    }
  }
};

// src/layout/context/layout-environment.ts
var LayoutEnvironment = class {
  constructor(options) {
    this.options = options;
    this.envAccessor = options.getEnv ?? (() => void 0);
  }
  get viewport() {
    return this.options.viewport;
  }
  get fontEmbedder() {
    return this.options.fontEmbedder;
  }
  getEnv(name) {
    return this.envAccessor(name);
  }
};

// src/layout/pipeline/context-factory.ts
var DefaultLayoutContextFactory = class {
  create(env, dispatcher) {
    return {
      env,
      layoutChild: dispatcher
    };
  }
};

// src/css/font-weight.ts
var FONT_WEIGHT_STEPS = [100, 200, 300, 400, 500, 600, 700, 800, 900];
function normalizeFontWeight(weight) {
  if (!Number.isFinite(weight ?? NaN)) {
    return 400;
  }
  const clamped = Math.min(900, Math.max(100, weight));
  let nearest = 400;
  let smallestDiff = Math.abs(nearest - clamped);
  for (const step of FONT_WEIGHT_STEPS) {
    const diff = Math.abs(step - clamped);
    if (diff < smallestDiff) {
      smallestDiff = diff;
      nearest = step;
    }
  }
  return nearest;
}
function stepFontWeight(weight, direction) {
  const normalized = normalizeFontWeight(weight);
  const index = FONT_WEIGHT_STEPS.indexOf(normalized);
  if (index === -1) {
    return normalized;
  }
  if (direction === "bolder") {
    return FONT_WEIGHT_STEPS[Math.min(FONT_WEIGHT_STEPS.length - 1, index + 1)];
  }
  return FONT_WEIGHT_STEPS[Math.max(0, index - 1)];
}
function parseFontWeightValue(value, inherited) {
  const token = value.trim().toLowerCase();
  switch (token) {
    case "normal":
      return 400;
    case "bold":
      return 700;
    case "bolder":
      return stepFontWeight(inherited, "bolder");
    case "lighter":
      return stepFontWeight(inherited, "lighter");
    case "inherit":
      return inherited !== void 0 ? normalizeFontWeight(inherited) : void 0;
    case "initial":
      return 400;
    default: {
      const numeric = Number.parseFloat(token);
      if (Number.isFinite(numeric)) {
        return normalizeFontWeight(numeric);
      }
      return void 0;
    }
  }
}
function fontWeightCacheKey(weight) {
  return normalizeFontWeight(weight).toString();
}
function isBoldFontWeight(weight) {
  return normalizeFontWeight(weight) >= 600;
}

// src/pdf/font/base14/widths-times-roman.ts
var TIMES_ROMAN_WIDTHS = {
  "32": 250,
  "33": 333,
  "34": 408,
  "35": 500,
  "36": 500,
  "37": 833,
  "38": 778,
  "39": 333,
  "40": 333,
  "41": 333,
  "42": 500,
  "43": 564,
  "44": 250,
  "45": 333,
  "46": 250,
  "47": 278,
  "48": 500,
  "49": 500,
  "50": 500,
  "51": 500,
  "52": 500,
  "53": 500,
  "54": 500,
  "55": 500,
  "56": 500,
  "57": 500,
  "58": 278,
  "59": 278,
  "60": 564,
  "61": 564,
  "62": 564,
  "63": 444,
  "64": 921,
  "65": 722,
  "66": 667,
  "67": 667,
  "68": 722,
  "69": 611,
  "70": 556,
  "71": 722,
  "72": 722,
  "73": 333,
  "74": 389,
  "75": 722,
  "76": 611,
  "77": 889,
  "78": 722,
  "79": 722,
  "80": 556,
  "81": 722,
  "82": 667,
  "83": 556,
  "84": 611,
  "85": 722,
  "86": 722,
  "87": 944,
  "88": 722,
  "89": 722,
  "90": 611,
  "91": 333,
  "92": 278,
  "93": 333,
  "94": 469,
  "95": 500,
  "96": 333,
  "97": 444,
  "98": 500,
  "99": 444,
  "100": 500,
  "101": 444,
  "102": 333,
  "103": 500,
  "104": 500,
  "105": 278,
  "106": 278,
  "107": 500,
  "108": 278,
  "109": 778,
  "110": 500,
  "111": 500,
  "112": 500,
  "113": 500,
  "114": 333,
  "115": 389,
  "116": 278,
  "117": 500,
  "118": 500,
  "119": 722,
  "120": 500,
  "121": 500,
  "122": 444,
  "123": 480,
  "124": 200,
  "125": 480,
  "126": 541,
  "161": 333,
  "162": 500,
  "163": 500,
  "164": 167,
  "165": 500,
  "166": 500,
  "167": 500,
  "168": 500,
  "169": 180,
  "170": 444,
  "171": 500,
  "172": 333,
  "173": 333,
  "174": 556,
  "175": 556,
  "177": 500,
  "178": 500,
  "179": 500,
  "180": 250,
  "182": 453,
  "183": 350,
  "184": 333,
  "185": 444,
  "186": 444,
  "187": 500,
  "188": 1e3,
  "189": 1e3,
  "191": 444,
  "193": 333,
  "194": 333,
  "195": 333,
  "196": 333,
  "197": 333,
  "198": 333,
  "199": 333,
  "200": 333,
  "202": 333,
  "203": 333,
  "205": 333,
  "206": 333,
  "207": 333,
  "208": 1e3,
  "225": 889,
  "227": 276,
  "232": 611,
  "233": 722,
  "234": 889,
  "235": 310,
  "241": 667,
  "245": 278,
  "248": 278,
  "249": 500,
  "250": 722,
  "251": 500,
  "-1": 500
};

// src/pdf/font/base14/widths-times-bold.ts
var TIMES_BOLD_WIDTHS = {
  "32": 250,
  "33": 333,
  "34": 555,
  "35": 500,
  "36": 500,
  "37": 1e3,
  "38": 833,
  "39": 333,
  "40": 333,
  "41": 333,
  "42": 500,
  "43": 570,
  "44": 250,
  "45": 333,
  "46": 250,
  "47": 278,
  "48": 500,
  "49": 500,
  "50": 500,
  "51": 500,
  "52": 500,
  "53": 500,
  "54": 500,
  "55": 500,
  "56": 500,
  "57": 500,
  "58": 333,
  "59": 333,
  "60": 570,
  "61": 570,
  "62": 570,
  "63": 500,
  "64": 930,
  "65": 722,
  "66": 667,
  "67": 722,
  "68": 722,
  "69": 667,
  "70": 611,
  "71": 778,
  "72": 778,
  "73": 389,
  "74": 500,
  "75": 778,
  "76": 667,
  "77": 944,
  "78": 722,
  "79": 778,
  "80": 611,
  "81": 778,
  "82": 722,
  "83": 556,
  "84": 667,
  "85": 722,
  "86": 722,
  "87": 1e3,
  "88": 722,
  "89": 722,
  "90": 667,
  "91": 333,
  "92": 278,
  "93": 333,
  "94": 581,
  "95": 500,
  "96": 333,
  "97": 500,
  "98": 556,
  "99": 444,
  "100": 556,
  "101": 444,
  "102": 333,
  "103": 500,
  "104": 556,
  "105": 278,
  "106": 333,
  "107": 556,
  "108": 278,
  "109": 833,
  "110": 556,
  "111": 500,
  "112": 556,
  "113": 556,
  "114": 444,
  "115": 389,
  "116": 333,
  "117": 556,
  "118": 500,
  "119": 722,
  "120": 500,
  "121": 500,
  "122": 444,
  "123": 394,
  "124": 220,
  "125": 394,
  "126": 520,
  "161": 333,
  "162": 500,
  "163": 500,
  "164": 167,
  "165": 500,
  "166": 500,
  "167": 500,
  "168": 500,
  "169": 278,
  "170": 500,
  "171": 500,
  "172": 333,
  "173": 333,
  "174": 556,
  "175": 556,
  "177": 500,
  "178": 500,
  "179": 500,
  "180": 250,
  "182": 540,
  "183": 350,
  "184": 333,
  "185": 500,
  "186": 500,
  "187": 500,
  "188": 1e3,
  "189": 1e3,
  "191": 500,
  "193": 333,
  "194": 333,
  "195": 333,
  "196": 333,
  "197": 333,
  "198": 333,
  "199": 333,
  "200": 333,
  "202": 333,
  "203": 333,
  "205": 333,
  "206": 333,
  "207": 333,
  "208": 1e3,
  "225": 1e3,
  "227": 300,
  "232": 667,
  "233": 778,
  "234": 1e3,
  "235": 330,
  "241": 722,
  "245": 278,
  "248": 278,
  "249": 500,
  "250": 722,
  "251": 556,
  "-1": 500
};

// src/pdf/font/base14/widths-helvetica.ts
var HELVETICA_WIDTHS = {
  "32": 278,
  "33": 278,
  "34": 355,
  "35": 556,
  "36": 556,
  "37": 889,
  "38": 667,
  "39": 222,
  "40": 333,
  "41": 333,
  "42": 389,
  "43": 584,
  "44": 278,
  "45": 333,
  "46": 278,
  "47": 278,
  "48": 556,
  "49": 556,
  "50": 556,
  "51": 556,
  "52": 556,
  "53": 556,
  "54": 556,
  "55": 556,
  "56": 556,
  "57": 556,
  "58": 278,
  "59": 278,
  "60": 584,
  "61": 584,
  "62": 584,
  "63": 556,
  "64": 1015,
  "65": 667,
  "66": 667,
  "67": 722,
  "68": 722,
  "69": 667,
  "70": 611,
  "71": 778,
  "72": 722,
  "73": 278,
  "74": 500,
  "75": 667,
  "76": 556,
  "77": 833,
  "78": 722,
  "79": 778,
  "80": 667,
  "81": 778,
  "82": 722,
  "83": 667,
  "84": 611,
  "85": 722,
  "86": 667,
  "87": 944,
  "88": 667,
  "89": 667,
  "90": 611,
  "91": 278,
  "92": 278,
  "93": 278,
  "94": 469,
  "95": 556,
  "96": 222,
  "97": 556,
  "98": 556,
  "99": 500,
  "100": 556,
  "101": 556,
  "102": 278,
  "103": 556,
  "104": 556,
  "105": 222,
  "106": 222,
  "107": 500,
  "108": 222,
  "109": 833,
  "110": 556,
  "111": 556,
  "112": 556,
  "113": 556,
  "114": 333,
  "115": 500,
  "116": 278,
  "117": 556,
  "118": 500,
  "119": 722,
  "120": 500,
  "121": 500,
  "122": 500,
  "123": 334,
  "124": 260,
  "125": 334,
  "126": 584,
  "161": 333,
  "162": 556,
  "163": 556,
  "164": 167,
  "165": 556,
  "166": 556,
  "167": 556,
  "168": 556,
  "169": 191,
  "170": 333,
  "171": 556,
  "172": 333,
  "173": 333,
  "174": 500,
  "175": 500,
  "177": 556,
  "178": 556,
  "179": 556,
  "180": 278,
  "182": 537,
  "183": 350,
  "184": 222,
  "185": 333,
  "186": 333,
  "187": 556,
  "188": 1e3,
  "189": 1e3,
  "191": 611,
  "193": 333,
  "194": 333,
  "195": 333,
  "196": 333,
  "197": 333,
  "198": 333,
  "199": 333,
  "200": 333,
  "202": 333,
  "203": 333,
  "205": 333,
  "206": 333,
  "207": 333,
  "208": 1e3,
  "225": 1e3,
  "227": 370,
  "232": 556,
  "233": 778,
  "234": 1e3,
  "235": 365,
  "241": 889,
  "245": 278,
  "248": 222,
  "249": 611,
  "250": 944,
  "251": 611,
  "-1": 556
};

// src/pdf/font/base14/widths-helvetica-bold.ts
var HELVETICA_BOLD_WIDTHS = {
  "32": 278,
  "33": 333,
  "34": 474,
  "35": 556,
  "36": 556,
  "37": 889,
  "38": 722,
  "39": 278,
  "40": 333,
  "41": 333,
  "42": 389,
  "43": 584,
  "44": 278,
  "45": 333,
  "46": 278,
  "47": 278,
  "48": 556,
  "49": 556,
  "50": 556,
  "51": 556,
  "52": 556,
  "53": 556,
  "54": 556,
  "55": 556,
  "56": 556,
  "57": 556,
  "58": 333,
  "59": 333,
  "60": 584,
  "61": 584,
  "62": 584,
  "63": 611,
  "64": 975,
  "65": 722,
  "66": 722,
  "67": 722,
  "68": 722,
  "69": 667,
  "70": 611,
  "71": 778,
  "72": 722,
  "73": 278,
  "74": 556,
  "75": 722,
  "76": 611,
  "77": 833,
  "78": 722,
  "79": 778,
  "80": 667,
  "81": 778,
  "82": 722,
  "83": 667,
  "84": 611,
  "85": 722,
  "86": 667,
  "87": 944,
  "88": 667,
  "89": 667,
  "90": 611,
  "91": 333,
  "92": 278,
  "93": 333,
  "94": 584,
  "95": 556,
  "96": 278,
  "97": 556,
  "98": 611,
  "99": 556,
  "100": 611,
  "101": 556,
  "102": 333,
  "103": 611,
  "104": 611,
  "105": 278,
  "106": 278,
  "107": 556,
  "108": 278,
  "109": 889,
  "110": 611,
  "111": 611,
  "112": 611,
  "113": 611,
  "114": 389,
  "115": 556,
  "116": 333,
  "117": 611,
  "118": 556,
  "119": 778,
  "120": 556,
  "121": 556,
  "122": 500,
  "123": 389,
  "124": 280,
  "125": 389,
  "126": 584,
  "161": 333,
  "162": 556,
  "163": 556,
  "164": 167,
  "165": 556,
  "166": 556,
  "167": 556,
  "168": 556,
  "169": 238,
  "170": 500,
  "171": 556,
  "172": 333,
  "173": 333,
  "174": 611,
  "175": 611,
  "177": 556,
  "178": 556,
  "179": 556,
  "180": 278,
  "182": 556,
  "183": 350,
  "184": 278,
  "185": 500,
  "186": 500,
  "187": 556,
  "188": 1e3,
  "189": 1e3,
  "191": 611,
  "193": 333,
  "194": 333,
  "195": 333,
  "196": 333,
  "197": 333,
  "198": 333,
  "199": 333,
  "200": 333,
  "202": 333,
  "203": 333,
  "205": 333,
  "206": 333,
  "207": 333,
  "208": 1e3,
  "225": 1e3,
  "227": 370,
  "232": 611,
  "233": 778,
  "234": 1e3,
  "235": 365,
  "241": 889,
  "245": 278,
  "248": 278,
  "249": 611,
  "250": 944,
  "251": 611,
  "-1": 556
};

// src/pdf/font/base14/widths-courier.ts
var COURIER_WIDTHS = {
  "32": 600,
  "33": 600,
  "34": 600,
  "35": 600,
  "36": 600,
  "37": 600,
  "38": 600,
  "39": 600,
  "40": 600,
  "41": 600,
  "42": 600,
  "43": 600,
  "44": 600,
  "45": 600,
  "46": 600,
  "47": 600,
  "48": 600,
  "49": 600,
  "50": 600,
  "51": 600,
  "52": 600,
  "53": 600,
  "54": 600,
  "55": 600,
  "56": 600,
  "57": 600,
  "58": 600,
  "59": 600,
  "60": 600,
  "61": 600,
  "62": 600,
  "63": 600,
  "64": 600,
  "65": 600,
  "66": 600,
  "67": 600,
  "68": 600,
  "69": 600,
  "70": 600,
  "71": 600,
  "72": 600,
  "73": 600,
  "74": 600,
  "75": 600,
  "76": 600,
  "77": 600,
  "78": 600,
  "79": 600,
  "80": 600,
  "81": 600,
  "82": 600,
  "83": 600,
  "84": 600,
  "85": 600,
  "86": 600,
  "87": 600,
  "88": 600,
  "89": 600,
  "90": 600,
  "91": 600,
  "92": 600,
  "93": 600,
  "94": 600,
  "95": 600,
  "96": 600,
  "97": 600,
  "98": 600,
  "99": 600,
  "100": 600,
  "101": 600,
  "102": 600,
  "103": 600,
  "104": 600,
  "105": 600,
  "106": 600,
  "107": 600,
  "108": 600,
  "109": 600,
  "110": 600,
  "111": 600,
  "112": 600,
  "113": 600,
  "114": 600,
  "115": 600,
  "116": 600,
  "117": 600,
  "118": 600,
  "119": 600,
  "120": 600,
  "121": 600,
  "122": 600,
  "123": 600,
  "124": 600,
  "125": 600,
  "126": 600,
  "161": 600,
  "162": 600,
  "163": 600,
  "164": 600,
  "165": 600,
  "166": 600,
  "167": 600,
  "168": 600,
  "169": 600,
  "170": 600,
  "171": 600,
  "172": 600,
  "173": 600,
  "174": 600,
  "175": 600,
  "177": 600,
  "178": 600,
  "179": 600,
  "180": 600,
  "182": 600,
  "183": 600,
  "184": 600,
  "185": 600,
  "186": 600,
  "187": 600,
  "188": 600,
  "189": 600,
  "191": 600,
  "193": 600,
  "194": 600,
  "195": 600,
  "196": 600,
  "197": 600,
  "198": 600,
  "199": 600,
  "200": 600,
  "202": 600,
  "203": 600,
  "205": 600,
  "206": 600,
  "207": 600,
  "208": 600,
  "225": 600,
  "227": 600,
  "232": 600,
  "233": 600,
  "234": 600,
  "235": 600,
  "241": 600,
  "245": 600,
  "248": 600,
  "249": 600,
  "250": 600,
  "251": 600,
  "-1": 600
};

// src/pdf/font/base14/widths-courier-bold.ts
var COURIER_BOLD_WIDTHS = {
  "32": 600,
  "33": 600,
  "34": 600,
  "35": 600,
  "36": 600,
  "37": 600,
  "38": 600,
  "39": 600,
  "40": 600,
  "41": 600,
  "42": 600,
  "43": 600,
  "44": 600,
  "45": 600,
  "46": 600,
  "47": 600,
  "48": 600,
  "49": 600,
  "50": 600,
  "51": 600,
  "52": 600,
  "53": 600,
  "54": 600,
  "55": 600,
  "56": 600,
  "57": 600,
  "58": 600,
  "59": 600,
  "60": 600,
  "61": 600,
  "62": 600,
  "63": 600,
  "64": 600,
  "65": 600,
  "66": 600,
  "67": 600,
  "68": 600,
  "69": 600,
  "70": 600,
  "71": 600,
  "72": 600,
  "73": 600,
  "74": 600,
  "75": 600,
  "76": 600,
  "77": 600,
  "78": 600,
  "79": 600,
  "80": 600,
  "81": 600,
  "82": 600,
  "83": 600,
  "84": 600,
  "85": 600,
  "86": 600,
  "87": 600,
  "88": 600,
  "89": 600,
  "90": 600,
  "91": 600,
  "92": 600,
  "93": 600,
  "94": 600,
  "95": 600,
  "96": 600,
  "97": 600,
  "98": 600,
  "99": 600,
  "100": 600,
  "101": 600,
  "102": 600,
  "103": 600,
  "104": 600,
  "105": 600,
  "106": 600,
  "107": 600,
  "108": 600,
  "109": 600,
  "110": 600,
  "111": 600,
  "112": 600,
  "113": 600,
  "114": 600,
  "115": 600,
  "116": 600,
  "117": 600,
  "118": 600,
  "119": 600,
  "120": 600,
  "121": 600,
  "122": 600,
  "123": 600,
  "124": 600,
  "125": 600,
  "126": 600,
  "161": 600,
  "162": 600,
  "163": 600,
  "164": 600,
  "165": 600,
  "166": 600,
  "167": 600,
  "168": 600,
  "169": 600,
  "170": 600,
  "171": 600,
  "172": 600,
  "173": 600,
  "174": 600,
  "175": 600,
  "177": 600,
  "178": 600,
  "179": 600,
  "180": 600,
  "182": 600,
  "183": 600,
  "184": 600,
  "185": 600,
  "186": 600,
  "187": 600,
  "188": 600,
  "189": 600,
  "191": 600,
  "193": 600,
  "194": 600,
  "195": 600,
  "196": 600,
  "197": 600,
  "198": 600,
  "199": 600,
  "200": 600,
  "202": 600,
  "203": 600,
  "205": 600,
  "206": 600,
  "207": 600,
  "208": 600,
  "225": 600,
  "227": 600,
  "232": 600,
  "233": 600,
  "234": 600,
  "235": 600,
  "241": 600,
  "245": 600,
  "248": 600,
  "249": 600,
  "250": 600,
  "251": 600,
  "-1": 600
};

// src/pdf/font/base14-widths.ts
var base14Widths = {
  "Times-Roman": TIMES_ROMAN_WIDTHS,
  "Times-Bold": TIMES_BOLD_WIDTHS,
  "Helvetica": HELVETICA_WIDTHS,
  "Helvetica-Bold": HELVETICA_BOLD_WIDTHS,
  "Courier": COURIER_WIDTHS,
  "Courier-Bold": COURIER_BOLD_WIDTHS
};

// src/text/text-transform.ts
var LETTER_OR_NUMBER = /[\p{L}\p{N}]/u;
var DEFAULT_LOCALE = "en-US";
function capitalizeText(text) {
  let result = "";
  let capitalizeNext = true;
  for (const char of text) {
    if (LETTER_OR_NUMBER.test(char)) {
      if (capitalizeNext) {
        result += char.toLocaleUpperCase(DEFAULT_LOCALE);
        capitalizeNext = false;
      } else {
        result += char.toLocaleLowerCase(DEFAULT_LOCALE);
      }
      continue;
    }
    capitalizeNext = true;
    result += char;
  }
  return result;
}
function applyTextTransform(text, transform) {
  if (!text || !transform || transform === "none") {
    return text;
  }
  switch (transform) {
    case "uppercase":
      return text.toLocaleUpperCase(DEFAULT_LOCALE);
    case "lowercase":
      return text.toLocaleLowerCase(DEFAULT_LOCALE);
    case "capitalize":
      return capitalizeText(text);
    default:
      return text;
  }
}

// src/layout/utils/text-metrics.ts
var MONO_FAMILY_PATTERN = /(mono|code|courier|console)/i;
var CHARACTER_WIDTH_FACTORS = {
  SPACE: 0.32,
  DIGIT: 0.52,
  UPPER: 0.58,
  BASE: 0.5,
  PUNCTUATION: 0.35,
  IDEOGRAPHIC: 1
};
var WIDTH_CALIBRATION = 0.9;
var BASE14_BOLD_THRESHOLD = 600;
var BASE14_ALIAS = /* @__PURE__ */ new Map([
  ["helvetica", "Helvetica"],
  ["arial", "Helvetica"],
  ["sans-serif", "Helvetica"],
  ["times", "Times-Roman"],
  ["times-roman", "Times-Roman"],
  ["times new roman", "Times-Roman"],
  ["georgia", "Times-Roman"],
  ["serif", "Times-Roman"],
  ["courier", "Courier"],
  ["courier new", "Courier"],
  ["monaco", "Courier"],
  ["monospace", "Courier"]
]);
var BASE14_BOLD_VARIANT = /* @__PURE__ */ new Map([
  ["Times-Roman", "Times-Bold"],
  ["Helvetica", "Helvetica-Bold"],
  ["Courier", "Courier-Bold"]
]);
function assignIntrinsicTextMetrics(root, fontEmbedder) {
  root.walk((node) => {
    if (!node.textContent) {
      return;
    }
    const trimmed = node.textContent;
    if (trimmed.length === 0) {
      node.intrinsicInlineSize = 0;
      node.intrinsicBlockSize = resolvedLineHeight(node.style);
      return;
    }
    const { inlineSize, blockSize } = measureText(trimmed, node.style, fontEmbedder);
    node.intrinsicInlineSize = inlineSize;
    node.intrinsicBlockSize = blockSize;
  });
}
function measureText(text, style, fontEmbedder) {
  const effectiveText = applyTextTransform(text, style.textTransform);
  const lines = effectiveText.split(/\r?\n/);
  let maxLineWidth = 0;
  const fontWeight = typeof style.fontWeight === "number" ? style.fontWeight : 400;
  const fontStyle = style.fontStyle ?? "normal";
  const fontMetrics = fontEmbedder?.getMetrics(style.fontFamily ?? "", fontWeight, fontStyle);
  for (const line of lines) {
    const glyphWidth = measureTextWithGlyphs(line, style, fontMetrics ?? null);
    if (glyphWidth !== null) {
      maxLineWidth = Math.max(maxLineWidth, glyphWidth);
    } else {
      maxLineWidth = Math.max(maxLineWidth, estimateLineWidth(line, style));
    }
  }
  const lineHeight = resolvedLineHeight(style);
  const blockSize = Math.max(lineHeight, lines.length * lineHeight);
  return { inlineSize: maxLineWidth, blockSize };
}
function estimateLineWidth(line, style) {
  if (!line) {
    return 0;
  }
  const fontSize = style.fontSize || 16;
  const isMonospace = style.fontFamily ? MONO_FAMILY_PATTERN.test(style.fontFamily) : false;
  const baseFactor = isMonospace ? 0.6 : CHARACTER_WIDTH_FACTORS.BASE;
  const weightMultiplier = fontWeightWidthMultiplier(normalizeFontWeight(style.fontWeight));
  const letterSpacing = style.letterSpacing ?? 0;
  const wordSpacing = style.wordSpacing ?? 0;
  const spacingContribution = Math.max(line.length - 1, 0) * letterSpacing + countSpaces(line) * wordSpacing;
  const base14Width = measureUsingBase14(line, style);
  if (base14Width !== null) {
    return base14Width + spacingContribution;
  }
  let totalFactor = 0;
  for (const char of line) {
    totalFactor += factorForChar(char, baseFactor);
  }
  const heuristicWidth = totalFactor * fontSize * weightMultiplier;
  return heuristicWidth * WIDTH_CALIBRATION + spacingContribution;
}
function measureUsingBase14(text, style) {
  const baseFont = resolveBase14Font(style);
  if (!baseFont) {
    return null;
  }
  const widths = base14Widths[baseFont];
  if (!widths) {
    return null;
  }
  const fontSize = style.fontSize || 16;
  let total = 0;
  for (const char of text) {
    const code = char.codePointAt(0);
    if (code === void 0) {
      return null;
    }
    if (code > 255) {
      if (code === 8226) {
        const w2 = widths[149];
        if (w2 === void 0) return null;
        total += w2;
        continue;
      }
      const base = char.normalize("NFD").replace(/\p{M}+/gu, "");
      if (base && base.length === 1) {
        const baseCode = base.codePointAt(0);
        if (baseCode !== void 0 && baseCode <= 255) {
          const w2 = widths[baseCode];
          if (w2 !== void 0) {
            total += w2;
            continue;
          }
        }
      }
      return null;
    }
    let w = widths[code];
    if (w === void 0) {
      const base = char.normalize("NFD").replace(/\p{M}+/gu, "");
      if (base && base.length === 1) {
        const baseCode = base.codePointAt(0);
        if (baseCode !== void 0 && baseCode <= 255) {
          w = widths[baseCode];
        }
      }
      if (w === void 0) return null;
    }
    if (w >= 900) {
      const base = char.normalize("NFD").replace(/\p{M}+/gu, "");
      if (base && base.length === 1) {
        const baseCode = base.codePointAt(0);
        if (baseCode !== void 0 && baseCode <= 255) {
          const fallback = widths[baseCode];
          if (fallback !== void 0) {
            w = fallback;
          }
        }
      }
    }
    total += w;
  }
  return total / 1e3 * fontSize;
}
function resolveBase14Font(style) {
  const tokens = parseFontFamily(style.fontFamily);
  if (tokens.length === 0) {
    return null;
  }
  const normalizedWeight = normalizeFontWeight(style.fontWeight);
  for (const token of tokens) {
    const alias = BASE14_ALIAS.get(token);
    if (!alias) {
      continue;
    }
    if (normalizedWeight >= BASE14_BOLD_THRESHOLD) {
      const boldVariant = BASE14_BOLD_VARIANT.get(alias);
      if (boldVariant) {
        return boldVariant;
      }
    }
    return alias;
  }
  return null;
}
function parseFontFamily(value) {
  if (!value) {
    return [];
  }
  return value.split(",").map((token) => stripQuotes(token.trim()).toLowerCase()).filter((token) => token.length > 0);
}
function stripQuotes(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  return value;
}
function factorForChar(char, baseFactor) {
  if (char === " ") {
    return CHARACTER_WIDTH_FACTORS.SPACE;
  }
  if (char === "	") {
    return CHARACTER_WIDTH_FACTORS.SPACE * 4;
  }
  if (isDigit(char)) {
    return CHARACTER_WIDTH_FACTORS.DIGIT;
  }
  if (isUpperCase(char)) {
    return baseFactor + (CHARACTER_WIDTH_FACTORS.UPPER - CHARACTER_WIDTH_FACTORS.BASE);
  }
  if (isPunctuation(char)) {
    return CHARACTER_WIDTH_FACTORS.PUNCTUATION;
  }
  if (isIdeograph(char)) {
    return CHARACTER_WIDTH_FACTORS.IDEOGRAPHIC;
  }
  return baseFactor;
}
function isUpperCase(char) {
  return char >= "A" && char <= "Z";
}
function isDigit(char) {
  return char >= "0" && char <= "9";
}
function isPunctuation(char) {
  return /[.,;:!?'"`~\-_/\\()[\]{}<>]/.test(char);
}
function isIdeograph(char) {
  const code = char.codePointAt(0);
  if (code === void 0) {
    return false;
  }
  return code >= 19968 && code <= 40959 || // CJK Unified Ideographs
  code >= 13312 && code <= 19903 || // CJK Unified Ideographs Extension A
  code >= 63744 && code <= 64255 || // CJK Compatibility Ideographs
  code >= 12352 && code <= 12447 || // Hiragana
  code >= 12448 && code <= 12543 || // Katakana
  code >= 44032 && code <= 55215;
}
function countSpaces(line) {
  let count = 0;
  for (const char of line) {
    if (char === " ") {
      count += 1;
    }
  }
  return count;
}
function measureTextWithGlyphs(text, style, fontMetrics) {
  if (!fontMetrics) {
    return null;
  }
  let totalWidth = 0;
  for (const char of text) {
    const codePoint = char.codePointAt(0);
    if (codePoint === void 0) {
      continue;
    }
    const glyphId = fontMetrics.cmap.getGlyphId(codePoint);
    const glyphMetrics = fontMetrics.glyphMetrics.get(glyphId);
    if (glyphMetrics) {
      totalWidth += glyphMetrics.advanceWidth;
    }
  }
  const scale = style.fontSize / fontMetrics.metrics.unitsPerEm;
  const baseWidthPx = totalWidth * scale;
  const letterSpacing = style.letterSpacing ?? 0;
  const wordSpacing = style.wordSpacing ?? 0;
  const spacingContribution = Math.max(text.length - 1, 0) * letterSpacing + countSpaces(text) * wordSpacing;
  return baseWidthPx + spacingContribution;
}
function fontWeightWidthMultiplier(weight) {
  switch (weight) {
    case 100:
      return 0.92;
    case 200:
      return 0.94;
    case 300:
      return 0.96;
    case 400:
      return 1;
    case 500:
      return 1.02;
    case 600:
      return 1.04;
    case 700:
      return 1.08;
    case 800:
      return 1.1;
    case 900:
      return 1.12;
    default:
      return 1;
  }
}

// src/layout/pipeline/text-metrics-initializer.ts
var DefaultTextMetricsInitializer = class {
  assign(root, fontEmbedder) {
    assignIntrinsicTextMetrics(root, fontEmbedder);
  }
};

// src/layout/utils/node-math.ts
function resolveBoxMetrics(node, widthRef, heightRef) {
  const { style } = node;
  const paddingLeft = resolveLength(style.paddingLeft, widthRef, { auto: "zero" });
  const paddingRight = resolveLength(style.paddingRight, widthRef, { auto: "zero" });
  const paddingTop = resolveLength(style.paddingTop, heightRef, { auto: "zero" });
  const paddingBottom = resolveLength(style.paddingBottom, heightRef, { auto: "zero" });
  const borderLeft = resolveLength(style.borderLeft, widthRef, { auto: "zero" });
  const borderRight = resolveLength(style.borderRight, widthRef, { auto: "zero" });
  const borderTop = resolveLength(style.borderTop, heightRef, { auto: "zero" });
  const borderBottom = resolveLength(style.borderBottom, heightRef, { auto: "zero" });
  return {
    paddingLeft,
    paddingRight,
    paddingTop,
    paddingBottom,
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    contentBoxX: node.box.x + borderLeft + paddingLeft,
    contentBoxY: node.box.y + borderTop + paddingTop
  };
}
function horizontalNonContent(node, reference) {
  const { style } = node;
  return resolveLength(style.paddingLeft, reference, { auto: "zero" }) + resolveLength(style.paddingRight, reference, { auto: "zero" }) + resolveLength(style.borderLeft, reference, { auto: "zero" }) + resolveLength(style.borderRight, reference, { auto: "zero" });
}
function verticalNonContent(node, reference) {
  const { style } = node;
  return resolveLength(style.paddingTop, reference, { auto: "zero" }) + resolveLength(style.paddingBottom, reference, { auto: "zero" }) + resolveLength(style.borderTop, reference, { auto: "zero" }) + resolveLength(style.borderBottom, reference, { auto: "zero" });
}
function horizontalMargin(node, reference) {
  const { style } = node;
  return resolveLength(style.marginLeft, reference, { auto: "zero" }) + resolveLength(style.marginRight, reference, { auto: "zero" });
}
function inFlow(node) {
  const { position, float: floatMode } = node.style;
  const isFlowPosition = position === "static" /* Static */ || position === "relative" /* Relative */ || position === "sticky" /* Sticky */;
  return isFlowPosition && floatMode === "none" /* None */;
}
function establishesBFC(node) {
  const { style } = node;
  return style.float !== "none" /* None */ || style.position === "absolute" /* Absolute */ || style.position === "fixed" /* Fixed */ || overflowCreatesBFC(style.overflowX) || overflowCreatesBFC(style.overflowY) || style.display === "inline-block" /* InlineBlock */ || style.display === "table" /* Table */ || style.display === "inline-table" /* InlineTable */ || style.display === "flow-root" /* FlowRoot */;
}
function overflowCreatesBFC(mode) {
  switch (mode) {
    case "hidden" /* Hidden */:
    case "auto" /* Auto */:
    case "scroll" /* Scroll */:
    case "clip" /* Clip */:
      return true;
    default:
      return false;
  }
}
function nearestPositionedAncestor(node) {
  return node.nearestAncestor((ancestor) => {
    const position = ancestor.style.position;
    return position === "relative" /* Relative */ || position === "absolute" /* Absolute */ || position === "fixed" /* Fixed */ || position === "sticky" /* Sticky */;
  });
}
function containingBlock(node, viewport) {
  const { style } = node;
  if (style.position === "fixed" /* Fixed */) {
    return { x: 0, y: 0, width: viewport.width, height: viewport.height };
  }
  if (style.position === "absolute" /* Absolute */) {
    const ancestor = nearestPositionedAncestor(node);
    if (ancestor) {
      return {
        x: ancestor.box.x,
        y: ancestor.box.y,
        width: ancestor.box.contentWidth,
        height: ancestor.box.contentHeight
      };
    }
    return { x: 0, y: 0, width: viewport.width, height: viewport.height };
  }
  const parent = node.parent;
  if (!parent) {
    return { x: 0, y: 0, width: viewport.width, height: viewport.height };
  }
  const widthRef = Math.max(parent.box.contentWidth, 0);
  let heightRef = Math.max(parent.box.contentHeight, 0);
  if (heightRef === 0 && parent.style.height !== "auto") {
    const explicitHeight = resolveLength(parent.style.height, viewport.height, { auto: "reference" });
    if (Number.isFinite(explicitHeight) && explicitHeight > 0) {
      heightRef = explicitHeight;
    }
  }
  const xOffset = parent.box.x + resolveLength(parent.style.paddingLeft, widthRef, { auto: "zero" }) + resolveLength(parent.style.borderLeft, widthRef, { auto: "zero" });
  const yOffset = parent.box.y + resolveLength(parent.style.paddingTop, heightRef, { auto: "zero" }) + resolveLength(parent.style.borderTop, heightRef, { auto: "zero" });
  return {
    x: xOffset,
    y: yOffset,
    width: parent.box.contentWidth,
    height: heightRef
  };
}
function resolveWidthBlock(node, containingBlockWidth) {
  const style = node.style;
  const marginLeft = isAutoLength(style.marginLeft) ? 0 : resolveLength(style.marginLeft, containingBlockWidth, { auto: "zero" });
  const marginRight = isAutoLength(style.marginRight) ? 0 : resolveLength(style.marginRight, containingBlockWidth, { auto: "zero" });
  const available = Math.max(
    0,
    containingBlockWidth - horizontalNonContent(node, containingBlockWidth) - marginLeft - marginRight
  );
  const width = style.width === "auto" ? available : resolveLength(style.width, containingBlockWidth, {
    auto: "reference"
  });
  const minWidth = style.minWidth ? resolveLength(style.minWidth, containingBlockWidth, { auto: "zero" }) : Number.NEGATIVE_INFINITY;
  const maxWidth = style.maxWidth ? resolveLength(style.maxWidth, containingBlockWidth, { auto: "reference" }) : Number.POSITIVE_INFINITY;
  return clampMinMax(width, minWidth, maxWidth);
}
function resolveBlockAutoMargins(containingBlockWidth, borderBoxWidth, marginLeft, marginRight) {
  const marginLeftAuto = isAutoLength(marginLeft);
  const marginRightAuto = isAutoLength(marginRight);
  const resolvedMarginLeft = marginLeftAuto ? 0 : resolveLength(marginLeft, containingBlockWidth, { auto: "zero" });
  const resolvedMarginRight = marginRightAuto ? 0 : resolveLength(marginRight, containingBlockWidth, { auto: "zero" });
  let usedMarginLeft = resolvedMarginLeft;
  let usedMarginRight = resolvedMarginRight;
  const remainingSpace = containingBlockWidth - (borderBoxWidth + resolvedMarginLeft + resolvedMarginRight);
  if (!Number.isFinite(remainingSpace)) {
    return { marginLeft: usedMarginLeft, marginRight: usedMarginRight };
  }
  if (remainingSpace < 0) {
    if (marginLeftAuto && marginRightAuto) {
      usedMarginLeft = 0;
      usedMarginRight = 0;
    } else if (marginLeftAuto) {
      usedMarginLeft = 0;
    } else if (marginRightAuto) {
      usedMarginRight = 0;
    } else {
      usedMarginRight = resolvedMarginRight + remainingSpace;
    }
  } else {
    if (marginLeftAuto && marginRightAuto) {
      usedMarginLeft = remainingSpace / 2;
      usedMarginRight = remainingSpace / 2;
    } else if (marginLeftAuto) {
      usedMarginLeft = remainingSpace;
    } else if (marginRightAuto) {
      usedMarginRight = remainingSpace;
    } else {
      usedMarginRight = resolvedMarginRight + remainingSpace;
    }
  }
  return { marginLeft: usedMarginLeft, marginRight: usedMarginRight };
}

// src/layout/pipeline/out-of-flow-manager.ts
var DefaultOutOfFlowManager = class {
  layoutOutOfFlow(root, context, dispatcher) {
    const positionedNodes = [];
    root.walk((node) => {
      if (node.style.position === "absolute" /* Absolute */ || node.style.position === "fixed" /* Fixed */) {
        positionedNodes.push(node);
      }
    });
    for (const node of positionedNodes) {
      dispatcher(node, context);
      this.positionAbsoluteOrFixed(node, context.env);
    }
  }
  positionAbsoluteOrFixed(node, env) {
    const cb = containingBlock(node, env.viewport);
    const widthRef = cb.width;
    const heightRef = cb.height;
    const resolveInset = (value, reference) => {
      if (value === void 0 || isAutoLength(value)) {
        return void 0;
      }
      return resolveLength(value, reference, { auto: "zero" });
    };
    const left = resolveInset(node.style.left, widthRef);
    const right = resolveInset(node.style.right, widthRef);
    const top = resolveInset(node.style.top, heightRef);
    const bottom = resolveInset(node.style.bottom, heightRef);
    const borderBoxWidth = node.box.borderBoxWidth || node.box.contentWidth;
    const borderBoxHeight = node.box.borderBoxHeight || node.box.contentHeight;
    const measuredWidth = node.box.marginBoxWidth || borderBoxWidth;
    const measuredHeight = node.box.marginBoxHeight || borderBoxHeight;
    let x = cb.x;
    if (left !== void 0) {
      x = cb.x + left;
    } else if (right !== void 0) {
      x = cb.x + cb.width - measuredWidth - right;
    }
    let y = cb.y;
    if (top !== void 0) {
      y = cb.y + top;
    } else if (bottom !== void 0) {
      y = cb.y + cb.height - measuredHeight - bottom;
    }
    node.box.x = x;
    node.box.y = y;
  }
};

// src/layout/pipeline/engine.ts
var LayoutEngine = class {
  constructor(options) {
    this.strategies = options.strategies;
    this.contextFactory = options.contextFactory ?? new DefaultLayoutContextFactory();
    this.textMetricsInitializer = options.textMetricsInitializer ?? new DefaultTextMetricsInitializer();
    this.outOfFlowManager = options.outOfFlowManager ?? new DefaultOutOfFlowManager();
  }
  layoutTree(root, viewport, fontEmbedder) {
    const environment = new LayoutEnvironment({ viewport, fontEmbedder });
    const context = this.contextFactory.create(environment, (node) => {
      this.layoutNodeInternal(node, context);
    });
    this.textMetricsInitializer.assign(root, fontEmbedder);
    root.box.x = 0;
    root.box.y = 0;
    root.box.contentWidth = viewport.width;
    root.box.contentHeight = viewport.height;
    this.layoutNodeInternal(root, context);
    this.outOfFlowManager.layoutOutOfFlow(root, context, (node, ctx) => this.layoutNodeInternal(node, ctx));
    return root;
  }
  layoutNodeInternal(node, context) {
    const strategy = this.strategies.find((s) => s.canLayout(node));
    if (!strategy) {
      throw new Error(`No layout strategy available for display: ${node.style.display}`);
    }
    strategy.layout(node, context);
  }
};

// src/layout/strategies/display-none.ts
var DisplayNoneStrategy = class {
  canLayout(node) {
    return node.style.display === "none" /* None */;
  }
  layout(node, _context) {
    node.box.contentWidth = 0;
    node.box.contentHeight = 0;
  }
};

// src/layout/utils/margin.ts
var EPSILON = 1e-7;
function isApproximatelyZero(value) {
  return Math.abs(value) < EPSILON;
}
function isBlockLevel(node) {
  switch (node.style.display) {
    case "block" /* Block */:
    case "list-item" /* ListItem */:
      return true;
    default:
      return false;
  }
}
function isMarginCollapsibleChild(node) {
  return node.style.display !== "none" /* None */ && inFlow(node) && isBlockLevel(node) && !establishesBFC(node);
}
function collapseMarginSet(margins) {
  const positives = [];
  const negatives = [];
  for (const margin of margins) {
    if (margin > 0) {
      positives.push(margin);
    } else if (margin < 0) {
      negatives.push(margin);
    }
  }
  if (negatives.length === 0) {
    return positives.length > 0 ? Math.max(...positives) : 0;
  }
  if (positives.length === 0) {
    return Math.min(...negatives);
  }
  return Math.max(...positives) + Math.min(...negatives);
}
function collapsedGapBetween(prevBottomMargin, nextTopMargin, parentEstablishesBfc) {
  if (parentEstablishesBfc) {
    return prevBottomMargin + nextTopMargin;
  }
  return collapseMarginSet([prevBottomMargin, nextTopMargin]);
}
function findFirstMarginCollapsibleChild(node) {
  for (const child of node.children) {
    if (!inFlow(child) || child.style.display === "none" /* None */) {
      continue;
    }
    if (isMarginCollapsibleChild(child)) {
      return child;
    }
    break;
  }
  return void 0;
}
function findLastMarginCollapsibleChild(node) {
  for (let i = node.children.length - 1; i >= 0; i -= 1) {
    const child = node.children[i];
    if (!inFlow(child) || child.style.display === "none" /* None */) {
      continue;
    }
    if (isMarginCollapsibleChild(child)) {
      return child;
    }
    break;
  }
  return void 0;
}
function canCollapseMarginStart(node, containingBlockWidth) {
  if (!isBlockLevel(node) || establishesBFC(node)) {
    return false;
  }
  const paddingTop = resolveLength(node.style.paddingTop, containingBlockWidth, { auto: "zero" });
  const borderTop = resolveLength(node.style.borderTop, containingBlockWidth, { auto: "zero" });
  if (!isApproximatelyZero(paddingTop) || !isApproximatelyZero(borderTop)) {
    return false;
  }
  return findFirstMarginCollapsibleChild(node) !== void 0;
}
function canCollapseMarginEnd(node, containingBlockWidth) {
  if (!isBlockLevel(node) || establishesBFC(node)) {
    return false;
  }
  const paddingBottom = resolveLength(node.style.paddingBottom, containingBlockWidth, { auto: "zero" });
  const borderBottom = resolveLength(node.style.borderBottom, containingBlockWidth, { auto: "zero" });
  if (!isApproximatelyZero(paddingBottom) || !isApproximatelyZero(borderBottom)) {
    return false;
  }
  return findLastMarginCollapsibleChild(node) !== void 0;
}
function effectiveMarginTop(node, containingBlockWidth) {
  const ownMargin = resolveLength(node.style.marginTop, containingBlockWidth, { auto: "zero" });
  if (!isBlockLevel(node)) {
    return ownMargin;
  }
  if (!canCollapseMarginStart(node, containingBlockWidth)) {
    return ownMargin;
  }
  const firstChild = findFirstMarginCollapsibleChild(node);
  if (!firstChild) {
    return ownMargin;
  }
  const childContainingWidth = resolveWidthBlock(node, containingBlockWidth);
  const childMargin = effectiveMarginTop(firstChild, childContainingWidth);
  return collapseMarginSet([ownMargin, childMargin]);
}
function effectiveMarginBottom(node, containingBlockWidth) {
  const ownMargin = resolveLength(node.style.marginBottom, containingBlockWidth, { auto: "zero" });
  if (!isBlockLevel(node)) {
    return ownMargin;
  }
  if (!canCollapseMarginEnd(node, containingBlockWidth)) {
    return ownMargin;
  }
  const lastChild = findLastMarginCollapsibleChild(node);
  if (!lastChild) {
    return ownMargin;
  }
  const childContainingWidth = resolveWidthBlock(node, containingBlockWidth);
  const childMargin = effectiveMarginBottom(lastChild, childContainingWidth);
  return collapseMarginSet([ownMargin, childMargin]);
}

// src/layout/utils/overflow.ts
function finalizeOverflow(node) {
  const contentWidth = node.box.contentWidth;
  const contentHeight = node.box.contentHeight;
  node.box.scrollWidth = Math.max(
    contentWidth,
    ...node.children.map((child) => child.box.x + child.box.borderBoxWidth - node.box.x)
  );
  node.box.scrollHeight = Math.max(
    contentHeight,
    ...node.children.map((child) => child.box.y + child.box.borderBoxHeight - node.box.y)
  );
}

// src/layout/context/float-context.ts
var FloatContext = class {
  constructor() {
    this.floats = [];
  }
  register(side, rect) {
    this.floats.push({ side, rect });
  }
  bottom(side) {
    let result = 0;
    for (const entry of this.floats) {
      if (entry.side === side) {
        result = Math.max(result, entry.rect.bottom);
      }
    }
    return result;
  }
  inlineOffsets(top, bottom, containingBlockWidth) {
    let leftOffset = 0;
    let rightOffset = 0;
    for (const { side, rect } of this.floats) {
      if (!rangesOverlap(rect.top, rect.bottom, top, bottom)) {
        continue;
      }
      if (side === "left") {
        leftOffset = Math.max(leftOffset, rect.inlineEnd);
      } else {
        rightOffset = Math.max(rightOffset, containingBlockWidth - rect.inlineStart);
      }
    }
    return {
      start: leftOffset,
      end: containingBlockWidth - rightOffset
    };
  }
  nextUnblockedY(top, bottom) {
    let candidate = null;
    for (const { rect } of this.floats) {
      if (rangesOverlap(rect.top, rect.bottom, top, bottom)) {
        candidate = candidate === null ? rect.bottom : Math.min(candidate, rect.bottom);
      }
    }
    return candidate;
  }
};
function rangesOverlap(aStart, aEnd, bStart, bEnd) {
  return Math.max(aStart, bStart) < Math.min(aEnd, bEnd);
}

// src/layout/utils/floats.ts
function clearForBlock(node, floatContext, yCursor) {
  const { clear } = node.style;
  let y = yCursor;
  if (clear === "left" /* Left */ || clear === "both" /* Both */ || clear === "inline-start" /* InlineStart */) {
    y = Math.max(y, floatContext.bottom("left"));
  }
  if (clear === "right" /* Right */ || clear === "both" /* Both */ || clear === "inline-end" /* InlineEnd */) {
    y = Math.max(y, floatContext.bottom("right"));
  }
  return y;
}
function placeFloat(options) {
  const { node, floatContext, context, contentX, contentWidth } = options;
  context.layoutChild(node);
  const marginLeft = resolveLength(node.style.marginLeft, contentWidth, { auto: "zero" });
  const marginRight = resolveLength(node.style.marginRight, contentWidth, { auto: "zero" });
  const marginTop = resolveLength(node.style.marginTop, contentWidth, { auto: "zero" });
  const marginBottom = resolveLength(node.style.marginBottom, contentWidth, { auto: "zero" });
  const borderLeft = resolveLength(node.style.borderLeft, contentWidth, { auto: "zero" });
  const borderRight = resolveLength(node.style.borderRight, contentWidth, { auto: "zero" });
  const borderTop = resolveLength(node.style.borderTop, contentWidth, { auto: "zero" });
  const borderBottom = resolveLength(node.style.borderBottom, contentWidth, { auto: "zero" });
  const paddingLeft = resolveLength(node.style.paddingLeft, contentWidth, { auto: "zero" });
  const paddingRight = resolveLength(node.style.paddingRight, contentWidth, { auto: "zero" });
  const paddingTop = resolveLength(node.style.paddingTop, contentWidth, { auto: "zero" });
  const paddingBottom = resolveLength(node.style.paddingBottom, contentWidth, { auto: "zero" });
  const borderBoxWidth = node.box.contentWidth + paddingLeft + paddingRight + borderLeft + borderRight;
  const borderBoxHeight = node.box.contentHeight + paddingTop + paddingBottom + borderTop + borderBottom;
  node.box.borderBoxWidth = borderBoxWidth;
  node.box.borderBoxHeight = borderBoxHeight;
  node.box.marginBoxWidth = borderBoxWidth + marginLeft + marginRight;
  node.box.marginBoxHeight = borderBoxHeight + marginTop + marginBottom;
  const outerWidth = node.box.marginBoxWidth;
  const outerHeight = node.box.marginBoxHeight;
  let y = options.startY;
  let attempts = 0;
  while (true) {
    if (attempts > 1e3) {
      break;
    }
    const offsets = floatContext.inlineOffsets(y, y + outerHeight, contentWidth);
    const availableWidth = Math.max(0, offsets.end - offsets.start);
    if (outerWidth <= availableWidth) {
      const marginBoxStart = node.style.float === "left" /* Left */ ? contentX + offsets.start : contentX + offsets.end - outerWidth;
      const contentXPosition = marginBoxStart + marginLeft + borderLeft + paddingLeft;
      const contentYPosition = y + marginTop + borderTop + paddingTop;
      node.box.x = contentXPosition;
      node.box.y = contentYPosition;
      node.box.scrollWidth = node.box.contentWidth;
      node.box.scrollHeight = node.box.contentHeight;
      floatContext.register(node.style.float === "left" /* Left */ ? "left" : "right", {
        top: y,
        bottom: y + outerHeight,
        inlineStart: marginBoxStart - contentX,
        inlineEnd: marginBoxStart - contentX + outerWidth
      });
      return y + outerHeight;
    }
    const nextY = floatContext.nextUnblockedY(y, y + outerHeight);
    if (nextY === null || nextY <= y) {
      y += 1;
    } else {
      y = nextY;
    }
    attempts += 1;
  }
  return y + outerHeight;
}

// src/layout/inline/types.ts
function isBoxItem(item) {
  return item.kind === "box";
}

// src/pdf/font/ttf-lite.ts
init_fs_empty();

// src/pdf/font/ttf-table-parser.ts
var TtfTableParser = class {
  constructor(buffer) {
    this.tableDirectory = /* @__PURE__ */ new Map();
    this.dataView = new DataView(buffer);
    this.parseTableDirectory();
  }
  parseTableDirectory() {
    if (this.dataView.byteLength < 12) {
      throw new Error("Truncated TTF header");
    }
    const numTables = this.dataView.getUint16(4, false);
    const tableDirOffset = 12;
    const requiredDirBytes = tableDirOffset + numTables * 16;
    if (requiredDirBytes > this.dataView.byteLength) {
      throw new Error("Truncated table directory");
    }
    for (let i = 0; i < numTables; i++) {
      const offset = tableDirOffset + i * 16;
      const tag = this.dataView.getUint32(offset, false);
      const checksum = this.dataView.getUint32(offset + 4, false);
      const tableOffset = this.dataView.getUint32(offset + 8, false);
      const length = this.dataView.getUint32(offset + 12, false);
      const tagString = String.fromCharCode(
        tag >> 24 & 255,
        tag >> 16 & 255,
        tag >> 8 & 255,
        tag & 255
      );
      if (tagString === "gloc") {
        log("font", "warn", `\u{1F6AB} CAVEAT TTF PARSER: FORCE SKIPPING problematic table 'gloc' (0x${tag.toString(16)})`);
        continue;
      }
      const essentialTables = ["cmap", "head", "hhea", "hmtx", "maxp", "name", "OS/2", "post"];
      if (tableOffset + length > this.dataView.byteLength) {
        if (essentialTables.includes(tagString)) {
          log("font", "warn", `WOFF2 TTF: ESSENTIAL table ${tagString} has bounds issues - attempting to proceed with clamped length`);
          const clampedLength = Math.min(length, this.dataView.byteLength - tableOffset);
          if (clampedLength > 0) {
            this.tableDirectory.set(tag, {
              tag,
              checksum,
              offset: tableOffset,
              length: clampedLength
            });
            log("font", "debug", `\u2705 CAVEAT TTF PARSER: KEPT essential table ${tagString} with clamped length ${clampedLength}`);
          } else {
            log("font", "warn", `WOFF2 TTF: Essential table ${tagString} completely out of bounds - skipping`);
          }
        } else {
          log("font", "warn", `WOFF2 TTF: Skipping optional table ${tagString} due to bounds issues`);
          continue;
        }
      } else {
        this.tableDirectory.set(tag, {
          tag,
          checksum,
          offset: tableOffset,
          length
        });
      }
    }
  }
  getTable(tag) {
    const entry = this.tableDirectory.get(tag);
    if (!entry) return null;
    if (entry.offset + entry.length > this.dataView.byteLength) {
      throw new Error(`Invalid table entry for tag 0x${tag.toString(16)}`);
    }
    return new DataView(this.dataView.buffer, entry.offset, entry.length);
  }
  getUint16(table, offset) {
    if (offset + 2 > table.byteLength) throw new Error("Read beyond table bounds (getUint16)");
    return table.getUint16(offset, false);
  }
  getInt16(table, offset) {
    if (offset + 2 > table.byteLength) throw new Error("Read beyond table bounds (getInt16)");
    return table.getInt16(offset, false);
  }
  getInt8(table, offset) {
    if (offset + 1 > table.byteLength) throw new Error("Read beyond table bounds (getInt8)");
    return table.getInt8(offset);
  }
  getUint8(table, offset) {
    if (offset + 1 > table.byteLength) throw new Error("Read beyond table bounds (getUint8)");
    return table.getUint8(offset);
  }
  getUint32(table, offset) {
    if (offset + 4 > table.byteLength) throw new Error("Read beyond table bounds (getUint32)");
    return table.getUint32(offset, false);
  }
};

// src/pdf/font/ttf-global-metrics.ts
var HEAD = 1751474532;
var HHEA = 1751672161;
var OS_2 = 1330851634;
function parseGlobalMetrics(parser) {
  const headTable = parser.getTable(HEAD);
  if (!headTable) throw new Error("Missing head table");
  const unitsPerEm = parser.getUint16(headTable, 18);
  const hheaTable = parser.getTable(HHEA);
  if (!hheaTable) throw new Error("Missing hhea table");
  const ascender = parser.getInt16(hheaTable, 4);
  const descender = parser.getInt16(hheaTable, 6);
  const lineGap = parser.getInt16(hheaTable, 8);
  const numberOfHMetricsRaw = parser.getUint16(hheaTable, 34);
  const os2Table = parser.getTable(OS_2);
  let capHeight = ascender;
  let xHeight = Math.round(ascender * 0.5);
  if (os2Table && os2Table.byteLength >= 4) {
    const os2Version = parser.getUint16(os2Table, 0);
    if (os2Version >= 2 && os2Table.byteLength >= 96) {
      capHeight = parser.getInt16(os2Table, 88);
      xHeight = parser.getInt16(os2Table, 86);
    }
  }
  let headBBox = void 0;
  if (headTable.byteLength >= 44) {
    const xMin = parser.getInt16(headTable, 36);
    const yMin = parser.getInt16(headTable, 38);
    const xMax = parser.getInt16(headTable, 40);
    const yMax = parser.getInt16(headTable, 42);
    headBBox = [xMin, yMin, xMax, yMax];
  }
  const metrics = {
    unitsPerEm,
    ascender,
    descender,
    lineGap,
    capHeight,
    xHeight
  };
  return { metrics, numberOfHMetricsRaw, headBBox };
}

// src/pdf/font/ttf-glyph-metrics.ts
var HMTX = 1752003704;
function parseGlyphMetrics(parser, numberOfHMetrics, numGlyphs) {
  const hmtxTable = parser.getTable(HMTX);
  if (!hmtxTable) throw new Error("Missing hmtx table");
  const glyphMetrics = /* @__PURE__ */ new Map();
  const longBytes = numberOfHMetrics * 4;
  if (hmtxTable.byteLength < longBytes) {
    throw new Error("Truncated hmtx long metrics");
  }
  let lastAdvanceWidth = 0;
  for (let gid = 0; gid < numGlyphs; gid++) {
    if (gid < numberOfHMetrics) {
      const off = gid * 4;
      if (off + 4 > hmtxTable.byteLength) throw new Error("Truncated hmtx entry");
      const advanceWidth = parser.getUint16(hmtxTable, off);
      const leftSideBearing = parser.getInt16(hmtxTable, off + 2);
      glyphMetrics.set(gid, { advanceWidth, leftSideBearing });
      lastAdvanceWidth = advanceWidth;
    } else {
      const lsbOff = longBytes + (gid - numberOfHMetrics) * 2;
      if (lsbOff + 2 > hmtxTable.byteLength) throw new Error("Truncated hmtx LSB array");
      const leftSideBearing = parser.getInt16(hmtxTable, lsbOff);
      glyphMetrics.set(gid, { advanceWidth: lastAdvanceWidth, leftSideBearing });
    }
  }
  return glyphMetrics;
}

// src/pdf/font/ttf-cmap.ts
var CmapParser = class {
  constructor(parser, cmapTable) {
    this.unicodeMap = /* @__PURE__ */ new Map();
    this.parseCmapTable(parser, cmapTable);
  }
  parseCmapTable(parser, table) {
    if (table.byteLength < 4) throw new Error("Truncated cmap header");
    const version = table.getUint16(0, false);
    if (version !== 0) return;
    const numSubtables = table.getUint16(2, false);
    const subtables = [];
    const expectedDirLen = 4 + numSubtables * 8;
    if (expectedDirLen > table.byteLength) throw new Error("Truncated cmap subtables directory");
    for (let i = 0; i < numSubtables; i++) {
      const subtableOffset = 4 + i * 8;
      const platformId = table.getUint16(subtableOffset, false);
      const encodingId = table.getUint16(subtableOffset + 2, false);
      const offset = table.getUint32(subtableOffset + 4, false);
      if (offset >= table.byteLength) {
        throw new Error("Invalid subtable offset in cmap");
      }
      subtables.push({ platformId, encodingId, offset });
    }
    const pickSubtable = () => {
      const findPreferred = (platforms) => {
        for (const p of platforms) {
          for (const st of subtables) {
            if (st.platformId !== p.pid) continue;
            if (p.eids.length > 0 && !p.eids.includes(st.encodingId)) continue;
            if (st.offset + 2 <= table.byteLength) {
              const fmt = table.getUint16(st.offset, false);
              if (fmt === 12) return st;
            }
          }
        }
        for (const p of platforms) {
          for (const st of subtables) {
            if (st.platformId !== p.pid) continue;
            if (p.eids.length > 0 && !p.eids.includes(st.encodingId)) continue;
            if (st.offset + 2 <= table.byteLength) {
              const fmt = table.getUint16(st.offset, false);
              if (fmt === 4) return st;
            }
          }
        }
        return null;
      };
      let chosen = findPreferred([{ pid: 0, eids: [] }]);
      if (chosen) return chosen;
      chosen = findPreferred([{ pid: 3, eids: [10] }, { pid: 3, eids: [1] }]);
      if (chosen) return chosen;
      for (const st of subtables) {
        if (st.offset + 2 <= table.byteLength && table.getUint16(st.offset, false) === 4) return st;
      }
      return null;
    };
    const selected = pickSubtable();
    if (!selected) {
      return;
    }
    const format = table.getUint16(selected.offset, false);
    if (format === 4) {
      this.parseFormat4Table(parser, table, selected.offset);
    } else if (format === 12) {
      this.parseFormat12Table(parser, table, selected.offset);
    } else {
      return;
    }
  }
  parseFormat4Table(_parser, table, offset) {
    if (offset + 8 > table.byteLength) throw new Error("Truncated cmap format 4 header");
    const format = table.getUint16(offset, false);
    if (format !== 4) throw new Error("Unexpected cmap format (not 4)");
    const length = table.getUint16(offset + 2, false);
    if (offset + length > table.byteLength) throw new Error("Truncated cmap format 4 table");
    const segCountX2 = table.getUint16(offset + 6, false);
    const segCount = segCountX2 / 2;
    const endCodeOffset = offset + 14;
    const startCodeOffset = endCodeOffset + segCount * 2 + 2;
    const idDeltaOffset = startCodeOffset + segCount * 2;
    const idRangeOffsetOffset = idDeltaOffset + segCount * 2;
    if (idRangeOffsetOffset > offset + length) throw new Error("Truncated cmap format 4 arrays");
    for (let i = 0; i < segCount; i++) {
      const endCode = table.getUint16(endCodeOffset + i * 2, false);
      const startCode = table.getUint16(startCodeOffset + i * 2, false);
      const idDelta = table.getInt16(idDeltaOffset + i * 2, false);
      const idRangeOffset = table.getUint16(idRangeOffsetOffset + i * 2, false);
      if (startCode === 65535) break;
      if (startCode > endCode) throw new Error("Invalid cmap segment (startCode > endCode)");
      for (let code = startCode; code <= endCode; code++) {
        let glyphId = 0;
        if (idRangeOffset === 0) {
          glyphId = code + idDelta & 65535;
        } else {
          const idRangeWordOffset = idRangeOffsetOffset + i * 2;
          const glyphIndexOffset = idRangeWordOffset + idRangeOffset + (code - startCode) * 2;
          if (glyphIndexOffset + 2 > offset + length) {
            throw new Error("Truncated cmap glyphIndexArray");
          }
          glyphId = table.getUint16(glyphIndexOffset, false);
          if (glyphId !== 0) {
            glyphId = glyphId + idDelta & 65535;
          }
        }
        this.unicodeMap.set(code, glyphId);
      }
    }
  }
  parseFormat12Table(_parser, table, offset) {
    if (offset + 16 > table.byteLength) throw new Error("Truncated cmap format 12 header");
    const format = table.getUint16(offset, false);
    if (format !== 12) throw new Error("Unexpected cmap format (not 12)");
    const nGroups = table.getUint32(offset + 12, false);
    const groupsOffset = offset + 16;
    const required = groupsOffset + nGroups * 12;
    if (required > table.byteLength) throw new Error("Truncated cmap format 12 groups");
    let p = groupsOffset;
    for (let g = 0; g < nGroups; g++, p += 12) {
      const startCode = table.getUint32(p, false);
      const endCode = table.getUint32(p + 4, false);
      const startGID = table.getUint32(p + 8, false);
      if (startCode > endCode) throw new Error("Invalid cmap format 12 group (startCode > endCode)");
      for (let cp = startCode; cp <= endCode; cp++) {
        this.unicodeMap.set(cp, startGID + (cp - startCode));
      }
    }
  }
  getGlyphId(codePoint) {
    return this.unicodeMap.get(codePoint) ?? 0;
  }
  hasCodePoint(codePoint) {
    return this.unicodeMap.has(codePoint);
  }
};

// src/pdf/font/loca-reader.ts
var LocaTableReader = class {
  /**
   * Creates a new LocaTableReader.
   * @param locaTable - DataView of the loca table
   * @param indexToLocFormat - Format: 0 for short offsets, 1 for long offsets
   * @param reader - Binary data reader
   */
  constructor(locaTable, indexToLocFormat, reader) {
    this.offsets = [];
    try {
      if (indexToLocFormat === 0) {
        const entryCount = locaTable.byteLength / 2;
        for (let i = 0; i < entryCount; i++) {
          const v = reader.getUint16(locaTable, i * 2);
          this.offsets.push(v * 2);
        }
      } else {
        const entryCount = locaTable.byteLength / 4;
        for (let i = 0; i < entryCount; i++) {
          const v = reader.getUint32(locaTable, i * 4);
          this.offsets.push(v);
        }
      }
    } catch {
      this.offsets = [];
    }
  }
  /**
   * Gets the byte offset range for a glyph in the glyf table.
   * @param glyphId - The glyph ID
   * @returns Offset range or null if invalid glyph ID
   */
  getGlyphOffset(glyphId) {
    if (glyphId < 0 || glyphId >= this.offsets.length - 1) {
      return null;
    }
    const start = this.offsets[glyphId];
    const end = this.offsets[glyphId + 1];
    if (start < 0 || start > end) {
      return null;
    }
    return { start, end };
  }
  /**
   * Checks if a glyph is empty (has no outline data).
   * Empty glyphs have start === end in the loca table.
   * @param glyphId - The glyph ID
   * @returns True if the glyph is empty, false otherwise
   */
  isEmptyGlyph(glyphId) {
    if (glyphId < 0 || glyphId >= this.offsets.length - 1) {
      return true;
    }
    return this.offsets[glyphId] === this.offsets[glyphId + 1];
  }
  /**
   * Gets the total number of glyphs in the font.
   * @returns Number of glyphs
   */
  getGlyphCount() {
    return Math.max(0, this.offsets.length - 1);
  }
  /**
   * Validates that a glyph offset range is within the glyf table bounds.
   * @param range - The offset range to validate
   * @param glyfTableSize - Size of the glyf table in bytes
   * @returns True if valid, false otherwise
   */
  validateRange(range, glyfTableSize) {
    return range.start >= 0 && range.end <= glyfTableSize && range.start <= range.end;
  }
};

// src/pdf/font/simple-glyph-parser.ts
var SimpleGlyphParser = class {
  constructor(reader) {
    this.reader = reader;
  }
  /**
   * Parses a simple glyph from a DataView.
   * @param view - DataView containing the glyph data starting at the glyph header
   * @returns Array of glyph outline commands, or null if parsing fails
   */
  parse(view) {
    const contours = this.parseContours(view);
    if (!contours) return null;
    return this.buildOutlineCommands(contours);
  }
  /**
   * Parses glyph contours from the DataView.
   * @param view - DataView containing the glyph data
   * @returns Array of contours (each contour is an array of points), or null if parsing fails
   */
  parseContours(view) {
    if (view.byteLength < 10) return null;
    const numberOfContours = view.getInt16(0, false);
    if (numberOfContours < 0) return null;
    const endPtsOffset = 10;
    const endPts = [];
    for (let i = 0; i < numberOfContours; i++) {
      if (endPtsOffset + i * 2 + 2 > view.byteLength) return null;
      endPts.push(this.reader.getUint16(view, endPtsOffset + i * 2));
    }
    const instrLenOffset = endPtsOffset + numberOfContours * 2;
    if (instrLenOffset + 2 > view.byteLength) return null;
    const instructionLength = this.reader.getUint16(view, instrLenOffset);
    const flagsOffset = instrLenOffset + 2 + instructionLength;
    if (flagsOffset > view.byteLength) return null;
    const nPoints = endPts.length === 0 ? 0 : endPts[endPts.length - 1] + 1;
    if (nPoints <= 0) return [];
    const flagsResult = this.parseFlags(view, nPoints, flagsOffset);
    if (!flagsResult) return null;
    const { flags, nextOffset: xCoordOffset } = flagsResult;
    const coordsResult = this.parseCoordinates(view, flags, xCoordOffset);
    if (!coordsResult) return null;
    const { points } = coordsResult;
    const contours = [];
    let startIndex = 0;
    for (let c = 0; c < numberOfContours; c++) {
      const endIndex = endPts[c];
      if (endIndex < startIndex || endIndex >= points.length) return null;
      contours.push(points.slice(startIndex, endIndex + 1));
      startIndex = endIndex + 1;
    }
    return contours;
  }
  /**
   * Parses glyph flags with run-length encoding.
   * @param view - DataView containing the glyph data
   * @param nPoints - Number of points to read
   * @param offset - Starting offset for flags
   * @returns Flags array and next offset, or null if parsing fails
   */
  parseFlags(view, nPoints, offset) {
    const flags = [];
    let p = offset;
    try {
      while (flags.length < nPoints) {
        if (p >= view.byteLength) return null;
        const flag = this.reader.getUint8(view, p++);
        flags.push(flag);
        if (flag & 8) {
          if (p >= view.byteLength) return null;
          const repeatCount = this.reader.getUint8(view, p++);
          for (let r = 0; r < repeatCount; r++) {
            flags.push(flag);
          }
        }
      }
    } catch {
      return null;
    }
    return { flags, nextOffset: p };
  }
  /**
   * Parses glyph X and Y coordinates from delta values.
   * @param view - DataView containing the glyph data
   * @param flags - Flag array for each point
   * @param offset - Starting offset for coordinates
   * @returns Points array and next offset, or null if parsing fails
   */
  parseCoordinates(view, flags, offset) {
    const nPoints = flags.length;
    const xs = new Array(nPoints);
    const ys = new Array(nPoints);
    let p = offset;
    try {
      for (let i = 0; i < nPoints; i++) {
        const f = flags[i];
        if (f & 2) {
          if (p >= view.byteLength) return null;
          const val = this.reader.getUint8(view, p++);
          xs[i] = f & 16 ? val : -val;
        } else {
          if (f & 16) {
            xs[i] = 0;
          } else {
            if (p + 2 > view.byteLength) return null;
            xs[i] = this.reader.getInt16(view, p);
            p += 2;
          }
        }
      }
    } catch {
      return null;
    }
    try {
      for (let i = 0; i < nPoints; i++) {
        const f = flags[i];
        if (f & 4) {
          if (p >= view.byteLength) return null;
          const val = this.reader.getUint8(view, p++);
          ys[i] = f & 32 ? val : -val;
        } else {
          if (f & 32) {
            ys[i] = 0;
          } else {
            if (p + 2 > view.byteLength) return null;
            ys[i] = this.reader.getInt16(view, p);
            p += 2;
          }
        }
      }
    } catch {
      return null;
    }
    const points = new Array(nPoints);
    let curX = 0;
    let curY = 0;
    for (let i = 0; i < nPoints; i++) {
      curX += xs[i];
      curY += ys[i];
      points[i] = {
        x: curX,
        y: curY,
        onCurve: !!(flags[i] & 1)
        // Bit 0: on-curve flag
      };
    }
    return { points, nextOffset: p };
  }
  /**
   * Converts contour points into glyph outline commands.
   * Handles quadratic Bezier curves with consecutive off-curve points.
   * @param contours - Array of contours
   * @returns Array of glyph outline commands
   */
  buildOutlineCommands(contours) {
    const cmds = [];
    for (const contour of contours) {
      if (contour.length === 0) continue;
      const n = contour.length;
      const getIdx = (i2) => (i2 % n + n) % n;
      let startPtIndex = -1;
      for (let i2 = 0; i2 < n; i2++) {
        if (contour[i2].onCurve) {
          startPtIndex = i2;
          break;
        }
      }
      let firstPoint;
      let curIndex;
      if (startPtIndex === -1) {
        const p0 = contour[0];
        const plast = contour[n - 1];
        firstPoint = {
          x: (plast.x + p0.x) / 2,
          y: (plast.y + p0.y) / 2,
          onCurve: true
        };
        curIndex = 0;
      } else {
        firstPoint = contour[startPtIndex];
        curIndex = startPtIndex;
      }
      cmds.push({ type: "moveTo", x: firstPoint.x, y: firstPoint.y });
      let i = curIndex + 1;
      let steps = 0;
      while (steps < n) {
        const idx = getIdx(i);
        const pt = contour[idx];
        const next = contour[getIdx(i + 1)];
        if (pt.onCurve) {
          cmds.push({ type: "lineTo", x: pt.x, y: pt.y });
        } else {
          if (next.onCurve) {
            cmds.push({ type: "quadTo", cx: pt.x, cy: pt.y, x: next.x, y: next.y });
            i++;
            steps++;
          } else {
            const midx = (pt.x + next.x) / 2;
            const midy = (pt.y + next.y) / 2;
            cmds.push({ type: "quadTo", cx: pt.x, cy: pt.y, x: midx, y: midy });
          }
        }
        i++;
        steps++;
      }
      cmds.push({ type: "close" });
    }
    return cmds;
  }
};

// src/pdf/font/transformation-matrix.ts
var TransformationMatrix = class _TransformationMatrix {
  constructor(mxx = 1, mxy = 0, myx = 0, myy = 1, tx = 0, ty = 0) {
    this.mxx = mxx;
    this.mxy = mxy;
    this.myx = myx;
    this.myy = myy;
    this.tx = tx;
    this.ty = ty;
  }
  /**
   * Creates an identity transformation matrix (no transformation).
   */
  static identity() {
    return new _TransformationMatrix();
  }
  /**
   * Creates a uniform scale transformation matrix.
   * @param s - Scale factor for both X and Y axes
   */
  static scale(s) {
    return new _TransformationMatrix(s, 0, 0, s, 0, 0);
  }
  /**
   * Creates a non-uniform scale transformation matrix.
   * @param sx - Scale factor for X axis
   * @param sy - Scale factor for Y axis
   */
  static scaleXY(sx, sy) {
    return new _TransformationMatrix(sx, 0, 0, sy, 0, 0);
  }
  /**
   * Creates a translation transformation matrix.
   * @param tx - Translation along X axis
   * @param ty - Translation along Y axis
   */
  static translate(tx, ty) {
    return new _TransformationMatrix(1, 0, 0, 1, tx, ty);
  }
  /**
   * Creates a transformation matrix from TrueType component transform data.
   * @param tx - Translation X
   * @param ty - Translation Y
   * @param mxx - Matrix element (1,1)
   * @param mxy - Matrix element (1,2)
   * @param myx - Matrix element (2,1)
   * @param myy - Matrix element (2,2)
   */
  static fromComponents(tx, ty, mxx = 1, mxy = 0, myx = 0, myy = 1) {
    return new _TransformationMatrix(mxx, mxy, myx, myy, tx, ty);
  }
  /**
   * Transforms a single point using this matrix.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @returns Transformed coordinates
   */
  transformPoint(x, y) {
    return {
      x: x * this.mxx + y * this.myx + this.tx,
      y: x * this.mxy + y * this.myy + this.ty
    };
  }
  /**
   * Applies this transformation to a list of glyph outline commands.
   * Creates new command objects with transformed coordinates.
   * @param cmds - Original glyph outline commands
   * @returns New array of transformed commands
   */
  applyToCommands(cmds) {
    const out = [];
    for (const c of cmds) {
      switch (c.type) {
        case "moveTo": {
          const { x, y } = this.transformPoint(c.x, c.y);
          out.push({ type: "moveTo", x, y });
          break;
        }
        case "lineTo": {
          const { x, y } = this.transformPoint(c.x, c.y);
          out.push({ type: "lineTo", x, y });
          break;
        }
        case "quadTo": {
          const cp = this.transformPoint(c.cx, c.cy);
          const ep = this.transformPoint(c.x, c.y);
          out.push({ type: "quadTo", cx: cp.x, cy: cp.y, x: ep.x, y: ep.y });
          break;
        }
        case "cubicTo": {
          const cp1 = this.transformPoint(c.cx1, c.cy1);
          const cp2 = this.transformPoint(c.cx2, c.cy2);
          const ep = this.transformPoint(c.x, c.y);
          out.push({
            type: "cubicTo",
            cx1: cp1.x,
            cy1: cp1.y,
            cx2: cp2.x,
            cy2: cp2.y,
            x: ep.x,
            y: ep.y
          });
          break;
        }
        case "close": {
          out.push({ type: "close" });
          break;
        }
      }
    }
    return out;
  }
};

// src/pdf/font/composite-glyph-parser.ts
var CompositeGlyphParser = class _CompositeGlyphParser {
  constructor(reader) {
    this.reader = reader;
    this.recursionLimit = 8;
    this.visited = /* @__PURE__ */ new Set();
  }
  static {
    // Component flags
    this.ARG_1_AND_2_ARE_WORDS = 1;
  }
  static {
    this.WE_HAVE_A_SCALE = 8;
  }
  static {
    this.MORE_COMPONENTS = 32;
  }
  static {
    this.WE_HAVE_AN_X_AND_Y_SCALE = 64;
  }
  static {
    this.WE_HAVE_A_TWO_BY_TWO = 128;
  }
  /**
   * Parses a composite glyph.
   * @param view - DataView containing the composite glyph data
   * @param provider - Provider for resolving component glyph references
   * @param depth - Current recursion depth
   * @returns Array of glyph outline commands, or null if parsing fails
   */
  parse(view, provider, depth = 0) {
    if (depth > this.recursionLimit) return null;
    const cmds = this.parseComponentRecords(view, 10, provider, depth);
    this.visited.clear();
    return cmds;
  }
  /**
   * Parses component records from a composite glyph.
   * @param view - DataView containing the glyph data
   * @param startOffset - Starting offset for component records
   * @param provider - Provider for resolving component references
   * @param depth - Current recursion depth
   * @returns Combined outline commands from all components, or null if parsing fails
   */
  parseComponentRecords(view, startOffset, provider, depth) {
    if (depth > this.recursionLimit) return null;
    let offset = startOffset;
    const allCmds = [];
    while (true) {
      const component = this.readComponentData(view, offset);
      if (!component) return null;
      offset = this.calculateNextOffset(view, offset, component.flags);
      if (this.visited.has(component.glyphIndex)) {
      } else {
        this.visited.add(component.glyphIndex);
        const componentCmds = provider.getOutline(component.glyphIndex, depth + 1);
        if (componentCmds && componentCmds.length > 0) {
          const transformedCmds = component.transform.applyToCommands(componentCmds);
          if (transformedCmds.length > 0 && transformedCmds[0].type !== "moveTo") {
            const firstCoord = this.findFirstCoordinate(transformedCmds);
            if (firstCoord) {
              allCmds.push({ type: "moveTo", x: firstCoord.x, y: firstCoord.y });
            }
          }
          allCmds.push(...transformedCmds);
        }
      }
      if (!component.hasMoreComponents) break;
    }
    return allCmds.length > 0 ? allCmds : null;
  }
  /**
   * Reads a single component's data from the view.
   * @param view - DataView containing the glyph data
   * @param offset - Starting offset for this component
   * @returns Component data or null if reading fails
   */
  readComponentData(view, offset) {
    if (offset + 4 > view.byteLength) return null;
    const flags = this.reader.getUint16(view, offset);
    const glyphIndex = this.reader.getUint16(view, offset + 2);
    let p = offset + 4;
    let arg1 = 0;
    let arg2 = 0;
    if (flags & _CompositeGlyphParser.ARG_1_AND_2_ARE_WORDS) {
      if (p + 4 > view.byteLength) return null;
      arg1 = this.reader.getInt16(view, p);
      arg2 = this.reader.getInt16(view, p + 2);
      p += 4;
    } else {
      if (p + 2 > view.byteLength) return null;
      arg1 = this.reader.getInt8(view, p);
      arg2 = this.reader.getInt8(view, p + 1);
      p += 2;
    }
    let mxx = 1, mxy = 0, myx = 0, myy = 1;
    if (flags & _CompositeGlyphParser.WE_HAVE_A_SCALE) {
      if (p + 2 > view.byteLength) return null;
      const scale = this.reader.getInt16(view, p) / (1 << 14);
      mxx = scale;
      myy = scale;
    } else if (flags & _CompositeGlyphParser.WE_HAVE_AN_X_AND_Y_SCALE) {
      if (p + 4 > view.byteLength) return null;
      const sx = this.reader.getInt16(view, p) / (1 << 14);
      const sy = this.reader.getInt16(view, p + 2) / (1 << 14);
      mxx = sx;
      myy = sy;
    } else if (flags & _CompositeGlyphParser.WE_HAVE_A_TWO_BY_TWO) {
      if (p + 8 > view.byteLength) return null;
      mxx = this.reader.getInt16(view, p) / (1 << 14);
      mxy = this.reader.getInt16(view, p + 2) / (1 << 14);
      myx = this.reader.getInt16(view, p + 4) / (1 << 14);
      myy = this.reader.getInt16(view, p + 6) / (1 << 14);
    }
    const transform = TransformationMatrix.fromComponents(arg1, arg2, mxx, mxy, myx, myy);
    return {
      glyphIndex,
      flags,
      transform,
      hasMoreComponents: !!(flags & _CompositeGlyphParser.MORE_COMPONENTS)
    };
  }
  /**
   * Calculates the next offset after reading a component record.
   * @param view - DataView containing the glyph data
   * @param offset - Current offset
   * @param flags - Component flags
   * @returns Next offset
   */
  calculateNextOffset(view, offset, flags) {
    let p = offset + 4;
    if (flags & _CompositeGlyphParser.ARG_1_AND_2_ARE_WORDS) {
      p += 4;
    } else {
      p += 2;
    }
    if (flags & _CompositeGlyphParser.WE_HAVE_A_SCALE) {
      p += 2;
    } else if (flags & _CompositeGlyphParser.WE_HAVE_AN_X_AND_Y_SCALE) {
      p += 4;
    } else if (flags & _CompositeGlyphParser.WE_HAVE_A_TWO_BY_TWO) {
      p += 8;
    }
    return p;
  }
  /**
   * Finds the first coordinate in a list of commands.
   * @param cmds - Array of glyph outline commands
   * @returns First coordinate found, or null
   */
  findFirstCoordinate(cmds) {
    for (const c of cmds) {
      if (c.type === "moveTo" || c.type === "lineTo") {
        return { x: c.x, y: c.y };
      }
      if (c.type === "quadTo") {
        return { x: c.x, y: c.y };
      }
      if (c.type === "cubicTo") {
        return { x: c.x, y: c.y };
      }
    }
    return null;
  }
};

// src/pdf/font/ttf-glyf.ts
var LOCA = 1819239265;
var GLYF = 1735162214;
var HEAD2 = 1751474532;
function createGlyfOutlineProvider(parser) {
  const headTable = parser.getTable(HEAD2);
  if (!headTable) {
    return () => null;
  }
  const indexToLocFormat = readIndexToLocFormat(headTable, parser);
  const locaTable = parser.getTable(LOCA);
  const glyfTable = parser.getTable(GLYF);
  if (!locaTable || !glyfTable) {
    return () => null;
  }
  const locaReader = new LocaTableReader(locaTable, indexToLocFormat, parser);
  const simpleParser = new SimpleGlyphParser(parser);
  const compositeParser = new CompositeGlyphParser(parser);
  const getOutlineInternal = (gid, depth = 0) => {
    const range = locaReader.getGlyphOffset(gid);
    if (!range) return null;
    if (range.start === range.end) return null;
    if (!locaReader.validateRange(range, glyfTable.byteLength)) return null;
    const view = createGlyphView(glyfTable, range.start, range.end);
    if (!view || view.byteLength < 10) return null;
    const numberOfContours = view.getInt16(0, false);
    if (numberOfContours >= 0) {
      return simpleParser.parse(view);
    } else {
      const provider = {
        getOutline: (componentGid, componentDepth) => getOutlineInternal(componentGid, componentDepth ?? 0)
      };
      return compositeParser.parse(view, provider, depth);
    }
  };
  return (gid) => getOutlineInternal(gid, 0);
}
function readIndexToLocFormat(headTable, reader) {
  try {
    return reader.getUint16(headTable, 50);
  } catch {
    return 0;
  }
}
function createGlyphView(glyfTable, start, end) {
  try {
    return new DataView(glyfTable.buffer, glyfTable.byteOffset + start, end - start);
  } catch {
    return null;
  }
}

// src/pdf/font/ttf-lite.ts
function parseTtfBuffer(buffer) {
  const parser = new TtfTableParser(buffer);
  const { metrics, numberOfHMetricsRaw, headBBox } = parseGlobalMetrics(parser);
  const MAXP = 1835104368;
  const maxpTable = parser.getTable(MAXP);
  if (!maxpTable) throw new Error("Missing maxp table");
  const numGlyphs = parser.getUint16(maxpTable, 4);
  const numberOfHMetrics = Math.min(numberOfHMetricsRaw, numGlyphs);
  const glyphMetrics = parseGlyphMetrics(parser, numberOfHMetrics, numGlyphs);
  const CMAP = 1668112752;
  const cmapTable = parser.getTable(CMAP);
  if (!cmapTable) throw new Error("Missing cmap table");
  const cmap = new CmapParser(parser, cmapTable);
  const kerning = mergeKerningMaps(parseKerningTable(parser), parseGposKerning(parser));
  const glyfProvider = createGlyfOutlineProvider(parser);
  return new TtfFontMetrics(metrics, glyphMetrics, cmap, headBBox, glyfProvider, kerning);
}
function parseKerningTable(parser) {
  const KERN = 1801810542;
  const table = parser.getTable(KERN);
  if (!table) return void 0;
  if (table.byteLength < 4) return void 0;
  const nTables = table.getUint16(2, false);
  let offset = 4;
  const result = /* @__PURE__ */ new Map();
  for (let i = 0; i < nTables; i++) {
    if (offset + 6 > table.byteLength) break;
    const subtableVersion = table.getUint16(offset, false);
    const length = table.getUint16(offset + 2, false);
    const coverage = table.getUint16(offset + 4, false);
    const format = coverage >> 8;
    if (subtableVersion === 0 && format === 0) {
      if (offset + length > table.byteLength) break;
      const stOffset = offset + 6;
      if (stOffset + 8 > table.byteLength) break;
      const pairCount = table.getUint16(stOffset, false);
      let cursor = stOffset + 8;
      for (let p = 0; p < pairCount; p++) {
        if (cursor + 6 > table.byteLength) break;
        const left = table.getUint16(cursor, false);
        const right = table.getUint16(cursor + 2, false);
        const value = table.getInt16(cursor + 4, false);
        if (value !== 0) {
          const rightMap = result.get(left) ?? /* @__PURE__ */ new Map();
          rightMap.set(right, value);
          result.set(left, rightMap);
        }
        cursor += 6;
      }
    }
    offset += length;
  }
  return result.size > 0 ? result : void 0;
}
function parseGposKerning(parser) {
  const GPOS = 1196445523;
  const table = parser.getTable(GPOS);
  if (!table) return void 0;
  if (table.byteLength < 10) return void 0;
  const gposStart = 0;
  const lookupListOffset = table.getUint16(gposStart + 8, false);
  if (lookupListOffset === 0 || lookupListOffset >= table.byteLength) return void 0;
  const kerning = /* @__PURE__ */ new Map();
  const lookupCount = table.getUint16(gposStart + lookupListOffset, false);
  let lookupOffsetsPos = gposStart + lookupListOffset + 2;
  for (let li = 0; li < lookupCount; li++) {
    if (lookupOffsetsPos + 2 > table.byteLength) break;
    const lookupOffset = table.getUint16(lookupOffsetsPos, false);
    lookupOffsetsPos += 2;
    if (lookupOffset === 0 || gposStart + lookupOffset >= table.byteLength) continue;
    const lookupStart = gposStart + lookupOffset;
    if (lookupStart + 6 > table.byteLength) continue;
    const lookupType = table.getUint16(lookupStart, false);
    const subTableCount = table.getUint16(lookupStart + 4, false);
    let subTableOffsetsPos = lookupStart + 6;
    if (lookupType !== 2) {
      continue;
    }
    for (let si = 0; si < subTableCount; si++) {
      if (subTableOffsetsPos + 2 > table.byteLength) break;
      const stOffset = table.getUint16(subTableOffsetsPos, false);
      subTableOffsetsPos += 2;
      if (stOffset === 0 || lookupStart + stOffset >= table.byteLength) continue;
      const stStart = lookupStart + stOffset;
      if (stStart + 10 > table.byteLength) continue;
      const format = table.getUint16(stStart, false);
      if (format !== 1) {
        continue;
      }
      const coverageOffset = table.getUint16(stStart + 2, false);
      const valueFormat1 = table.getUint16(stStart + 4, false);
      const valueFormat2 = table.getUint16(stStart + 6, false);
      const pairSetCount = table.getUint16(stStart + 8, false);
      const coverage = parseCoverageTable(table, stStart + coverageOffset);
      const pairSetOffsetsStart = stStart + 10;
      for (let pi = 0; pi < pairSetCount; pi++) {
        const leftGlyph = coverage[pi];
        if (leftGlyph === void 0) continue;
        const pairSetOffsetPos = pairSetOffsetsStart + pi * 2;
        if (pairSetOffsetPos + 2 > table.byteLength) break;
        const pairSetOffset = table.getUint16(pairSetOffsetPos, false);
        if (pairSetOffset === 0 || stStart + pairSetOffset >= table.byteLength) continue;
        const pairSetStart = stStart + pairSetOffset;
        if (pairSetStart + 2 > table.byteLength) continue;
        const pairValueCount = table.getUint16(pairSetStart, false);
        let recPos = pairSetStart + 2;
        for (let r = 0; r < pairValueCount; r++) {
          if (recPos + 2 > table.byteLength) break;
          const rightGlyph = table.getUint16(recPos, false);
          recPos += 2;
          const val1 = readValueRecord(table, recPos, valueFormat1);
          recPos += val1.length;
          const val2 = readValueRecord(table, recPos, valueFormat2);
          recPos += val2.length;
          const adjust = (val1.xAdvance ?? 0) + (val1.xPlacement ?? 0) + (val2.xPlacement ?? 0);
          if (adjust !== 0) {
            const rightMap = kerning.get(leftGlyph) ?? /* @__PURE__ */ new Map();
            rightMap.set(rightGlyph, adjust);
            kerning.set(leftGlyph, rightMap);
          }
        }
      }
    }
  }
  return kerning.size > 0 ? kerning : void 0;
}
function parseCoverageTable(table, offset) {
  if (offset + 4 > table.byteLength) return [];
  const format = table.getUint16(offset, false);
  if (format === 1) {
    const count = table.getUint16(offset + 2, false);
    const glyphs = [];
    let pos = offset + 4;
    for (let i = 0; i < count; i++) {
      if (pos + 2 > table.byteLength) break;
      glyphs.push(table.getUint16(pos, false));
      pos += 2;
    }
    return glyphs;
  }
  if (format === 2) {
    const rangeCount = table.getUint16(offset + 2, false);
    const glyphs = [];
    let pos = offset + 4;
    for (let i = 0; i < rangeCount; i++) {
      if (pos + 6 > table.byteLength) break;
      const start = table.getUint16(pos, false);
      const end = table.getUint16(pos + 2, false);
      const startCoverage = table.getUint16(pos + 4, false);
      for (let g = 0; g <= end - start; g++) {
        glyphs[startCoverage + g] = start + g;
      }
      pos += 6;
    }
    return glyphs;
  }
  return [];
}
function readValueRecord(table, offset, valueFormat) {
  let pos = offset;
  let xPlacement;
  let xAdvance;
  const consume = (flag) => {
    const v = table.getInt16(pos, false);
    pos += 2;
    return v;
  };
  if (valueFormat & 1) xPlacement = consume(1);
  if (valueFormat & 2) consume(2);
  if (valueFormat & 4) xAdvance = consume(4);
  if (valueFormat & 8) consume(8);
  const deviceFlags = [16, 32, 64, 128];
  for (const flag of deviceFlags) {
    if (valueFormat & flag) {
      pos += 2;
    }
  }
  return { xAdvance, xPlacement, length: pos - offset };
}
function mergeKerningMaps(a, b) {
  if (!a && !b) return void 0;
  const result = /* @__PURE__ */ new Map();
  const add2 = (map) => {
    if (!map) return;
    for (const [left, rights] of map.entries()) {
      const target = result.get(left) ?? /* @__PURE__ */ new Map();
      for (const [right, val] of rights.entries()) {
        target.set(right, (target.get(right) ?? 0) + val);
      }
      result.set(left, target);
    }
  };
  add2(a);
  add2(b);
  return result;
}

// src/fonts/detector.ts
function detectFontFormat(fontData) {
  if (fontData.length < 4) {
    return null;
  }
  const signature = String.fromCharCode(...fontData.slice(0, 4));
  switch (signature) {
    case "wOFF":
      return "woff";
    case "wOF2":
      return "woff2";
    case "\0\0\0":
    case "OTTO":
      return fontData[0] === 0 && fontData[1] === 1 ? "ttf" : "otf";
    default:
      return null;
  }
}

// src/fonts/utils/ttf-reconstructor.ts
function reconstructTtf(parsedFont) {
  const sfntVersion = parsedFont.flavor >>> 0;
  const numTables = parsedFont.numTables;
  const headerSize = 12;
  const tableDirSize = 16 * numTables;
  let totalDataSize = 0;
  const tableEntries = [];
  Object.entries(parsedFont.tables).sort(([a], [b]) => a.localeCompare(b)).forEach(([tag, data]) => {
    let entryData = data;
    if (tag === "head") {
      const view2 = new DataView(data.buffer, data.byteOffset, data.length);
      if (data.length >= 20) {
        const units = view2.getUint16(18, false);
        if (units === 0) {
          const patchedData = new Uint8Array(data);
          const patchedView = new DataView(patchedData.buffer);
          patchedView.setUint16(18, 1e3, false);
          entryData = patchedData;
        }
      }
    }
    tableEntries.push({ tag, data: entryData });
    const padding = (4 - entryData.length % 4) % 4;
    totalDataSize += entryData.length + padding;
  });
  const buffer = new ArrayBuffer(headerSize + tableDirSize + totalDataSize);
  const view = new Uint8Array(buffer);
  const dataView = new DataView(buffer);
  dataView.setUint32(0, sfntVersion, false);
  dataView.setUint16(4, numTables, false);
  let entrySelector = 0;
  let searchRange = 1;
  while (searchRange * 2 <= numTables) {
    searchRange *= 2;
    entrySelector++;
  }
  searchRange *= 16;
  const rangeShift = numTables * 16 - searchRange;
  dataView.setUint16(6, searchRange, false);
  dataView.setUint16(8, entrySelector, false);
  dataView.setUint16(10, rangeShift, false);
  let currentOffset = headerSize + tableDirSize;
  let dirOffset = 12;
  for (const entry of tableEntries) {
    const { tag, data } = entry;
    for (let i = 0; i < 4; i++) {
      view[dirOffset + i] = tag.charCodeAt(i);
    }
    const checksum = calculateTableChecksum(data);
    dataView.setUint32(dirOffset + 4, checksum, false);
    dataView.setUint32(dirOffset + 8, currentOffset, false);
    dataView.setUint32(dirOffset + 12, data.length, false);
    view.set(data, currentOffset);
    const padding = (4 - data.length % 4) % 4;
    currentOffset += data.length + padding;
    dirOffset += 16;
  }
  return buffer;
}
function calculateTableChecksum(data) {
  let sum = 0;
  const nlongs = Math.floor((data.length + 3) / 4);
  for (let i = 0; i < nlongs; i++) {
    let val = 0;
    const offset = i * 4;
    if (offset + 4 <= data.length) {
      val = data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
    } else {
      for (let j = 0; j < 4; j++) {
        if (offset + j < data.length) {
          val |= data[offset + j] << 24 - j * 8;
        }
      }
    }
    sum = sum + val >>> 0;
  }
  return sum;
}

// src/pdf/font/widths.ts
function computeWidths(metrics) {
  const count = metrics.glyphMetrics.size;
  const widths = new Array(count).fill(0);
  for (const [gid, gm] of metrics.glyphMetrics) {
    widths[gid] = Math.round(gm.advanceWidth / metrics.metrics.unitsPerEm * 1e3);
  }
  const computeDW = (arr) => {
    const freq = /* @__PURE__ */ new Map();
    for (const v of arr) {
      if (v === 0) continue;
      freq.set(v, (freq.get(v) ?? 0) + 1);
    }
    if (freq.size === 0) {
      return 1e3;
    }
    let best = 1e3;
    let bestCount = -1;
    for (const [v, c] of freq.entries()) {
      if (c > bestCount || c === bestCount && v < best) {
        best = v;
        bestCount = c;
      }
    }
    return best;
  };
  const DW = computeDW(widths);
  const result = [];
  let i = 0;
  while (i < count) {
    if (widths[i] === DW) {
      i++;
      continue;
    }
    const start = i;
    const val = widths[i];
    let j = i + 1;
    while (j < count && widths[j] === val) j++;
    const runLen = j - start;
    if (runLen >= 4) {
      result.push(start);
      result.push(j - 1);
      result.push(val);
      i = j;
      continue;
    }
    const listStart = i;
    const list = [];
    while (i < count && widths[i] !== DW && list.length < 32) {
      list.push(widths[i]);
      i++;
    }
    result.push(listStart);
    result.push(list);
  }
  return { DW, W: result };
}

// src/pdf/font/to-unicode.ts
function createToUnicodeCMapText(entries2) {
  if (!entries2 || entries2.length === 0) {
    return `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
endcodespacerange
endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  }
  const es = entries2.slice().sort((a, b) => a.gid - b.gid);
  const uniToUtf16Hex = (cp) => {
    if (cp <= 65535) {
      return cp.toString(16).padStart(4, "0").toUpperCase();
    }
    const v = cp - 65536;
    const hi = 55296 + (v >> 10);
    const lo = 56320 + (v & 1023);
    return hi.toString(16).padStart(4, "0").toUpperCase() + lo.toString(16).padStart(4, "0").toUpperCase();
  };
  const mappings = [];
  let i = 0;
  while (i < es.length) {
    const start = es[i];
    let j = i + 1;
    while (j < es.length && es[j].gid === es[j - 1].gid + 1 && es[j].unicode === es[j - 1].unicode + 1) {
      j++;
    }
    const runLen = j - i;
    if (runLen >= 2) {
      mappings.push({ type: "range", startG: start.gid, endG: es[j - 1].gid, startU: start.unicode });
      i = j;
    } else {
      mappings.push({ type: "char", gid: start.gid, unicode: start.unicode });
      i++;
    }
  }
  const lines = [];
  lines.push("/CIDInit /ProcSet findresource begin");
  lines.push("12 dict begin");
  lines.push("begincmap");
  lines.push("/CIDSystemInfo << /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def");
  lines.push("/CMapName /Adobe-Identity-UCS def");
  lines.push("/CMapType 2 def");
  lines.push("1 begincodespacerange");
  lines.push("<0000> <FFFF>");
  lines.push("endcodespacerange");
  const CHUNK = 100;
  let p = 0;
  while (p < mappings.length) {
    const currentType = mappings[p].type;
    const group = [];
    while (p < mappings.length && mappings[p].type === currentType && group.length < CHUNK) {
      group.push(mappings[p]);
      p++;
    }
    if (currentType === "char") {
      lines.push(`${group.length} beginbfchar`);
      for (const m of group) {
        const cid = m.gid.toString(16).padStart(4, "0").toUpperCase();
        const uniHex = uniToUtf16Hex(m.unicode);
        lines.push(`<${cid}> <${uniHex}>`);
      }
      lines.push("endbfchar");
    } else {
      lines.push(`${group.length} beginbfrange`);
      for (const m of group) {
        const startCid = m.startG.toString(16).padStart(4, "0").toUpperCase();
        const endCid = m.endG.toString(16).padStart(4, "0").toUpperCase();
        const startUniHex = uniToUtf16Hex(m.startU);
        lines.push(`<${startCid}> <${endCid}> <${startUniHex}>`);
      }
      lines.push("endbfrange");
    }
  }
  lines.push("endcmap");
  lines.push("CMapName currentdict /CMap defineresource pop");
  lines.push("end");
  lines.push("end");
  return lines.join("\n");
}

// src/pdf/font/font-config.ts
var BASE_FONT_ALIASES = /* @__PURE__ */ new Map([
  // Sans/UI families
  ["helvetica", "Lato"],
  ["arial", "Arimo"],
  ["arial black", "Arimo"],
  ["segoe ui", "Roboto"],
  ["open sans", "Lato"],
  ["calibri", "Roboto"],
  ["roboto", "Roboto"],
  ["arimo", "Arimo"],
  ["lato", "Lato"],
  ["noto sans", "Noto Sans"],
  ["notosans-regular", "Noto Sans"],
  ["dejavu sans", "DejaVu Sans"],
  // Serif
  ["times", "Tinos"],
  ["times-roman", "Tinos"],
  ["times new roman", "Tinos"],
  ["georgia", "Tinos"],
  ["garamond", "Tinos"],
  ["baskerville", "Tinos"],
  // Mono
  ["courier", "Fira Code"],
  ["courier new", "Fira Code"],
  ["consolas", "Fira Code"],
  ["menlo", "Fira Code"],
  ["monaco", "Fira Code"],
  ["source code pro", "Fira Code"],
  // Decorative / cursive
  ["comic sans", "Caveat"],
  ["comic sans ms", "Caveat"],
  ["fantasy", "Cinzel Decorative"],
  ["cursive", "Caveat"],
  // Emoji / math / symbols
  ["noto emoji", "Noto Emoji"],
  ["noto color emoji", "Noto Emoji"],
  ["segoe ui emoji", "Noto Emoji"],
  ["apple color emoji", "Noto Emoji"],
  ["twemoji", "Noto Emoji"],
  ["cambria math", "STIX Two Math"],
  ["stix two math", "STIX Two Math"],
  ["math", "STIX Two Math"],
  ["symbol", "Symbol"],
  ["zapfdingbats", "ZapfDingbats"]
]);
var GENERIC_FAMILIES = /* @__PURE__ */ new Map([
  ["serif", "Tinos"],
  ["sans-serif", "Lato"],
  ["monospace", "Fira Code"],
  ["system-ui", "Roboto"],
  ["cursive", "Caveat"],
  ["fantasy", "Cinzel Decorative"],
  ["emoji", "Noto Emoji"],
  ["math", "STIX Two Math"]
]);
var BASE14_FALLBACKS = /* @__PURE__ */ new Map([
  ["times", "Times-Roman"],
  ["times-roman", "Times-Roman"],
  ["times new roman", "Times-Roman"],
  ["georgia", "Times-Roman"],
  ["garamond", "Times-Roman"],
  ["baskerville", "Times-Roman"],
  ["serif", "Times-Roman"],
  ["helvetica", "Helvetica"],
  ["arial", "Helvetica"],
  ["segoe ui", "Helvetica"],
  ["open sans", "Helvetica"],
  ["calibri", "Helvetica"],
  ["sans-serif", "Helvetica"],
  ["system-ui", "Helvetica"],
  ["courier", "Courier"],
  ["courier new", "Courier"],
  ["monospace", "Courier"]
]);
var BASE14_FAMILY_VARIANTS = {
  "Helvetica": {
    normal: "Helvetica",
    italic: "Helvetica-Oblique",
    bold: "Helvetica-Bold",
    boldItalic: "Helvetica-BoldOblique"
  },
  "Times-Roman": {
    normal: "Times-Roman",
    italic: "Times-Italic",
    bold: "Times-Bold",
    boldItalic: "Times-BoldItalic"
  },
  "Courier": {
    normal: "Courier",
    italic: "Courier-Oblique",
    bold: "Courier-Bold",
    boldItalic: "Courier-BoldOblique"
  }
};
var BASE14_VARIANT_LOOKUP = (() => {
  const lookup = /* @__PURE__ */ new Map();
  for (const [family, variants] of Object.entries(BASE14_FAMILY_VARIANTS)) {
    for (const [variant, name] of Object.entries(variants)) {
      lookup.set(name.toLowerCase(), { family, variant });
    }
  }
  return lookup;
})();
function detectBase14Family(baseFont) {
  const entry = BASE14_VARIANT_LOOKUP.get(baseFont.toLowerCase());
  return entry ? entry.family : null;
}
function classifyBase14Variant(baseFont) {
  const entry = BASE14_VARIANT_LOOKUP.get(baseFont.toLowerCase());
  return entry ? entry.variant : "normal";
}

// src/pdf/font/embedder.ts
var TYPICAL_STEM_V = 80;
var FontEmbedder = class {
  constructor(config, doc) {
    this.config = config;
    this.doc = doc;
    this.embeddedFonts = /* @__PURE__ */ new Map();
    this.faceMetrics = /* @__PURE__ */ new Map();
  }
  async initialize() {
    for (const face of this.config.fontFaceDefs) {
      if (!face.data) {
        log("font", "error", `Missing data for font ${face.name}`);
        continue;
      }
      try {
        let fontData = new Uint8Array(face.data);
        const format = detectFontFormat(fontData);
        let ttfBuffer;
        if (format === "woff") {
          const parsed = await Promise.resolve().then(() => (init_decoder(), decoder_exports));
          const decoded = parsed.decodeWoff(fontData);
          ttfBuffer = reconstructTtf(decoded);
          fontData = new Uint8Array(ttfBuffer);
          face.data = ttfBuffer;
        } else if (format === "woff2") {
          const { decodeWoff2: decodeWoff22 } = await Promise.resolve().then(() => (init_decoder2(), decoder_exports2));
          const decoded = decodeWoff22(fontData);
          const ttfCopy = decoded.ttfBuffer.slice();
          ttfBuffer = ttfCopy.buffer;
          fontData = new Uint8Array(ttfBuffer);
          face.data = ttfBuffer;
        } else {
          ttfBuffer = face.data;
        }
        const metrics = parseTtfBuffer(ttfBuffer);
        this.faceMetrics.set(face.name, metrics);
      } catch (error) {
        log("font", "error", `Failed to load font ${face.name}`, { error: error instanceof Error ? error.message : String(error) });
      }
    }
  }
  ensureFont(familyStack, fontWeight, fontStyle) {
    const targetWeight = normalizeFontWeight(fontWeight);
    const wantsItalic = isItalic(fontStyle);
    for (const family of familyStack) {
      const normalizedFamily = family.toLowerCase().trim();
      const candidates = this.config.fontFaceDefs.filter((f) => {
        return (f.family || "").toLowerCase().trim() === normalizedFamily;
      });
      if (candidates.length === 0) {
        continue;
      }
      const face = pickFaceByWeight(candidates, targetWeight, wantsItalic);
      if (!face) {
        continue;
      }
      const faceKey = (face.name || "").toLowerCase().trim();
      const existing = this.embeddedFonts.get(face.name) ?? this.embeddedFonts.get(faceKey);
      if (existing) return existing;
      const embedded = this.embedFont(face);
      if (embedded) {
        this.embeddedFonts.set(face.name, embedded);
        this.embeddedFonts.set(faceKey, embedded);
        return embedded;
      }
    }
    return null;
  }
  embedFont(face) {
    const metrics = this.faceMetrics.get(face.name);
    if (!metrics) return null;
    const unitsPerEm = metrics.metrics.unitsPerEm;
    const scaleTo1000 = (v) => Math.round(v / unitsPerEm * 1e3);
    let fontBBox;
    if (metrics.headBBox) {
      const hb = metrics.headBBox;
      fontBBox = [scaleTo1000(hb[0]), scaleTo1000(hb[1]), scaleTo1000(hb[2]), scaleTo1000(hb[3])];
    } else {
      fontBBox = [-1e3, -1e3, 1e3, 1e3];
    }
    const fullFontData = new Uint8Array(face.data);
    const fontFileRef = this.doc.registerStream(fullFontData, {});
    const fontDescriptor = {
      Type: "/FontDescriptor",
      FontName: `/${face.name}`,
      Flags: computePdfFlagsFromFace(face),
      FontBBox: fontBBox,
      ItalicAngle: face.style === "italic" ? -12 : 0,
      Ascent: scaleTo1000(metrics.metrics.ascender),
      Descent: scaleTo1000(metrics.metrics.descender),
      CapHeight: scaleTo1000(metrics.metrics.capHeight),
      XHeight: scaleTo1000(metrics.metrics.xHeight),
      StemV: TYPICAL_STEM_V,
      FontFile2: fontFileRef
    };
    const fontDescriptorRef = this.doc.register(fontDescriptor);
    const { DW, W } = computeWidths(metrics);
    const cidFontDict = {
      Type: "/Font",
      Subtype: "/CIDFontType2",
      BaseFont: `/${face.name}`,
      CIDSystemInfo: {
        Registry: "(Adobe)",
        Ordering: "(Identity)",
        Supplement: 0
      },
      FontDescriptor: fontDescriptorRef,
      DW,
      W,
      // Rely on built-in Identity CIDToGID mapping to keep font dictionaries simple/compatible.
      CIDToGIDMap: "/Identity"
    };
    const cidFontRef = this.doc.register(cidFontDict);
    const toUnicodeRef = this.createToUnicodeCMap(metrics);
    const type0Font = {
      Type: "/Font",
      Subtype: "/Type0",
      BaseFont: `/${face.name}-Identity-H`,
      Encoding: "/Identity-H",
      DescendantFonts: [cidFontRef],
      ToUnicode: toUnicodeRef
    };
    const fontRef = this.doc.register(type0Font);
    return {
      resourceName: `F${this.embeddedFonts.size + 1}`,
      ref: fontRef,
      baseFont: face.name,
      metrics,
      subset: fullFontData
    };
  }
  createToUnicodeCMap(metrics, _uniqueUnicodes = []) {
    const unicodeMap = metrics.cmap["unicodeMap"];
    log("font", "debug", "createToUnicodeCMap - unicodeMap size", { size: unicodeMap.size });
    const samples = [];
    let count = 0;
    for (const [unicode, gid] of unicodeMap.entries()) {
      if (count < 10) {
        samples.push({ unicode, char: String.fromCodePoint(unicode), gid });
      }
      count++;
    }
    log("font", "debug", "createToUnicodeCMap - sample entries", { samples });
    const gidToUni = /* @__PURE__ */ new Map();
    for (const [unicode, gid] of unicodeMap.entries()) {
      if (!gidToUni.has(gid)) gidToUni.set(gid, unicode);
    }
    const gidSamples = [];
    let gidCount = 0;
    for (const [gid, unicode] of gidToUni.entries()) {
      if (gidCount < 20) {
        gidSamples.push({ gid, unicode, char: String.fromCodePoint(unicode) });
      }
      gidCount++;
    }
    log("font", "debug", "createToUnicodeCMap - gid->unicode sample", { samples: gidSamples });
    const entries2 = Array.from(gidToUni.entries()).map(([gid, unicode]) => ({ gid, unicode })).sort((a, b) => a.gid - b.gid);
    const cmapText = createToUnicodeCMapText(entries2);
    return this.doc.registerStream(new TextEncoder().encode(cmapText), {});
  }
  /**
   * Return parsed TTF metrics for a loaded face by name or family, or null if not available.
   * Exposed to allow rendering code to access outlines/metrics for embedding masks.
   * 
   * The lookup tries:
   * 1. Exact match by face name (e.g., "Tinos-Bold")
   * 2. Match by family name (e.g., "Tinos") with weight/style matching
   * 3. Case-insensitive match by family name
   * 4. If input contains comma-separated font stack (e.g., "Tinos, serif"), tries each font
   * 5. Uses BASE_FONT_ALIASES to resolve CSS font names to embedded fonts (e.g., "Times New Roman"  "Tinos")
   * 
   * @param faceName - Font family name or font stack
   * @param fontWeight - Optional font weight (100-900), defaults to 400
   * @param fontStyle - Optional font style ('normal' | 'italic' | 'oblique'), defaults to 'normal'
   */
  getMetrics(faceName, fontWeight = 400, fontStyle = "normal") {
    const exact = this.faceMetrics.get(faceName);
    if (exact) return exact;
    const wantsItalic = fontStyle === "italic" || fontStyle === "oblique";
    const fontStack = faceName.split(",").map((f) => f.trim().replace(/^["']|["']$/g, ""));
    for (const fontName of fontStack) {
      const normalizedQuery = fontName.toLowerCase().trim();
      const exactMatch = this.faceMetrics.get(fontName);
      if (exactMatch) return exactMatch;
      const aliasedFont = BASE_FONT_ALIASES.get(normalizedQuery) || GENERIC_FAMILIES.get(normalizedQuery);
      const targetFamily = aliasedFont ? aliasedFont.toLowerCase() : normalizedQuery;
      const matchingFaces = [];
      for (const face of this.config.fontFaceDefs) {
        const faceFamily = (face.family || "").toLowerCase().trim();
        if (faceFamily === targetFamily) {
          matchingFaces.push(face);
        }
      }
      if (matchingFaces.length > 0) {
        const bestFace = pickFaceByWeight(matchingFaces, fontWeight, wantsItalic);
        if (bestFace) {
          const metrics = this.faceMetrics.get(bestFace.name);
          if (metrics) return metrics;
        }
      }
    }
    return null;
  }
};
function pickFaceByWeight(faces, requestedWeight, wantsItalic) {
  if (faces.length === 0) {
    return null;
  }
  const styleFiltered = faces.filter((face) => isItalic(face.style) === wantsItalic);
  const pool = styleFiltered.length > 0 ? styleFiltered : faces;
  let bestFace = pool[0];
  let bestDiff = Math.abs(normalizeFontWeight(bestFace.weight) - requestedWeight);
  for (const face of pool) {
    const normalized = normalizeFontWeight(face.weight);
    const diff = Math.abs(normalized - requestedWeight);
    if (diff < bestDiff) {
      bestDiff = diff;
      bestFace = face;
    }
  }
  return bestFace;
}
function isItalic(style) {
  if (!style) return false;
  const s = style.toLowerCase();
  return s === "italic" || s === "oblique";
}
function computePdfFlagsFromFace(face) {
  let flags = 0;
  const family = (face.family || "").toLowerCase().trim();
  const name = (face.name || "").toLowerCase().trim();
  const style = (face.style || "").toLowerCase();
  const isItalic2 = /italic|oblique/i.test(style);
  const isSerif = /serif/i.test(family) || /serif/i.test(name);
  const isSymbol = /symbol|dingbat|dingbats|zapfdingbats/i.test(family) || /symbol|dingbat|dingbats/i.test(name);
  if (isSymbol) flags |= 1 << 2;
  else flags |= 1 << 5;
  if (isSerif) flags |= 1 << 1;
  if (isItalic2) flags |= 1 << 6;
  return flags;
}

// src/layout/inline/measurement.ts
function measureSegment(text, style, fontEmbedder) {
  const fontWeight = typeof style.fontWeight === "number" ? style.fontWeight : 400;
  const fontStyle = style.fontStyle ?? "normal";
  const metrics = fontEmbedder?.getMetrics(style.fontFamily ?? "", fontWeight, fontStyle);
  const glyphWidth = measureTextWithGlyphs(text, style, metrics ?? null);
  return glyphWidth ?? estimateLineWidth(text, style);
}
function countSpaces2(value) {
  let count = 0;
  for (const char of value) {
    if (char === " ") {
      count += 1;
    }
  }
  return count;
}
function measureInlineNode(node, containerWidth, context, layoutCallback) {
  if (node.style.display === "inline-block" /* InlineBlock */ || node.style.display === "inline-flex" /* InlineFlex */ || node.style.display === "inline-grid" /* InlineGrid */ || node.style.display === "inline-table" /* InlineTable */) {
    const savedX = node.box.x;
    const savedY = node.box.y;
    context.layoutChild(node);
    node.box.x = savedX;
    node.box.y = savedY;
  }
  const marginLeft = resolveLength(node.style.marginLeft, containerWidth, { auto: "zero" });
  const marginRight = resolveLength(node.style.marginRight, containerWidth, { auto: "zero" });
  const marginTop = resolveLength(node.style.marginTop, containerWidth, { auto: "zero" });
  const marginBottom = resolveLength(node.style.marginBottom, containerWidth, { auto: "zero" });
  const inlineChildrenResult = layoutCallback(node, containerWidth, context);
  let contentWidth = node.box.contentWidth;
  let contentHeight = node.box.contentHeight;
  if (inlineChildrenResult) {
    contentWidth = Math.max(contentWidth, inlineChildrenResult.contentWidth);
    contentHeight = Math.max(contentHeight, inlineChildrenResult.contentHeight);
  }
  if (node.style.display === "inline-block" /* InlineBlock */ && node.style.width === "auto") {
    const intrinsicWidth = node.box.scrollWidth;
    if (Number.isFinite(intrinsicWidth) && intrinsicWidth > 0 && intrinsicWidth < contentWidth) {
      const minWidth = node.style.minWidth !== void 0 ? resolveLength(node.style.minWidth, containerWidth, { auto: "zero" }) : void 0;
      const maxWidth = node.style.maxWidth !== void 0 ? resolveLength(node.style.maxWidth, containerWidth, { auto: "reference" }) : void 0;
      const clamped = clampMinMax(intrinsicWidth, minWidth, maxWidth);
      contentWidth = Math.min(clamped, contentWidth);
    }
  }
  if (contentWidth === 0 && !node.textContent) {
    if (typeof node.style.width === "number") {
      contentWidth = node.style.width;
    } else if (node.style.width !== "auto") {
      contentWidth = resolveLength(node.style.width, containerWidth, { auto: "zero" });
    } else if (node.intrinsicInlineSize !== void 0) {
      contentWidth = node.intrinsicInlineSize;
    } else {
      contentWidth = resolvedLineHeight(node.style);
    }
  }
  if (contentHeight === 0 && !node.textContent) {
    if (node.style.height !== "auto") {
      contentHeight = resolveLength(node.style.height, containerWidth, { auto: "zero" });
    } else if (node.intrinsicBlockSize !== void 0) {
      contentHeight = node.intrinsicBlockSize;
    } else {
      contentHeight = resolvedLineHeight(node.style);
    }
  }
  const paddingLeft = resolveLength(node.style.paddingLeft, containerWidth, { auto: "zero" });
  const paddingRight = resolveLength(node.style.paddingRight, containerWidth, { auto: "zero" });
  const paddingTop = resolveLength(node.style.paddingTop, containerWidth, { auto: "zero" });
  const paddingBottom = resolveLength(node.style.paddingBottom, containerWidth, { auto: "zero" });
  const borderLeft = resolveLength(node.style.borderLeft, containerWidth, { auto: "zero" });
  const borderRight = resolveLength(node.style.borderRight, containerWidth, { auto: "zero" });
  const borderTop = resolveLength(node.style.borderTop, containerWidth, { auto: "zero" });
  const borderBottom = resolveLength(node.style.borderBottom, containerWidth, { auto: "zero" });
  node.box.contentWidth = contentWidth;
  node.box.contentHeight = contentHeight;
  node.box.borderBoxWidth = contentWidth + paddingLeft + paddingRight + borderLeft + borderRight;
  node.box.borderBoxHeight = contentHeight + paddingTop + paddingBottom + borderTop + borderBottom;
  node.box.marginBoxWidth = node.box.borderBoxWidth + marginLeft + marginRight;
  node.box.marginBoxHeight = node.box.borderBoxHeight + marginTop + marginBottom;
  node.box.scrollWidth = Math.max(node.box.scrollWidth, node.box.contentWidth);
  node.box.scrollHeight = Math.max(node.box.scrollHeight, node.box.contentHeight);
  return {
    node,
    contentWidth,
    contentHeight,
    lineOffset: 0,
    marginLeft,
    marginRight,
    marginTop,
    marginBottom,
    paddingLeft,
    paddingRight,
    paddingTop,
    paddingBottom,
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    outerWidth: node.box.marginBoxWidth,
    outerHeight: node.box.marginBoxHeight
  };
}

// src/layout/inline/tokenizer.ts
function collectInlineFragments(nodes, containerWidth, context, layoutCallback) {
  const fragments = [];
  const recurse = (node) => {
    if (node.style.display === "none" /* None */) {
      return;
    }
    if (node.style.float !== "none" /* None */) {
      return;
    }
    if (isAtomicInline(node.style.display)) {
      const metrics = measureInlineNode(node, containerWidth, context, layoutCallback);
      fragments.push({ kind: "box", metrics });
      return;
    }
    if (node.textContent && node.style.display === "inline" /* Inline */) {
      fragments.push({
        kind: "text",
        node,
        style: node.style,
        text: node.textContent,
        preserveLeading: !!node.customData?.preserveLeadingSpace,
        preserveTrailing: !!node.customData?.preserveTrailingSpace
      });
      return;
    }
    for (const child of node.children) {
      if (!isInlineDisplay(child.style.display)) {
        continue;
      }
      recurse(child);
    }
  };
  for (const node of nodes) {
    recurse(node);
  }
  return fragments;
}
function tokenizeFragments(fragments, fontEmbedder) {
  const items = [];
  for (const fragment of fragments) {
    if (fragment.kind === "box") {
      items.push({
        kind: "box",
        width: fragment.metrics.outerWidth,
        height: fragment.metrics.outerHeight,
        lineHeight: fragment.metrics.outerHeight,
        metrics: fragment.metrics
      });
      continue;
    }
    const style = fragment.style;
    const raw = fragment.text ?? "";
    if (!raw) {
      continue;
    }
    const effectiveText = applyTextTransform(raw, style.textTransform);
    const lineHeight = resolvedLineHeight(style);
    const segments = segmentTextWithWhitespace(effectiveText, style.whiteSpace);
    for (const segment of segments) {
      if (segment.kind === "newline") {
        items.push({
          kind: "newline",
          width: 0,
          height: lineHeight,
          lineHeight
        });
        continue;
      }
      const width = measureSegment(segment.text, style, fontEmbedder);
      items.push({
        kind: segment.kind,
        width,
        height: lineHeight,
        lineHeight,
        node: fragment.node,
        style,
        text: segment.text,
        spaceCount: segment.kind === "space" ? countSpaces2(segment.text) : 0
      });
    }
  }
  return items;
}
function segmentTextWithWhitespace(text, mode) {
  const segments = [];
  const regex = /(\n)|(\s+)|([^\s]+)/g;
  let match;
  while ((match = regex.exec(text)) !== null) {
    if (match[1]) {
      if (mode === "pre" /* Pre */ || mode === "pre-wrap" /* PreWrap */ || mode === "pre-line" /* PreLine */) {
        segments.push({ kind: "newline", text: "\n" });
      } else {
        segments.push({ kind: "space", text: " " });
      }
    } else if (match[2]) {
      segments.push({ kind: "space", text: match[2] });
    } else if (match[3]) {
      segments.push({ kind: "word", text: match[3] });
    }
  }
  return segments;
}
function splitWordItemToken(item, availableWidth) {
  if (item.kind !== "word" || !item.text || !item.style) {
    return [item, null];
  }
  let buffer = "";
  let bufferWidth = 0;
  for (const char of Array.from(item.text)) {
    const candidate = buffer + char;
    const candidateWidth = estimateLineWidth(candidate, item.style);
    if (buffer && candidateWidth > availableWidth) {
      break;
    }
    buffer = candidate;
    bufferWidth = candidateWidth;
  }
  if (!buffer) {
    return [item, null];
  }
  const head = {
    ...item,
    text: buffer,
    width: bufferWidth
  };
  const tailText = item.text.slice(buffer.length);
  if (!tailText) {
    return [head, null];
  }
  const tail = {
    ...item,
    text: tailText,
    width: estimateLineWidth(tailText, item.style)
  };
  return [head, tail];
}
function isInlineDisplay(display) {
  switch (display) {
    case "inline" /* Inline */:
    case "inline-block" /* InlineBlock */:
    case "inline-flex" /* InlineFlex */:
    case "inline-grid" /* InlineGrid */:
    case "inline-table" /* InlineTable */:
      return true;
    default:
      return false;
  }
}
function isAtomicInline(display) {
  switch (display) {
    case "inline-block" /* InlineBlock */:
    case "inline-flex" /* InlineFlex */:
    case "inline-grid" /* InlineGrid */:
    case "inline-table" /* InlineTable */:
      return true;
    default:
      return false;
  }
}

// src/layout/inline/inline-utils.ts
function resolveInlineTextAlign(node) {
  let current2 = node;
  while (current2) {
    const value = current2.style.textAlign;
    if (value) {
      const normalized = value.toLowerCase();
      if (normalized !== "start" && normalized !== "auto") {
        return normalized;
      }
    }
    current2 = current2.parent;
  }
  return void 0;
}
function isInlineDisplay2(display) {
  switch (display) {
    case "inline" /* Inline */:
    case "inline-block" /* InlineBlock */:
    case "inline-flex" /* InlineFlex */:
    case "inline-grid" /* InlineGrid */:
    case "inline-table" /* InlineTable */:
      return true;
    default:
      return false;
  }
}
function shouldLayoutInlineChildren(node) {
  if (node.children.length === 0) {
    return false;
  }
  if (node.style.display !== "inline" /* Inline */) {
    return false;
  }
  return true;
}
function collectInlineParticipants(node) {
  const participants = [];
  for (const child of node.children) {
    if (child.style.display === "none" /* None */) {
      continue;
    }
    if (child.style.float !== "none" /* None */) {
      continue;
    }
    if (!isInlineDisplay2(child.style.display)) {
      continue;
    }
    participants.push(child);
  }
  return participants;
}
function inlineExtentWithinContainer(node, referenceWidth) {
  const marginLeft = resolveLength(node.style.marginLeft, referenceWidth, { auto: "zero" });
  const marginRight = resolveLength(node.style.marginRight, referenceWidth, { auto: "zero" });
  const paddingLeft = resolveLength(node.style.paddingLeft, referenceWidth, { auto: "zero" });
  const paddingRight = resolveLength(node.style.paddingRight, referenceWidth, { auto: "zero" });
  const borderLeft = resolveLength(node.style.borderLeft, referenceWidth, { auto: "zero" });
  const borderRight = resolveLength(node.style.borderRight, referenceWidth, { auto: "zero" });
  const marginStart = node.box.x - paddingLeft - borderLeft - marginLeft;
  const width = node.box.contentWidth + paddingLeft + paddingRight + borderLeft + borderRight + marginLeft + marginRight;
  return {
    start: marginStart,
    end: marginStart + width
  };
}

// src/layout/inline/text-alignment.ts
var LeftAlignment = class {
  calculateOffset() {
    return 0;
  }
};
var CenterAlignment = class {
  calculateOffset(lineWidth, availableWidth) {
    const slack = Math.max(availableWidth - lineWidth, 0);
    return slack / 2;
  }
};
var RightAlignment = class {
  calculateOffset(lineWidth, availableWidth) {
    const slack = Math.max(availableWidth - lineWidth, 0);
    return slack;
  }
};
var JustifyAlignment = class {
  calculateOffset() {
    return 0;
  }
};
function getAlignmentStrategy(textAlign) {
  switch (textAlign) {
    case "center":
      return new CenterAlignment();
    case "right":
    case "end":
      return new RightAlignment();
    case "justify":
      return new JustifyAlignment();
    default:
      return new LeftAlignment();
  }
}

// src/layout/inline/bounding-box-calculator.ts
var BoundingBoxCalculator = class {
  constructor() {
    this.boundingBoxes = /* @__PURE__ */ new Map();
  }
  /**
   * Compute per-node box sizes from their inline runs.
   * Assigns box dimensions based on the runs' position and sizes.
   */
  computeNodeBoxes(nodeRuns) {
    for (const [node, runs] of nodeRuns.entries()) {
      node.inlineRuns = runs;
      node.lineBoxes = void 0;
      const lineCount = runs.reduce((max, run) => Math.max(max, run.lineIndex + 1), 0);
      const lh = resolvedLineHeight(node.style);
      node.box.contentHeight = lineCount * lh;
      if (runs.length > 0) {
        const firstRun = runs[0];
        let minX = firstRun.startX;
        let maxX = firstRun.startX + firstRun.width;
        for (let i = 1; i < runs.length; i++) {
          const run = runs[i];
          minX = Math.min(minX, run.startX);
          maxX = Math.max(maxX, run.startX + run.width);
        }
        const actualWidth = maxX - minX;
        node.box.contentWidth = actualWidth;
      } else {
        node.box.contentWidth = 0;
      }
      node.box.borderBoxWidth = node.box.contentWidth;
      node.box.borderBoxHeight = node.box.contentHeight;
      node.box.marginBoxWidth = node.box.borderBoxWidth;
      node.box.marginBoxHeight = node.box.borderBoxHeight;
      node.box.scrollWidth = Math.max(node.box.scrollWidth, node.box.contentWidth);
      node.box.scrollHeight = Math.max(node.box.scrollHeight, node.box.contentHeight);
    }
  }
  /**
   * Propagate bounding boxes from text nodes to their inline ancestors.
   * This ensures that container nodes (like spans) have a bounding box that encompasses their content,
   * even if they didn't generate box items themselves (e.g. no padding/border).
   */
  propagateBoundingBoxes(nodeRuns, container) {
    for (const [node] of nodeRuns.entries()) {
      const rect = {
        minX: node.box.x,
        minY: node.box.y,
        maxX: node.box.x + node.box.contentWidth,
        maxY: node.box.y + node.box.contentHeight
      };
      let curr = node.parent;
      while (curr && curr !== container && isInlineDisplay2(curr.style.display)) {
        this.updateBox(curr, rect);
        curr = curr.parent;
      }
    }
    for (const [node, rect] of this.boundingBoxes.entries()) {
      node.box.x = rect.minX;
      node.box.y = rect.minY;
      node.box.contentWidth = rect.maxX - rect.minX;
      node.box.contentHeight = rect.maxY - rect.minY;
      node.box.borderBoxWidth = Math.max(node.box.borderBoxWidth, node.box.contentWidth);
      node.box.borderBoxHeight = Math.max(node.box.borderBoxHeight, node.box.contentHeight);
      node.box.marginBoxWidth = Math.max(node.box.marginBoxWidth, node.box.borderBoxWidth);
      node.box.marginBoxHeight = Math.max(node.box.marginBoxHeight, node.box.borderBoxHeight);
    }
  }
  /**
   * Update or create a bounding box for a node by incorporating a new rectangle.
   * Expands the existing bounding box to include the new rect.
   */
  updateBox(node, rect) {
    let current2 = this.boundingBoxes.get(node);
    if (!current2) {
      if (node.box.contentWidth > 0 || node.box.contentHeight > 0) {
        current2 = {
          minX: node.box.x,
          minY: node.box.y,
          maxX: node.box.x + node.box.contentWidth,
          maxY: node.box.y + node.box.contentHeight
        };
        current2.minX = Math.min(current2.minX, rect.minX);
        current2.minY = Math.min(current2.minY, rect.minY);
        current2.maxX = Math.max(current2.maxX, rect.maxX);
        current2.maxY = Math.max(current2.maxY, rect.maxY);
      } else {
        current2 = { ...rect };
      }
      this.boundingBoxes.set(node, current2);
    } else {
      current2.minX = Math.min(current2.minX, rect.minX);
      current2.minY = Math.min(current2.minY, rect.minY);
      current2.maxX = Math.max(current2.maxX, rect.maxX);
      current2.maxY = Math.max(current2.maxY, rect.maxY);
    }
  }
};

// src/layout/inline/font-baseline-calculator.ts
var DEFAULT_ASCENT_RATIO = 0.75;
function calculateBaseline(lineTop, fontSize, lineHeight, fontMetrics) {
  let ascent;
  if (fontMetrics) {
    const { metrics } = fontMetrics;
    const unitsPerEm = metrics.unitsPerEm;
    const ascentUnits = metrics.ascender;
    ascent = ascentUnits / unitsPerEm * fontSize;
  } else {
    ascent = fontSize * DEFAULT_ASCENT_RATIO;
  }
  const leading = lineHeight - fontSize;
  const halfLeading = leading / 2;
  return lineTop + halfLeading + ascent;
}

// src/layout/inline/run-placer.ts
var RunPlacer = class {
  constructor(fontEmbedder = null) {
    this.fontEmbedder = fontEmbedder;
    this.nodeRuns = /* @__PURE__ */ new Map();
    this.maxInlineEnd = 0;
  }
  /**
   * Place all items on a line, creating InlineRun objects for text and positioning box items.
   */
  placeRunsForLine(parts, lineContext) {
    if (parts.length === 0) {
      return;
    }
    const { lineTop, lineHeight, lineStartX, lineIndex, availableWidth, offsetShift, isLastLine, contentX, inlineOffsetStart } = lineContext;
    const lineWidth = parts.reduce((max, part) => Math.max(max, part.offset + part.item.width), 0);
    const currentAvailableWidth = Math.max(availableWidth, 0);
    const spaceCount = parts.reduce((count, part) => {
      if (part.item.kind === "space") {
        return count + (part.item.spaceCount ?? 1);
      }
      return count;
    }, 0);
    this.maxInlineEnd = Math.max(this.maxInlineEnd, lineStartX + lineWidth - contentX);
    for (const part of parts) {
      if (isBoxItem(part.item)) {
        const metrics = part.item.metrics;
        metrics.lineOffset = part.offset + offsetShift;
        placeInlineItem(metrics, contentX + inlineOffsetStart, lineTop);
        continue;
      }
      const node = part.item.node;
      if (!node || !part.item.text) {
        continue;
      }
      const fontSize = part.item.style?.fontSize ?? 16;
      const itemLineHeight = part.item.lineHeight ?? lineHeight;
      const fontFamily = part.item.style?.fontFamily ?? "sans-serif";
      const fontWeight = part.item.style?.fontWeight ?? 400;
      const fontStyle = part.item.style?.fontStyle ?? "normal";
      const fontMetrics = this.fontEmbedder?.getMetrics(fontFamily, fontWeight, fontStyle);
      const lineBaseline = calculateBaseline(lineTop, fontSize, itemLineHeight, fontMetrics);
      const startX = lineStartX + part.offset;
      const run = {
        lineIndex,
        startX,
        baseline: lineBaseline,
        text: part.item.text,
        width: part.item.width,
        lineWidth,
        targetWidth: currentAvailableWidth,
        spaceCount,
        isLastLine
      };
      if (!this.nodeRuns.has(node)) {
        node.box.x = startX;
        node.box.y = lineTop;
      } else {
        node.box.x = Math.min(node.box.x, startX);
        node.box.y = Math.min(node.box.y, lineTop);
      }
      node.box.baseline = lineBaseline;
      this.pushRun(node, run);
    }
  }
  /**
   * Get all collected node runs
   */
  getNodeRuns() {
    return this.nodeRuns;
  }
  /**
   * Get the maximum inline end position seen
   */
  getMaxInlineEnd() {
    return this.maxInlineEnd;
  }
  /**
   * Add a run to a node's run list
   */
  pushRun(node, run) {
    const existing = this.nodeRuns.get(node);
    if (existing) {
      existing.push(run);
    } else {
      this.nodeRuns.set(node, [run]);
    }
  }
};

// src/layout/debug.ts
var LAYOUT_DEBUG;
var initialize = (context) => {
  if (LAYOUT_DEBUG === void 0) {
    LAYOUT_DEBUG = context.env.getEnv("PAGYRA_DEBUG_LAYOUT") === "1";
  }
};
var createLayoutDebug = (context) => {
  initialize(context);
  return (...args) => {
    if (LAYOUT_DEBUG) {
      console.log(...args);
    }
  };
};

// src/layout/inline/layout.ts
function layoutInlineFormattingContext(options) {
  const { container, inlineNodes, context, floatContext, contentX, contentWidth } = options;
  container.establishesIFC = true;
  const layoutDebug = createLayoutDebug(context);
  const textAlign = container.style.display === "inline" /* Inline */ ? void 0 : resolveInlineTextAlign(container);
  const alignmentStrategy = getAlignmentStrategy(textAlign);
  const shouldApplyTextIndent = container.style.display !== "inline" /* Inline */;
  const resolvedTextIndent = shouldApplyTextIndent ? resolveLength(container.style.textIndent, contentWidth, { auto: "zero" }) : 0;
  let firstLineTextIndentPending = shouldApplyTextIndent && resolvedTextIndent !== 0;
  const layoutCallback = (node, width, ctx) => layoutInlineChildrenIfNeeded(node, width, ctx);
  const fragments = collectInlineFragments(inlineNodes, contentWidth, context, layoutCallback);
  const items = tokenizeFragments(fragments, context.env.fontEmbedder);
  let lineTop = options.startY;
  let lineHeight = Math.max(resolvedLineHeight(container.style), 0);
  let inlineOffset = floatContext.inlineOffsets(lineTop, lineTop + lineHeight, contentWidth);
  let availableWidth = Math.max(0, inlineOffset.end - inlineOffset.start);
  let cursorX = 0;
  let lineIndex = 0;
  const lineParts = [];
  const runPlacer = new RunPlacer(context.env.fontEmbedder);
  const placeRunsForLine = (parts, isLastLine) => {
    const offsetShift = alignmentStrategy.calculateOffset(
      parts.reduce((max, part) => Math.max(max, part.offset + part.item.width), 0),
      Math.max(availableWidth, 0)
    );
    runPlacer.placeRunsForLine(parts, {
      lineTop,
      lineHeight,
      lineStartX: contentX + inlineOffset.start + offsetShift,
      lineIndex,
      availableWidth,
      offsetShift,
      isLastLine,
      contentX,
      inlineOffsetStart: inlineOffset.start
    });
  };
  const commitLine = (isLastLine) => {
    if (lineParts.length === 0) {
      lineTop += lineHeight;
    } else {
      placeRunsForLine(lineParts, isLastLine);
      lineTop += lineHeight;
    }
    cursorX = 0;
    lineHeight = Math.max(resolvedLineHeight(container.style), 0);
    lineParts.length = 0;
    inlineOffset = floatContext.inlineOffsets(lineTop, lineTop + lineHeight, contentWidth);
    availableWidth = Math.max(0, inlineOffset.end - inlineOffset.start);
    lineIndex += 1;
  };
  for (let index = 0; index < items.length; index++) {
    const item = items[index];
    if (item.kind === "newline") {
      commitLine(false);
      continue;
    }
    let workingItem = item;
    while (workingItem) {
      if (availableWidth <= 0) {
        const nextLineTop = floatContext.nextUnblockedY(lineTop, lineTop + lineHeight);
        if (nextLineTop === null) {
          availableWidth = Math.max(0, contentWidth);
          inlineOffset = { start: 0, end: contentWidth };
        } else {
          lineTop = nextLineTop;
          inlineOffset = floatContext.inlineOffsets(lineTop, lineTop + lineHeight, contentWidth);
          availableWidth = Math.max(0, inlineOffset.end - inlineOffset.start);
          cursorX = 0;
          lineParts.length = 0;
          continue;
        }
      }
      if (lineParts.length === 0 && firstLineTextIndentPending) {
        cursorX += resolvedTextIndent;
        firstLineTextIndentPending = false;
      }
      const remaining = Math.max(availableWidth - cursorX, 0);
      if (workingItem.kind === "box") {
        if (lineParts.length > 0 && cursorX + workingItem.width > availableWidth) {
          commitLine(false);
          continue;
        }
        if (lineParts.length === 0 && workingItem.width > availableWidth) {
          const nextLineTop = floatContext.nextUnblockedY(lineTop, lineTop + lineHeight);
          if (nextLineTop === null) {
            lineParts.push({ item: workingItem, offset: cursorX });
            cursorX += workingItem.width;
            lineHeight = Math.max(lineHeight, workingItem.lineHeight);
            break;
          }
          lineTop = nextLineTop;
          inlineOffset = floatContext.inlineOffsets(lineTop, lineTop + lineHeight, contentWidth);
          availableWidth = Math.max(0, inlineOffset.end - inlineOffset.start);
          cursorX = 0;
          lineParts.length = 0;
          continue;
        }
        lineParts.push({ item: workingItem, offset: cursorX });
        cursorX += workingItem.width;
        lineHeight = Math.max(lineHeight, workingItem.lineHeight);
        break;
      }
      if (workingItem.kind === "word" && workingItem.width > remaining) {
        const mode = workingItem.style?.overflowWrap ?? "normal";
        if (mode !== "normal" && remaining > 0) {
          const [head, tail] = splitWordItemToken(workingItem, remaining);
          if (head) {
            lineParts.push({ item: head, offset: cursorX });
            cursorX += head.width;
            lineHeight = Math.max(lineHeight, head.lineHeight);
          }
          if (tail) {
            items.splice(index + 1, 0, tail);
          }
          workingItem = null;
          break;
        }
      }
      if (lineParts.length > 0 && cursorX + workingItem.width > availableWidth) {
        commitLine(false);
        continue;
      }
      if (lineParts.length === 0 && workingItem.width > availableWidth && workingItem.kind === "word") {
        const nextLineTop = floatContext.nextUnblockedY(lineTop, lineTop + lineHeight);
        if (nextLineTop === null) {
          lineParts.push({ item: workingItem, offset: cursorX });
          cursorX += workingItem.width;
          lineHeight = Math.max(lineHeight, workingItem.lineHeight);
          workingItem = null;
          break;
        }
        lineTop = nextLineTop;
        inlineOffset = floatContext.inlineOffsets(lineTop, lineTop + lineHeight, contentWidth);
        availableWidth = Math.max(0, inlineOffset.end - inlineOffset.start);
        cursorX = 0;
        lineParts.length = 0;
        continue;
      }
      lineParts.push({ item: workingItem, offset: cursorX });
      cursorX += workingItem.width;
      lineHeight = Math.max(lineHeight, workingItem.lineHeight);
      workingItem = null;
    }
  }
  if (lineParts.length > 0) {
    commitLine(true);
  }
  const nodeRuns = runPlacer.getNodeRuns();
  const boxCalculator = new BoundingBoxCalculator();
  boxCalculator.computeNodeBoxes(nodeRuns);
  boxCalculator.propagateBoundingBoxes(nodeRuns, container);
  return { newCursorY: lineTop };
}
function placeInlineItem(item, lineStartX, lineTop, context) {
  const { node } = item;
  const contentX = lineStartX + item.lineOffset + item.marginLeft + item.borderLeft + item.paddingLeft;
  const contentY = lineTop + item.marginTop + item.borderTop + item.paddingTop;
  const layoutDebug = context ? createLayoutDebug(context) : () => {
  };
  layoutDebug(`[placeInlineItem] node=${node.tagName ?? "(anonymous)"} lineStartX=${lineStartX} lineOffset=${item.lineOffset} marginLeft=${item.marginLeft} paddingLeft=${item.paddingLeft} borderLeft=${item.borderLeft} -> contentX=${contentX}`);
  const previousX = node.box.x;
  const previousY = node.box.y;
  node.box.x = contentX;
  node.box.y = contentY;
  node.box.baseline = contentY + item.contentHeight;
  const deltaX = node.box.x - previousX;
  const deltaY = node.box.y - previousY;
  if (deltaX !== 0 || deltaY !== 0) {
    offsetInlineDescendants(node, deltaX, deltaY);
  }
}
function offsetInlineDescendants(node, deltaX, deltaY) {
  for (const child of node.children) {
    child.shift(deltaX, deltaY);
  }
}
function layoutInlineChildrenIfNeeded(node, containerWidth, context) {
  if (!shouldLayoutInlineChildren(node)) {
    return null;
  }
  const inlineChildren = collectInlineParticipants(node);
  if (inlineChildren.length === 0) {
    return null;
  }
  const savedX = node.box.x;
  const savedY = node.box.y;
  node.box.x = 0;
  node.box.y = 0;
  for (const child of inlineChildren) {
    child.box.x = 0;
    child.box.y = 0;
  }
  const localFloatContext = new FloatContext();
  const result = layoutInlineFormattingContext({
    container: node,
    inlineNodes: inlineChildren,
    context,
    floatContext: localFloatContext,
    contentX: 0,
    contentWidth: Math.max(containerWidth, 0),
    startY: 0
  });
  const floatBottom = Math.max(localFloatContext.bottom("left"), localFloatContext.bottom("right"));
  const contentHeight = Math.max(result.newCursorY, floatBottom);
  let maxInlineEnd = 0;
  for (const child of inlineChildren) {
    const extent = inlineExtentWithinContainer(child, containerWidth);
    maxInlineEnd = Math.max(maxInlineEnd, extent.end);
  }
  node.box.x = savedX;
  node.box.y = savedY;
  return {
    contentWidth: Math.max(0, maxInlineEnd),
    contentHeight: Math.max(0, contentHeight)
  };
}

// src/layout/utils/inline-formatter.ts
var InlineFormatter = class {
  layout(request) {
    const floatContext = request.floatContext ?? new FloatContext();
    return layoutInlineFormattingContext({
      container: request.container,
      inlineNodes: request.inlineNodes,
      context: request.context,
      floatContext,
      contentX: request.contentX,
      contentWidth: request.contentWidth,
      startY: request.startY
    });
  }
};
var defaultInlineFormatter = new InlineFormatter();

// src/layout/utils/display-utils.ts
function isInlineLevel(node) {
  switch (node.style.display) {
    case "inline" /* Inline */:
    case "inline-block" /* InlineBlock */:
    case "inline-flex" /* InlineFlex */:
    case "inline-grid" /* InlineGrid */:
    case "inline-table" /* InlineTable */:
      return true;
    default:
      return false;
  }
}

// src/layout/utils/content-measurer.ts
var ContentMeasurer = class {
  constructor(layoutDebug) {
    this.layoutDebug = layoutDebug;
  }
  /**
   * Measures the intrinsic width of in-flow content within a node.
   * 
   * Calculates the minimum and maximum horizontal extents of all in-flow
   * children, taking into account their margins, borders, and padding.
   * 
   * @param node - The parent node whose content width to measure
   * @param referenceWidth - The reference width for percentage calculations
   * @param contentStartX - The X coordinate where content area begins
   * @returns Object containing the measured width and any left offset
   */
  measureInFlowWidth(node, referenceWidth, contentStartX) {
    let minStart = Number.POSITIVE_INFINITY;
    let maxEnd = Number.NEGATIVE_INFINITY;
    let hasContent = false;
    for (const child of node.children) {
      if (!inFlow(child)) {
        continue;
      }
      if (child.style.display === "none" /* None */) {
        continue;
      }
      const marginLeft = child.box.usedMarginLeft !== void 0 ? child.box.usedMarginLeft : resolveLength(child.style.marginLeft, referenceWidth, { auto: "zero" });
      const marginRight = child.box.usedMarginRight !== void 0 ? child.box.usedMarginRight : resolveLength(child.style.marginRight, referenceWidth, { auto: "zero" });
      const borderLeft = resolveLength(child.style.borderLeft, referenceWidth, { auto: "zero" });
      const borderRight = resolveLength(child.style.borderRight, referenceWidth, { auto: "zero" });
      const paddingLeft = resolveLength(child.style.paddingLeft, referenceWidth, { auto: "zero" });
      const paddingRight = resolveLength(child.style.paddingRight, referenceWidth, { auto: "zero" });
      const borderBoxWidth = child.box.borderBoxWidth || Math.max(0, child.box.contentWidth + paddingLeft + paddingRight + borderLeft + borderRight);
      const marginBoxWidth = borderBoxWidth + marginLeft + marginRight;
      const marginStart = child.box.x - paddingLeft - borderLeft - marginLeft;
      const relativeStart = marginStart - contentStartX;
      const relativeEnd = relativeStart + marginBoxWidth;
      this.layoutDebug(
        `[measureInFlowContentWidth] parent=${node.tagName ?? "(anonymous)"} child=${child.tagName ?? "(anonymous)"} marginStart=${marginStart} relativeStart=${relativeStart} marginBoxWidth=${marginBoxWidth} borderBoxWidth=${borderBoxWidth} child.box.x=${child.box.x} contentStartX=${contentStartX}`
      );
      minStart = Math.min(minStart, relativeStart);
      maxEnd = Math.max(maxEnd, relativeEnd);
      hasContent = true;
    }
    if (!hasContent) {
      return { width: 0, leftOffset: 0 };
    }
    if (!Number.isFinite(minStart)) {
      minStart = 0;
    }
    if (!Number.isFinite(maxEnd)) {
      maxEnd = minStart;
    }
    const width = Math.max(0, maxEnd - minStart);
    const leftOffset = minStart > 0 ? minStart : 0;
    return { width, leftOffset };
  }
  /**
   * Shifts all in-flow children horizontally by the specified amount.
   * 
   * This is used to adjust child positions when the parent's content width
   * changes (e.g., for inline-block shrink-to-fit).
   * 
   * @param node - The parent node whose children to shift
   * @param deltaX - The horizontal offset to apply (negative shifts left)
   */
  shiftInFlowChildrenX(node, deltaX) {
    if (deltaX === 0) {
      return;
    }
    for (const child of node.children) {
      if (!inFlow(child)) {
        continue;
      }
      if (child.style.display === "none" /* None */) {
        continue;
      }
      child.shift(-deltaX, 0);
    }
  }
};

// src/layout/strategies/block.ts
var BlockLayoutStrategy = class {
  constructor() {
    this.supportedDisplays = /* @__PURE__ */ new Set(["block" /* Block */, "flow-root" /* FlowRoot */, "inline-block" /* InlineBlock */, "table-cell" /* TableCell */]);
  }
  canLayout(node) {
    return this.supportedDisplays.has(node.style.display);
  }
  layout(node, context) {
    const layoutDebug = createLayoutDebug(context);
    const contentMeasurer = new ContentMeasurer(layoutDebug);
    const cb = containingBlock(node, context.env.viewport);
    node.establishesBFC = establishesBFC(node);
    let contentWidth = resolveWidthBlock(node, cb.width);
    const debugTag = node.tagName ?? "(anonymous)";
    if (node.style.display === "inline-block" /* InlineBlock */) {
      layoutDebug(
        `[BlockLayout] start inline-block tag=${debugTag} style.width=${node.style.width} resolvedContentWidth=${contentWidth} cb.width=${cb.width}`
      );
    }
    const availableWidth = contentWidth;
    node.box.contentWidth = contentWidth;
    const horizontalExtras = horizontalNonContent(node, contentWidth);
    const horizontalMarginSize = horizontalMargin(node, contentWidth);
    node.box.borderBoxWidth = contentWidth + horizontalExtras;
    node.box.marginBoxWidth = node.box.borderBoxWidth + horizontalMarginSize;
    const paddingLeft = resolveLength(node.style.paddingLeft, contentWidth, { auto: "zero" });
    const borderLeft = resolveLength(node.style.borderLeft, contentWidth, { auto: "zero" });
    const paddingTop = resolveLength(node.style.paddingTop, contentWidth, { auto: "zero" });
    const borderTop = resolveLength(node.style.borderTop, contentWidth, { auto: "zero" });
    const contentX = node.box.x + borderLeft + paddingLeft;
    const collapseTopWithChildren = canCollapseMarginStart(node, contentWidth);
    const collapseBottomWithChildren = canCollapseMarginEnd(node, contentWidth);
    const firstCollapsibleChild = collapseTopWithChildren ? findFirstMarginCollapsibleChild(node) : void 0;
    const lastCollapsibleChild = collapseBottomWithChildren ? findLastMarginCollapsibleChild(node) : void 0;
    const topCollapseAmount = collapseTopWithChildren && firstCollapsibleChild ? effectiveMarginTop(firstCollapsibleChild, contentWidth) : 0;
    const bottomCollapseAmount = collapseBottomWithChildren && lastCollapsibleChild ? effectiveMarginBottom(lastCollapsibleChild, contentWidth) : 0;
    let cursorY = node.box.y + paddingTop + borderTop;
    let previousBottomMargin = 0;
    const floatContext = new FloatContext();
    const children = node.children;
    for (let index = 0; index < children.length; index++) {
      const child = children[index];
      if (child.style.display === "none" /* None */) {
        continue;
      }
      if (child.style.float !== "none" /* None */) {
        cursorY = clearForBlock(child, floatContext, cursorY);
        placeFloat({
          node: child,
          floatContext,
          context,
          contentX,
          contentWidth,
          startY: cursorY
        });
        previousBottomMargin = 0;
        continue;
      }
      if (!inFlow(child)) {
        continue;
      }
      if (isInlineLevel(child)) {
        const inlineNodes = [child];
        let lookahead = index + 1;
        while (lookahead < children.length) {
          const candidate = children[lookahead];
          if (candidate.style.float !== "none" /* None */ || !isInlineLevel(candidate)) {
            break;
          }
          inlineNodes.push(candidate);
          lookahead += 1;
        }
        const result = defaultInlineFormatter.layout({
          container: node,
          inlineNodes,
          context,
          floatContext,
          contentX,
          contentWidth,
          startY: cursorY
        });
        cursorY = result.newCursorY;
        previousBottomMargin = 0;
        index = lookahead - 1;
        continue;
      }
      const childMarginTopRaw = resolveLength(child.style.marginTop, contentWidth, { auto: "zero" });
      const childMarginBottomRaw = resolveLength(child.style.marginBottom, contentWidth, { auto: "zero" });
      const collapsedMarginTop = effectiveMarginTop(child, contentWidth);
      const collapsedMarginBottom = effectiveMarginBottom(child, contentWidth);
      let gap = collapsedGapBetween(previousBottomMargin, collapsedMarginTop, node.establishesBFC);
      if (collapseTopWithChildren && child === firstCollapsibleChild) {
        gap -= topCollapseAmount;
      }
      child.box.x = contentX;
      child.box.y = cursorY + gap;
      context.layoutChild(child);
      const { marginLeft: usedMarginLeft, marginRight: usedMarginRight } = resolveBlockAutoMargins(
        contentWidth,
        child.box.borderBoxWidth,
        child.style.marginLeft,
        child.style.marginRight
      );
      child.box.usedMarginLeft = usedMarginLeft;
      child.box.usedMarginRight = usedMarginRight;
      const deltaX = usedMarginLeft;
      if (deltaX !== 0) {
        child.shift(deltaX, 0);
      }
      child.box.x = contentX + usedMarginLeft;
      child.box.marginBoxWidth = child.box.borderBoxWidth + usedMarginLeft + usedMarginRight;
      child.box.marginBoxHeight = child.box.borderBoxHeight + childMarginTopRaw + childMarginBottomRaw;
      previousBottomMargin = collapsedMarginBottom;
      cursorY = child.box.y + child.box.borderBoxHeight;
      if (collapseBottomWithChildren && child === lastCollapsibleChild) {
        cursorY += collapsedMarginBottom - bottomCollapseAmount;
        previousBottomMargin = 0;
      }
    }
    const measurement = contentMeasurer.measureInFlowWidth(node, contentWidth, contentX);
    if (Number.isFinite(measurement.width)) {
      const intrinsicWidth = Math.max(0, measurement.width);
      node.box.scrollWidth = Math.max(node.box.scrollWidth, intrinsicWidth);
      if (node.style.display === "inline-block" /* InlineBlock */ && node.style.width === "auto") {
        const minWidth = node.style.minWidth !== void 0 ? resolveLength(node.style.minWidth, cb.width, { auto: "zero" }) : void 0;
        const maxWidth = node.style.maxWidth !== void 0 ? resolveLength(node.style.maxWidth, cb.width, { auto: "reference" }) : void 0;
        let targetContentWidth = intrinsicWidth;
        targetContentWidth = Math.min(targetContentWidth, availableWidth);
        if (minWidth !== void 0) {
          targetContentWidth = Math.max(targetContentWidth, minWidth);
        }
        if (maxWidth !== void 0) {
          targetContentWidth = Math.min(targetContentWidth, maxWidth);
        }
        targetContentWidth = Math.max(0, targetContentWidth);
        if (node.style.display === "inline-block" /* InlineBlock */) {
          layoutDebug(
            `[BlockLayout] intrinsic measurement tag=${debugTag} intrinsic=${intrinsicWidth} current=${node.box.contentWidth} horizontalExtras=${horizontalExtras} available=${availableWidth}`
          );
        }
        if (measurement.leftOffset > 0) {
          layoutDebug(
            `[BlockLayout] shifting inline-block children tag=${debugTag} offset=${measurement.leftOffset}`
          );
          contentMeasurer.shiftInFlowChildrenX(node, measurement.leftOffset);
        }
        if (targetContentWidth !== node.box.contentWidth) {
          node.box.contentWidth = targetContentWidth;
          contentWidth = targetContentWidth;
          node.box.borderBoxWidth = node.box.contentWidth + horizontalExtras;
          node.box.marginBoxWidth = node.box.borderBoxWidth + horizontalMarginSize;
          if (node.style.display === "inline-block" /* InlineBlock */) {
            layoutDebug(
              `[BlockLayout] updated inline-block tag=${debugTag} newContentWidth=${node.box.contentWidth} borderBoxWidth=${node.box.borderBoxWidth}`
            );
          }
        }
      }
    }
    const floatBottom = Math.max(floatContext.bottom("left"), floatContext.bottom("right"));
    const effectiveCursor = Math.max(cursorY, floatBottom);
    node.box.contentHeight = Math.max(0, effectiveCursor - (node.box.y + borderTop) - paddingTop);
    if (node.style.height !== "auto") {
      node.box.contentHeight = resolveLength(node.style.height, cb.height, { auto: "zero" });
    }
    const verticalExtras = verticalNonContent(node, contentWidth);
    node.box.borderBoxHeight = node.box.contentHeight + verticalExtras;
    node.box.marginBoxHeight = node.box.borderBoxHeight + resolveLength(node.style.marginTop, contentWidth, { auto: "zero" }) + resolveLength(node.style.marginBottom, contentWidth, { auto: "zero" });
    finalizeOverflow(node);
  }
};

// src/layout/utils/gap-calculator.ts
function calculateTotalGap(gap, itemCount) {
  if (itemCount <= 1 || gap <= 0) {
    return 0;
  }
  return gap * (itemCount - 1);
}
function calculateAvailableSpace(totalSpace, gap, itemCount) {
  const totalGap = calculateTotalGap(gap, itemCount);
  return Math.max(0, totalSpace - totalGap);
}
function calculateItemOffsets(itemSizes, gap) {
  const offsets = [];
  let offset = 0;
  for (let i = 0; i < itemSizes.length; i++) {
    offsets.push(offset);
    offset += itemSizes[i];
    if (i < itemSizes.length - 1) {
      offset += gap;
    }
  }
  return offsets;
}
function calculateTrackOffsets(trackSizes, gap) {
  return calculateItemOffsets(trackSizes, gap);
}
var GapCalculator = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Get gap for main axis based on direction.
   * 
   * @param isRow - True if main axis is horizontal (row), false for vertical (column)
   * @returns Gap value in pixels
   */
  getMainAxisGap(isRow) {
    return isRow ? this.config.columnGap : this.config.rowGap;
  }
  /**
   * Get gap for cross axis based on direction.
   * 
   * @param isRow - True if main axis is horizontal (row), false for vertical (column)
   * @returns Gap value in pixels
   */
  getCrossAxisGap(isRow) {
    return isRow ? this.config.rowGap : this.config.columnGap;
  }
  /**
   * Calculate total gap for main axis.
   * 
   * @param isRow - True if main axis is horizontal (row)
   * @param itemCount - Number of items in main axis
   * @returns Total gap space consumed in pixels
   */
  calculateMainAxisTotalGap(isRow, itemCount) {
    const gap = this.getMainAxisGap(isRow);
    return calculateTotalGap(gap, itemCount);
  }
  /**
   * Calculate available space in main axis after gaps.
   * 
   * @param isRow - True if main axis is horizontal (row)
   * @param totalSpace - Total available space in pixels
   * @param itemCount - Number of items in main axis
   * @returns Available space for content in pixels
   */
  calculateMainAxisAvailableSpace(isRow, totalSpace, itemCount) {
    const gap = this.getMainAxisGap(isRow);
    return calculateAvailableSpace(totalSpace, gap, itemCount);
  }
};

// src/layout/strategies/flex.ts
function blockifyFlexItemDisplay(display) {
  switch (display) {
    case "inline" /* Inline */:
    case "inline-block" /* InlineBlock */:
      return "block" /* Block */;
    case "inline-flex" /* InlineFlex */:
      return "flex" /* Flex */;
    case "inline-grid" /* InlineGrid */:
      return "grid" /* Grid */;
    case "inline-table" /* InlineTable */:
      return "table" /* Table */;
    default:
      return display;
  }
}
function allowsPreferredShrink(originalDisplay, effectiveDisplay) {
  switch (effectiveDisplay) {
    case "flex" /* Flex */:
    case "inline-flex" /* InlineFlex */:
    case "grid" /* Grid */:
    case "inline-grid" /* InlineGrid */:
      return false;
    default:
      break;
  }
  if (effectiveDisplay === originalDisplay) {
    return true;
  }
  return originalDisplay === "inline" /* Inline */;
}
var FlexLayoutStrategy = class {
  constructor() {
    this.supportedDisplays = /* @__PURE__ */ new Set(["flex" /* Flex */, "inline-flex" /* InlineFlex */]);
  }
  canLayout(node) {
    return this.supportedDisplays.has(node.style.display);
  }
  layout(node, context) {
    const cb = containingBlock(node, context.env.viewport);
    const isRow = isRowDirection(node.style.flexDirection);
    const cbMain = isRow ? cb.width : cb.height;
    const cbCross = isRow ? cb.height : cb.width;
    const specifiedMain = resolveFlexSize(isRow ? node.style.width : node.style.height, cbMain);
    const specifiedCross = resolveFlexSize(isRow ? node.style.height : node.style.width, cbCross);
    const rowGap = node.style.rowGap ?? 0;
    const columnGap = node.style.columnGap ?? 0;
    const gapCalculator = new GapCalculator({ rowGap, columnGap });
    const mainAxisGap = gapCalculator.getMainAxisGap(isRow);
    const boxMetrics = resolveBoxMetrics(node, cb.width, cb.height);
    if (isRow) {
      node.box.contentWidth = resolveInitialDimension(specifiedMain, cbMain);
      node.box.contentHeight = resolveInitialDimension(specifiedCross, cbCross);
    } else {
      node.box.contentWidth = resolveInitialDimension(specifiedCross, cbCross);
      node.box.contentHeight = resolveInitialDimension(specifiedMain, cbMain);
    }
    node.box.borderBoxWidth = node.box.contentWidth + boxMetrics.paddingLeft + boxMetrics.paddingRight + boxMetrics.borderLeft + boxMetrics.borderRight;
    node.box.borderBoxHeight = node.box.contentHeight + boxMetrics.paddingTop + boxMetrics.paddingBottom + boxMetrics.borderTop + boxMetrics.borderBottom;
    node.box.scrollWidth = Math.max(node.box.scrollWidth, node.box.contentWidth);
    node.box.scrollHeight = Math.max(node.box.scrollHeight, node.box.contentHeight);
    const alignContainer = node.style.alignItems ?? "stretch" /* Stretch */;
    const items = [];
    let totalMain = 0;
    let maxCrossContribution = 0;
    for (const child of node.children) {
      if (child.style.display === "none" /* None */) {
        continue;
      }
      const originalDisplay = child.style.display;
      const blockifiedDisplay = blockifyFlexItemDisplay(originalDisplay);
      const displayMutated = blockifiedDisplay !== originalDisplay;
      if (displayMutated) {
        child.style.display = blockifiedDisplay;
      }
      try {
        context.layoutChild(child);
        const marginLeft = resolveLength(child.style.marginLeft, cb.width, { auto: "zero" });
        const marginRight = resolveLength(child.style.marginRight, cb.width, { auto: "zero" });
        const marginTop = resolveLength(child.style.marginTop, cb.height, { auto: "zero" });
        const marginBottom = resolveLength(child.style.marginBottom, cb.height, { auto: "zero" });
        const mainMarginStart = isRow ? marginLeft : marginTop;
        const mainMarginEnd = isRow ? marginRight : marginBottom;
        const crossMarginStart = isRow ? marginTop : marginLeft;
        const crossMarginEnd = isRow ? marginBottom : marginRight;
        let mainSize = isRow ? child.box.borderBoxWidth : child.box.borderBoxHeight;
        const childDisplay = blockifiedDisplay;
        const allowPreferredShrink = allowsPreferredShrink(originalDisplay, childDisplay);
        if (isRow && allowPreferredShrink && isAutoMainSize(child.style.width)) {
          const preferredContent = computePreferredInlineWidth(child);
          if (preferredContent !== void 0 && preferredContent >= 0) {
            const minWidth = child.style.minWidth !== void 0 ? resolveLength(child.style.minWidth, cb.width, { auto: "zero" }) : void 0;
            const maxWidth = child.style.maxWidth !== void 0 ? resolveLength(child.style.maxWidth, cb.width, { auto: "reference" }) : void 0;
            let targetContentWidth = preferredContent;
            if (minWidth !== void 0) {
              targetContentWidth = Math.max(targetContentWidth, minWidth);
            }
            if (maxWidth !== void 0) {
              targetContentWidth = Math.min(targetContentWidth, maxWidth);
            }
            if (targetContentWidth < child.box.contentWidth) {
              const paddingLeft = resolveLength(child.style.paddingLeft, cb.width, { auto: "zero" });
              const paddingRight = resolveLength(child.style.paddingRight, cb.width, { auto: "zero" });
              const borderLeft = resolveLength(child.style.borderLeft, cb.width, { auto: "zero" });
              const borderRight = resolveLength(child.style.borderRight, cb.width, { auto: "zero" });
              child.box.contentWidth = targetContentWidth;
              child.box.borderBoxWidth = targetContentWidth + paddingLeft + paddingRight + borderLeft + borderRight;
              child.box.marginBoxWidth = child.box.borderBoxWidth + marginLeft + marginRight;
              child.box.scrollWidth = Math.max(child.box.scrollWidth, child.box.contentWidth);
              mainSize = child.box.borderBoxWidth;
            }
          }
        }
        let crossSize = isRow ? child.box.borderBoxHeight : child.box.borderBoxWidth;
        if (!isRow && allowPreferredShrink) {
          const alignSelf = resolveItemAlignment(child.style.alignSelf, alignContainer);
          const autoWidth = isAutoLength(child.style.width);
          if (alignSelf !== "stretch" /* Stretch */ && autoWidth) {
            const preferredContent = computePreferredInlineWidth(child);
            if (preferredContent !== void 0 && preferredContent > 0) {
              const widthRef = cb.width;
              const paddingLeft = resolveLength(child.style.paddingLeft, widthRef, { auto: "zero" });
              const paddingRight = resolveLength(child.style.paddingRight, widthRef, { auto: "zero" });
              const borderLeft = resolveLength(child.style.borderLeft, widthRef, { auto: "zero" });
              const borderRight = resolveLength(child.style.borderRight, widthRef, { auto: "zero" });
              const minWidth = child.style.minWidth !== void 0 ? resolveLength(child.style.minWidth, widthRef, { auto: "zero" }) : void 0;
              const maxWidth = child.style.maxWidth !== void 0 ? resolveLength(child.style.maxWidth, widthRef, { auto: "reference" }) : void 0;
              let targetContentWidth = Math.min(preferredContent, child.box.contentWidth);
              if (minWidth !== void 0) {
                targetContentWidth = Math.max(targetContentWidth, minWidth);
              }
              if (maxWidth !== void 0) {
                targetContentWidth = Math.min(targetContentWidth, maxWidth);
              }
              targetContentWidth = Math.max(0, targetContentWidth);
              if (targetContentWidth < child.box.contentWidth) {
                child.box.contentWidth = targetContentWidth;
                const horizontalExtras = paddingLeft + paddingRight + borderLeft + borderRight;
                const newBorderBoxWidth = targetContentWidth + horizontalExtras;
                child.box.borderBoxWidth = newBorderBoxWidth;
                child.box.marginBoxWidth = newBorderBoxWidth + marginLeft + marginRight;
                child.box.scrollWidth = Math.max(child.box.scrollWidth, targetContentWidth);
                crossSize = newBorderBoxWidth;
              }
            }
          }
        }
        const mainContribution = mainSize + mainMarginStart + mainMarginEnd;
        const crossContribution = crossSize + crossMarginStart + crossMarginEnd;
        items.push({
          node: child,
          mainMarginStart,
          mainMarginEnd,
          crossMarginStart,
          crossMarginEnd,
          mainSize,
          crossSize,
          mainContribution,
          crossContribution
        });
        totalMain += mainContribution;
        maxCrossContribution = Math.max(maxCrossContribution, crossContribution);
      } finally {
        if (displayMutated) {
          child.style.display = originalDisplay;
        }
      }
    }
    const gapSpace = calculateTotalGap(mainAxisGap, items.length);
    const totalMainWithGaps = totalMain + gapSpace;
    let containerMainSize;
    if (specifiedMain !== void 0) {
      containerMainSize = specifiedMain;
    } else {
      const reference = Number.isFinite(cbMain) && cbMain > 0 ? cbMain : totalMainWithGaps;
      containerMainSize = Math.max(reference, totalMainWithGaps);
    }
    let containerCrossSize;
    if (specifiedCross !== void 0) {
      containerCrossSize = Math.max(specifiedCross, maxCrossContribution);
    } else if (!isRow) {
      const referenceCross = Number.isFinite(cbCross) && cbCross > 0 ? cbCross : maxCrossContribution;
      containerCrossSize = Math.max(referenceCross, maxCrossContribution);
    } else {
      containerCrossSize = maxCrossContribution;
    }
    const minCrossValue = isRow ? node.style.minHeight : node.style.minWidth;
    const maxCrossValue = isRow ? node.style.maxHeight : node.style.maxWidth;
    const minCross = minCrossValue !== void 0 ? resolveLength(minCrossValue, cbCross, { auto: "zero" }) : void 0;
    const maxCross = maxCrossValue !== void 0 ? resolveLength(maxCrossValue, cbCross, { auto: "reference" }) : void 0;
    if (minCross !== void 0) {
      containerCrossSize = Math.max(containerCrossSize, minCross);
    }
    if (maxCross !== void 0) {
      containerCrossSize = Math.min(containerCrossSize, maxCross);
    }
    const justify = node.style.justifyContent ?? "flex-start" /* FlexStart */;
    const align = alignContainer;
    const freeSpaceAfterGaps = containerMainSize - totalMainWithGaps;
    const { offset: initialOffset, gap: justifyGap } = resolveJustifySpacing(justify, freeSpaceAfterGaps, items.length);
    let cursor = initialOffset;
    for (let index = 0; index < items.length; index++) {
      const item = items[index];
      const alignSelf = resolveItemAlignment(item.node.style.alignSelf, align);
      const crossOffset = computeCrossOffset(alignSelf, containerCrossSize, item.crossSize, item.crossMarginStart, item.crossMarginEnd);
      const previousX = item.node.box.x;
      const previousY = item.node.box.y;
      if (isRow) {
        item.node.box.x = boxMetrics.contentBoxX + cursor + item.mainMarginStart;
        item.node.box.y = boxMetrics.contentBoxY + crossOffset + item.crossMarginStart;
      } else {
        item.node.box.x = boxMetrics.contentBoxX + crossOffset + item.crossMarginStart;
        item.node.box.y = boxMetrics.contentBoxY + cursor + item.mainMarginStart;
      }
      offsetLayoutSubtree(item.node, item.node.box.x - previousX, item.node.box.y - previousY);
      cursor += item.mainContribution;
      if (index < items.length - 1) {
        cursor += mainAxisGap + justifyGap;
      }
    }
    if (isRow) {
      node.box.contentWidth = containerMainSize;
      node.box.contentHeight = containerCrossSize;
    } else {
      node.box.contentWidth = containerCrossSize;
      node.box.contentHeight = containerMainSize;
    }
    node.box.borderBoxWidth = node.box.contentWidth + boxMetrics.paddingLeft + boxMetrics.paddingRight + boxMetrics.borderLeft + boxMetrics.borderRight;
    node.box.borderBoxHeight = node.box.contentHeight + boxMetrics.paddingTop + boxMetrics.paddingBottom + boxMetrics.borderTop + boxMetrics.borderBottom;
    node.box.scrollWidth = node.box.contentWidth;
    node.box.scrollHeight = node.box.contentHeight;
  }
};
function resolveInitialDimension(specified, fallback) {
  if (specified !== void 0 && Number.isFinite(specified)) {
    return Math.max(specified, 0);
  }
  if (Number.isFinite(fallback)) {
    return Math.max(fallback, 0);
  }
  return 0;
}
function resolveFlexSize(value, reference) {
  if (value === void 0) {
    return void 0;
  }
  if (typeof value === "number") {
    return value;
  }
  if (value === "auto" || isAutoLength(value)) {
    return void 0;
  }
  return resolveLength(value, reference, { auto: "reference" });
}
function resolveItemAlignment(alignSelf, containerAlign) {
  if (alignSelf && alignSelf !== "auto") {
    return alignSelf;
  }
  return containerAlign;
}
function computeCrossOffset(alignment, containerSize, itemSize, marginStart, marginEnd) {
  const total = itemSize + marginStart + marginEnd;
  const reference = Number.isFinite(containerSize) ? containerSize : total;
  const freeSpace = reference - total;
  if (freeSpace <= 0) {
    return 0;
  }
  switch (alignment) {
    case "center" /* Center */:
      return freeSpace / 2;
    case "flex-end" /* FlexEnd */:
      return freeSpace;
    default:
      return 0;
  }
}
function resolveJustifySpacing(justify, freeSpace, itemCount) {
  if (itemCount <= 0) {
    return { offset: 0, gap: 0 };
  }
  const clamped = Number.isFinite(freeSpace) ? Math.max(freeSpace, 0) : 0;
  switch (justify) {
    case "center" /* Center */:
      return { offset: clamped / 2, gap: 0 };
    case "flex-end" /* FlexEnd */:
    case "end" /* End */:
    case "right" /* Right */:
      return { offset: clamped, gap: 0 };
    case "space-between" /* SpaceBetween */:
      if (itemCount === 1) {
        return { offset: 0, gap: 0 };
      }
      return { offset: 0, gap: clamped / (itemCount - 1) };
    case "space-around" /* SpaceAround */: {
      const gap = clamped / itemCount;
      return { offset: gap / 2, gap };
    }
    case "space-evenly" /* SpaceEvenly */: {
      const gap = clamped / (itemCount + 1);
      return { offset: gap, gap };
    }
    default:
      return { offset: 0, gap: 0 };
  }
}
function isRowDirection(direction) {
  return direction === "row" || direction === "row-reverse";
}
function isAutoMainSize(value) {
  if (value === void 0) {
    return true;
  }
  if (typeof value === "number") {
    return false;
  }
  if (value === "auto") {
    return true;
  }
  return isAutoLength(value);
}
function computePreferredInlineWidth(node) {
  let maxWidth = 0;
  node.walk((desc) => {
    if (desc.inlineRuns && desc.inlineRuns.length > 0) {
      const localMax = desc.inlineRuns.reduce(
        (max, run) => Math.max(max, run.lineWidth ?? run.width),
        0
      );
      if (localMax > maxWidth) {
        maxWidth = localMax;
      }
      return;
    }
    if (!desc.lineBoxes || desc.lineBoxes.length === 0) {
      return;
    }
    for (const line of desc.lineBoxes) {
      if (!line) {
        continue;
      }
      const width = typeof line.width === "number" ? line.width : 0;
      if (width > maxWidth) {
        maxWidth = width;
      }
    }
  });
  return maxWidth > 0 ? maxWidth : void 0;
}
function offsetLayoutSubtree(node, deltaX, deltaY) {
  if (deltaX === 0 && deltaY === 0) {
    return;
  }
  node.walk((desc) => {
    if (desc === node) {
      return;
    }
    desc.box.x += deltaX;
    desc.box.y += deltaY;
    desc.box.baseline += deltaY;
    if (desc.inlineRuns && desc.inlineRuns.length > 0) {
      for (const run of desc.inlineRuns) {
        run.startX += deltaX;
        run.baseline += deltaY;
      }
    }
  });
}

// src/layout/strategies/grid.ts
function isRepeatTrack(def) {
  return typeof def === "object" && def !== null && "kind" in def && def.kind === "repeat";
}
function isAutoRepeatTrack(def) {
  return typeof def === "object" && def !== null && "kind" in def && def.kind === "repeat-auto";
}
function trackMinSize(track) {
  switch (track.kind) {
    case "fixed":
      return Math.max(0, track.size);
    case "flex":
      return Math.max(0, track.min ?? 0);
    case "auto":
      return Math.max(0, track.min ?? 0);
    default:
      return 0;
  }
}
function trackFlex(track) {
  return track.kind === "flex" ? Math.max(0, track.flex) : 0;
}
function cloneTrackSize(track) {
  if (track.kind === "fixed") {
    return { kind: "fixed", size: track.size };
  }
  if (track.kind === "flex") {
    return {
      kind: "flex",
      flex: track.flex,
      min: track.min,
      max: track.max
    };
  }
  return {
    kind: "auto",
    min: track.min,
    max: track.max
  };
}
function flattenTrackDefinitions(definitions, childCount, availableWidth, columnGap) {
  if (definitions.length === 0) {
    return [];
  }
  const tracks = [];
  for (const def of definitions) {
    if (isRepeatTrack(def)) {
      for (let i = 0; i < def.count; i++) {
        tracks.push(cloneTrackSize(def.track));
      }
      continue;
    }
    if (isAutoRepeatTrack(def)) {
      const minSize = trackMinSize(def.track);
      let count = childCount || 1;
      if (minSize > 0) {
        const unit = minSize + columnGap;
        if (unit > 0) {
          count = Math.max(1, Math.floor((availableWidth + columnGap) / unit));
        }
      }
      if (def.mode === "auto-fit" && childCount > 0) {
        count = Math.min(count, childCount);
      }
      for (let i = 0; i < count; i++) {
        tracks.push(cloneTrackSize(def.track));
      }
      continue;
    }
    tracks.push(cloneTrackSize(def));
  }
  return tracks;
}
function resolveColumnWidths(tracks, contentWidth, columnGap) {
  const columnCount = tracks.length;
  if (columnCount === 0) {
    return [];
  }
  const gapTotal = calculateTotalGap(columnGap, columnCount);
  const available = Math.max(0, contentWidth - gapTotal);
  const minSizes = tracks.map((track) => trackMinSize(track));
  const flexFactors = tracks.map((track) => trackFlex(track));
  const totalMin = minSizes.reduce((sum, size) => sum + size, 0);
  const totalFlex = flexFactors.reduce((sum, flex) => sum + flex, 0);
  const leftover = Math.max(0, available - totalMin);
  return tracks.map((track, index) => {
    switch (track.kind) {
      case "fixed":
        return Math.max(0, track.size);
      case "flex": {
        let size = minSizes[index];
        if (totalFlex > 0 && flexFactors[index] > 0) {
          size += flexFactors[index] / totalFlex * leftover;
        }
        if (track.max !== void 0) {
          size = Math.min(size, track.max);
        }
        return Math.max(0, size);
      }
      case "auto": {
        let size = minSizes[index];
        if (track.max !== void 0 && size > track.max) {
          size = track.max;
        }
        return Math.max(0, size);
      }
      default:
        return available / columnCount;
    }
  });
}
var GridLayoutStrategy = class {
  constructor() {
    this.supportedDisplays = /* @__PURE__ */ new Set(["grid" /* Grid */, "inline-grid" /* InlineGrid */]);
  }
  canLayout(node) {
    return this.supportedDisplays.has(node.style.display);
  }
  layout(node, context) {
    const cb = containingBlock(node, context.env.viewport);
    const baseContentWidth = resolveWidthBlock(node, cb.width);
    node.box.contentWidth = baseContentWidth;
    const horizontalExtras = horizontalNonContent(node, baseContentWidth);
    node.box.borderBoxWidth = baseContentWidth + horizontalExtras;
    node.box.marginBoxWidth = node.box.borderBoxWidth + horizontalMargin(node, baseContentWidth);
    const paddingLeft = resolveLength(node.style.paddingLeft, baseContentWidth, { auto: "zero" });
    const paddingTop = resolveLength(node.style.paddingTop, baseContentWidth, { auto: "zero" });
    const borderLeft = resolveLength(node.style.borderLeft, baseContentWidth, { auto: "zero" });
    const borderTop = resolveLength(node.style.borderTop, baseContentWidth, { auto: "zero" });
    const contentOriginX = node.box.x + borderLeft + paddingLeft;
    const contentOriginY = node.box.y + borderTop + paddingTop;
    const columnGap = node.style.columnGap ?? 0;
    const rowGap = node.style.rowGap ?? 0;
    const flattenedTracks = flattenTrackDefinitions(
      node.style.trackListColumns,
      node.children.length,
      baseContentWidth,
      columnGap
    );
    const tracks = flattenedTracks.length > 0 ? flattenedTracks : [{ kind: "flex", flex: 1 }];
    const columnWidths = resolveColumnWidths(tracks, baseContentWidth, columnGap);
    const totalColumnWidth = columnWidths.reduce((sum, width) => sum + width, 0) + calculateTotalGap(columnGap, columnWidths.length);
    const resolvedContentWidth = columnWidths.length > 0 ? Math.max(baseContentWidth, totalColumnWidth) : baseContentWidth;
    node.box.contentWidth = resolvedContentWidth;
    node.box.borderBoxWidth = resolvedContentWidth + horizontalExtras;
    node.box.marginBoxWidth = node.box.borderBoxWidth + horizontalMargin(node, resolvedContentWidth);
    const columnOffsets = calculateTrackOffsets(columnWidths, columnGap);
    let contentHeight = 0;
    let currentRowTop = contentOriginY;
    let currentRowHeight = 0;
    let columnIndex = 0;
    let rowCount = 0;
    for (const child of node.children) {
      if (child.style.display === "none" /* None */) {
        continue;
      }
      const columnWidth = columnWidths[columnIndex] ?? columnWidths[columnWidths.length - 1] ?? baseContentWidth;
      const columnX = contentOriginX + (columnOffsets[columnIndex] ?? 0);
      child.box.x = columnX;
      child.box.y = currentRowTop;
      const originalContentWidth = node.box.contentWidth;
      node.box.contentWidth = columnWidth;
      context.layoutChild(child);
      node.box.contentWidth = originalContentWidth;
      child.box.x = columnX;
      child.box.y = currentRowTop;
      currentRowHeight = Math.max(currentRowHeight, child.box.borderBoxHeight);
      columnIndex += 1;
      if (columnIndex >= columnWidths.length) {
        rowCount += 1;
        contentHeight += currentRowHeight;
        currentRowTop += currentRowHeight + rowGap;
        currentRowHeight = 0;
        columnIndex = 0;
      }
    }
    if (columnIndex !== 0) {
      rowCount += 1;
      contentHeight += currentRowHeight;
    }
    const totalRowGap = calculateTotalGap(rowGap, rowCount);
    const verticalExtras = verticalNonContent(node, node.box.contentWidth);
    node.box.contentHeight = Math.max(0, contentHeight + totalRowGap);
    node.box.borderBoxHeight = node.box.contentHeight + verticalExtras;
    node.box.marginBoxHeight = node.box.borderBoxHeight + resolveLength(node.style.marginTop, node.box.contentWidth, { auto: "zero" }) + resolveLength(node.style.marginBottom, node.box.contentWidth, { auto: "zero" });
    node.box.scrollWidth = Math.max(node.box.contentWidth, totalColumnWidth);
    node.box.scrollHeight = node.box.contentHeight;
    if (columnWidths.length === 0) {
      node.box.contentWidth = baseContentWidth;
      node.box.borderBoxWidth = node.box.contentWidth + horizontalExtras;
      node.box.marginBoxWidth = node.box.borderBoxWidth + horizontalMargin(node, node.box.contentWidth);
    }
  }
};

// src/text/line-breaker.ts
function segmentText(text) {
  const segments = [];
  const regex = /(\s+)|([^\s]+)/g;
  let match;
  while ((match = regex.exec(text)) !== null) {
    if (match[1]) {
      segments.push({ type: "space", text: match[1] });
    } else if (match[2]) {
      segments.push({ type: "word", text: match[2] });
    }
  }
  return segments;
}
function measureItems(segments, style, fontEmbedder) {
  const fontWeight = typeof style.fontWeight === "number" ? style.fontWeight : 400;
  const fontStyle = style.fontStyle ?? "normal";
  const fontMetrics = fontEmbedder?.getMetrics(style.fontFamily ?? "", fontWeight, fontStyle);
  return segments.map((s) => {
    const glyphWidth = measureTextWithGlyphs(s.text, style, fontMetrics ?? null);
    return {
      ...s,
      width: glyphWidth ?? estimateLineWidth(s.text, style)
    };
  });
}
function splitWordItem(item, style, availableWidth) {
  if (availableWidth <= 0) {
    return [item];
  }
  const pieces = [];
  let buffer = "";
  let bufferWidth = 0;
  const flush = () => {
    if (!buffer) {
      return;
    }
    pieces.push({ type: "word", text: buffer, width: bufferWidth });
    buffer = "";
    bufferWidth = 0;
  };
  for (const char of Array.from(item.text)) {
    const candidate = buffer + char;
    const candidateWidth = estimateLineWidth(candidate, style);
    if (buffer && candidateWidth > availableWidth) {
      flush();
      buffer = char;
      bufferWidth = estimateLineWidth(char, style);
      continue;
    }
    if (!buffer && candidateWidth > availableWidth) {
      pieces.push({ type: "word", text: char, width: candidateWidth });
      buffer = "";
      bufferWidth = 0;
      continue;
    }
    buffer = candidate;
    bufferWidth = candidateWidth;
  }
  flush();
  return pieces.length ? pieces : [item];
}
function enforceOverflowWrap(items, style, availableWidth, mode) {
  if (!mode || mode === "normal") {
    return items;
  }
  const adjusted = [];
  for (const item of items) {
    if (item.type !== "word") {
      adjusted.push(item);
      continue;
    }
    if (item.width <= availableWidth) {
      adjusted.push(item);
      continue;
    }
    adjusted.push(...splitWordItem(item, style, availableWidth));
  }
  return adjusted.length ? adjusted : items;
}
function countJustifiableSpaces(items) {
  let count = 0;
  for (let index = 0; index < items.length; index++) {
    const item = items[index];
    if (item.type !== "space") {
      continue;
    }
    const hasWordBefore = items.slice(0, index).some((candidate) => candidate.type === "word");
    if (!hasWordBefore) {
      continue;
    }
    const hasWordAfter = items.slice(index + 1).some((candidate) => candidate.type === "word");
    if (hasWordAfter) {
      count += 1;
    }
  }
  return count;
}
function shouldTrimLineEdges(style) {
  const mode = style.whiteSpace;
  return mode === "normal" /* Normal */ || mode === "nowrap" /* NoWrap */ || mode === "pre-line" /* PreLine */;
}
function buildLineBox(items, availableWidth, trimEdges) {
  let start = 0;
  let end = items.length;
  if (trimEdges) {
    while (start < end && items[start].type === "space") {
      start += 1;
    }
    while (end > start && items[end - 1].type === "space") {
      end -= 1;
    }
  }
  if (start >= end) {
    return null;
  }
  const trimmed = items.slice(start, end);
  const text = trimmed.map((it) => it.text).join("");
  const width = trimmed.reduce((sum, it) => sum + it.width, 0);
  return {
    text,
    width,
    spaceCount: countJustifiableSpaces(trimmed),
    targetWidth: availableWidth
  };
}
function breakTextIntoLines(text, style, availableWidth, fontEmbedder = null) {
  const effectiveText = applyTextTransform(text, style.textTransform);
  if (effectiveText.length === 0) {
    return [];
  }
  const rawItems = segmentText(effectiveText);
  let items = measureItems(rawItems, style, fontEmbedder);
  items = enforceOverflowWrap(items, style, availableWidth, style.overflowWrap);
  const n = items.length;
  if (n === 0) return [];
  const trimEdges = shouldTrimLineEdges(style);
  const totalWidth = items.reduce((sum, it) => sum + it.width, 0);
  if (totalWidth <= availableWidth) {
    const singleLine = buildLineBox(items, availableWidth, trimEdges);
    return singleLine ? [singleLine] : [];
  }
  const memo = new Array(n + 1).fill(Infinity);
  const breaks = new Array(n + 1).fill(0);
  memo[0] = 0;
  for (let i = 1; i <= n; i++) {
    let lineWidth = 0;
    let hasWord = false;
    for (let j = i; j > 0; j--) {
      const item = items[j - 1];
      if (item.type === "space") {
        if (!hasWord && trimEdges) {
          continue;
        }
        lineWidth += item.width;
        if (lineWidth > availableWidth) {
          break;
        }
        if (!trimEdges && !hasWord) {
          const slack2 = availableWidth - lineWidth;
          const cost2 = 100 + slack2 * slack2;
          if (memo[j - 1] + cost2 < memo[i]) {
            memo[i] = memo[j - 1] + cost2;
            breaks[i] = j - 1;
          }
        }
        continue;
      }
      lineWidth += item.width;
      hasWord = true;
      if (lineWidth > availableWidth) {
        break;
      }
      const slack = availableWidth - lineWidth;
      const cost = 100 + slack * slack;
      if (memo[j - 1] + cost < memo[i]) {
        memo[i] = memo[j - 1] + cost;
        breaks[i] = j - 1;
      }
    }
  }
  if (!isFinite(memo[n])) {
    const lines2 = [];
    let currentWidth = 0;
    let currentItems = [];
    const pushCurrent = () => {
      const line = buildLineBox(currentItems, availableWidth, trimEdges);
      if (line) {
        lines2.push(line);
      }
    };
    for (const item of items) {
      if (trimEdges && item.type === "space" && currentItems.length === 0) {
        continue;
      }
      if (item.type === "word" && currentItems.length > 0 && currentWidth + item.width > availableWidth) {
        pushCurrent();
        currentWidth = 0;
        currentItems = [];
      }
      currentItems.push(item);
      currentWidth += item.width;
    }
    if (currentItems.length > 0) {
      pushCurrent();
    }
    return lines2;
  }
  const lines = [];
  let current2 = n;
  while (current2 > 0) {
    const prev = breaks[current2];
    const lineItems = items.slice(prev, current2);
    const line = buildLineBox(lineItems, availableWidth, trimEdges);
    if (line) {
      lines.unshift(line);
    }
    current2 = prev;
  }
  return lines;
}

// src/layout/table/cell_layout.ts
function layoutTableCell(td) {
  const availableWidth = Math.max(0, td.box.contentWidth);
  td.walk((node) => {
    if (!node.textContent) {
      return;
    }
    const lines = breakTextIntoLines(node.textContent, node.style, availableWidth);
    node.lineBoxes = lines;
    const lineHeight = resolvedLineHeight(node.style);
    const hasRenderableText = node.textContent.trim().length > 0;
    const totalHeight = lines.length > 0 ? lines.length * lineHeight : hasRenderableText ? lineHeight : 0;
    node.box.contentHeight = totalHeight;
    if (lines.length > 0) {
      const maxWidth = Math.max(...lines.map((line) => line.width));
      node.box.contentWidth = Math.min(availableWidth, maxWidth);
    } else {
      node.box.contentWidth = 0;
    }
  });
  const childHeights = Array.from(td.children).map((child) => child.box.contentHeight ?? 0);
  td.box.contentHeight = Math.max(td.box.contentHeight ?? 0, ...childHeights);
}

// src/layout/table/diagnostics.ts
function auditTableCell(td) {
  log("layout", "debug", "[AUDIT] td inline", {
    tdWidth: td.box.contentWidth,
    lines: (td.lineBoxes ?? []).length,
    joined: (td.lineBoxes ?? []).map((line) => line.text).join(" | ")
  });
}
function debugTableCell(cell) {
  if (cell.tagName === "td" && cell.textContent?.includes("Row 3, Cell 3")) {
    log("layout", "debug", "[DEBUG] before inline layout for problematic td", {
      textContent: cell.textContent,
      contentWidth: cell.box.contentWidth
    });
  }
}

// src/layout/strategies/table.ts
var TableLayoutStrategy = class {
  constructor() {
    this.supportedDisplays = /* @__PURE__ */ new Set(["table" /* Table */, "inline-table" /* InlineTable */]);
  }
  canLayout(node) {
    return this.supportedDisplays.has(node.style.display);
  }
  layout(node, context) {
    log("layout", "debug", "TableLayoutStrategy invoked", {
      tagName: node.tagName,
      display: node.style.display,
      children: node.children.length
    });
    const cb = containingBlock(node, context.env.viewport);
    node.box.contentWidth = resolveWidthBlock(node, cb.width);
    log("layout", "debug", "Table layout start", {
      table: node.tagName,
      availableWidth: cb.width,
      resolvedWidth: node.box.contentWidth
    });
    const { grid, rowNodes } = this.buildTableGrid(node);
    if (grid.length === 0 || grid[0].length === 0) {
      node.box.contentHeight = 0;
      return;
    }
    const numRows = grid.length;
    const numCols = grid[0].length;
    log("layout", "debug", "Table grid created", { rows: numRows, cols: numCols });
    const collapsedBorders = node.style.borderModel === "collapse" /* Collapse */;
    for (let r = 0; r < numRows; r++) {
      for (let c = 0; c < numCols; c++) {
        const cell = grid[r][c];
        if (!cell || !this.isOriginCell(cell, r, c)) continue;
        const row = cell.parent;
        const isTableCell = cell.tagName === "td" || cell.tagName === "th";
        if (isTableCell) {
          if (cell.style.borderTop === void 0) cell.style.borderTop = collapsedBorders ? 0 : 1;
          if (cell.style.borderRight === void 0) cell.style.borderRight = collapsedBorders ? 0 : 1;
          if (cell.style.borderBottom === void 0) cell.style.borderBottom = collapsedBorders ? 0 : 1;
          if (cell.style.borderLeft === void 0) cell.style.borderLeft = collapsedBorders ? 0 : 1;
          if (cell.style.borderColor === void 0) cell.style.borderColor = "#000";
        }
        if (cell.style.borderTop === void 0) {
          if (row && row.style.borderTop !== void 0 && row.style.borderTop !== 0) {
            cell.style.borderTop = row.style.borderTop;
          } else if (node.style.borderTop !== void 0 && node.style.borderTop !== 0) {
            cell.style.borderTop = node.style.borderTop;
          }
        }
        if (cell.style.borderRight === void 0) {
          if (row && row.style.borderRight !== void 0 && row.style.borderRight !== 0) {
            cell.style.borderRight = row.style.borderRight;
          } else if (node.style.borderRight !== void 0 && node.style.borderRight !== 0) {
            cell.style.borderRight = node.style.borderRight;
          }
        }
        if (cell.style.borderBottom === void 0) {
          if (row && row.style.borderBottom !== void 0 && row.style.borderBottom !== 0) {
            cell.style.borderBottom = row.style.borderBottom;
          } else if (node.style.borderBottom !== void 0 && node.style.borderBottom !== 0) {
            cell.style.borderBottom = node.style.borderBottom;
          }
        }
        if (cell.style.borderLeft === void 0) {
          if (row && row.style.borderLeft !== void 0 && row.style.borderLeft !== 0) {
            cell.style.borderLeft = row.style.borderLeft;
          } else if (node.style.borderLeft !== void 0 && node.style.borderLeft !== 0) {
            cell.style.borderLeft = node.style.borderLeft;
          }
        }
        if (cell.style.borderColor === void 0) {
          if (row && row.style.borderColor !== void 0) {
            cell.style.borderColor = row.style.borderColor;
          } else if (node.style.borderColor !== void 0) {
            cell.style.borderColor = node.style.borderColor;
          }
        }
        log("layout", "trace", "Cell border properties", {
          row: r,
          col: c,
          borderTop: cell.style.borderTop,
          borderRight: cell.style.borderRight,
          borderBottom: cell.style.borderBottom,
          borderLeft: cell.style.borderLeft,
          borderColor: cell.style.borderColor
        });
      }
    }
    if (collapsedBorders) {
      const numericBorder = (value) => resolveLength(value, node.box.contentWidth, { auto: "zero" });
      const tableBorderTop = numericBorder(node.style.borderTop);
      const tableBorderRight = numericBorder(node.style.borderRight);
      const tableBorderBottom = numericBorder(node.style.borderBottom);
      const tableBorderLeft = numericBorder(node.style.borderLeft);
      for (let c = 0; c < numCols; c++) {
        const topCell = grid[0][c];
        if (topCell && this.isOriginCell(topCell, 0, c)) {
          const cellTop = numericBorder(topCell.style.borderTop);
          const shared = Math.max(cellTop, tableBorderTop);
          topCell.style.borderTop = shared;
        }
        const bottomCell = grid[numRows - 1][c];
        if (bottomCell && this.isOriginCell(bottomCell, numRows - 1, c)) {
          const cellBottom = numericBorder(bottomCell.style.borderBottom);
          const shared = Math.max(cellBottom, tableBorderBottom);
          bottomCell.style.borderBottom = shared;
        }
      }
      for (let r = 0; r < numRows; r++) {
        const leftCell = grid[r][0];
        if (leftCell && this.isOriginCell(leftCell, r, 0)) {
          const cellLeft = numericBorder(leftCell.style.borderLeft);
          const shared = Math.max(cellLeft, tableBorderLeft);
          leftCell.style.borderLeft = shared;
        }
        const rightCell = grid[r][numCols - 1];
        if (rightCell && this.isOriginCell(rightCell, r, numCols - 1)) {
          const cellRight = numericBorder(rightCell.style.borderRight);
          const shared = Math.max(cellRight, tableBorderRight);
          rightCell.style.borderRight = shared;
        }
      }
      node.style.borderTop = 0;
      node.style.borderRight = 0;
      node.style.borderBottom = 0;
      node.style.borderLeft = 0;
      for (let r = 0; r < numRows - 1; r++) {
        for (let c = 0; c < numCols; c++) {
          const upper = grid[r][c];
          const lower = grid[r + 1][c];
          if (!upper || !lower) continue;
          if (upper === lower) continue;
          if (!this.isRowBoundary(upper, r)) continue;
          const upperBottom = numericBorder(upper.style.borderBottom);
          const lowerTop = numericBorder(lower.style.borderTop);
          const shared = Math.max(upperBottom, lowerTop);
          lower.style.borderTop = shared;
          upper.style.borderBottom = 0;
          if (lower.style.borderColor === void 0 && upper.style.borderColor !== void 0) {
            lower.style.borderColor = upper.style.borderColor;
          }
        }
      }
      for (let r = 0; r < numRows; r++) {
        for (let c = 0; c < numCols - 1; c++) {
          const left = grid[r][c];
          const right = grid[r][c + 1];
          if (!left || !right) continue;
          if (left === right) continue;
          if (!this.isColumnBoundary(left, c)) continue;
          const leftRight = numericBorder(left.style.borderRight);
          const rightLeft = numericBorder(right.style.borderLeft);
          const shared = Math.max(leftRight, rightLeft);
          right.style.borderLeft = shared;
          left.style.borderRight = 0;
          if (right.style.borderColor === void 0 && left.style.borderColor !== void 0) {
            right.style.borderColor = left.style.borderColor;
          }
        }
      }
    }
    for (let r = 0; r < numRows; r++) {
      const rowNode = rowNodes[r];
      if (!rowNode) continue;
      const rowBgColor = rowNode.style.backgroundColor;
      if (!rowBgColor) continue;
      for (let c = 0; c < numCols; c++) {
        const cell = grid[r][c];
        if (!cell || !this.isOriginCell(cell, r, c)) continue;
        if (!cell.style.backgroundColor) {
          if (!cell.style.backgroundLayers) {
            cell.style.backgroundLayers = [];
          }
          cell.style.backgroundLayers.push({ kind: "color", color: rowBgColor });
        }
      }
    }
    const colWidths = this.calculateColumnWidths(grid, node.box.contentWidth);
    const tableContentWidth = colWidths.reduce((sum, width) => sum + width, 0);
    node.box.contentWidth = tableContentWidth;
    log("layout", "debug", "Table column widths calculated", { colWidths });
    const rowHeights = new Array(numRows).fill(0);
    const spanningHeightRequests = [];
    for (let r = 0; r < numRows; r++) {
      for (let c = 0; c < numCols; c++) {
        const cell = grid[r][c];
        if (!cell || !this.isOriginCell(cell, r, c)) continue;
        const colSpan = Math.min(this.cellColSpan(cell), numCols - c);
        const rowSpan = Math.min(this.cellRowSpan(cell), numRows - r);
        const spannedWidth = this.sumColumns(colWidths, c, colSpan);
        const boxMetrics = this.resolveCellBoxMetrics(cell, spannedWidth);
        const cellAvailableWidth = spannedWidth - boxMetrics.borderLeft - boxMetrics.borderRight - boxMetrics.paddingLeft - boxMetrics.paddingRight;
        cell.box.x = 0;
        cell.box.y = 0;
        cell.box.contentWidth = cellAvailableWidth;
        debugTableCell(cell);
        layoutTableCell(cell);
        if (cell.textContent?.includes("Row 3, Cell 3")) auditTableCell(cell);
        for (const child of cell.children) {
          child.box.x = (child.box.x ?? 0) + boxMetrics.paddingLeft;
          child.box.y = (child.box.y ?? 0) + boxMetrics.paddingTop;
        }
        if (cell.style.textAlign || cell.style.verticalAlign) {
          for (const child of cell.children) {
            if (cell.style.textAlign) child.style.textAlign = cell.style.textAlign;
            if (cell.style.verticalAlign) child.style.verticalAlign = cell.style.verticalAlign;
          }
        }
        cell.box.contentHeight = cell.box.contentHeight || 0;
        if (cell.children && cell.children.length > 0) {
          let maxChildHeight = 0;
          for (const child of cell.children) {
            maxChildHeight = Math.max(maxChildHeight, child.box.contentHeight || 0);
          }
          cell.box.contentHeight = Math.max(cell.box.contentHeight, maxChildHeight);
        }
        const cellTotalHeight = cell.box.contentHeight + boxMetrics.borderTop + boxMetrics.borderBottom + boxMetrics.paddingTop + boxMetrics.paddingBottom;
        if (rowSpan === 1) {
          rowHeights[r] = Math.max(rowHeights[r], cellTotalHeight);
        } else {
          spanningHeightRequests.push({ startRow: r, span: rowSpan, height: cellTotalHeight });
        }
      }
    }
    for (const request of spanningHeightRequests) {
      const share = request.height / request.span;
      for (let offset = 0; offset < request.span; offset++) {
        const targetRow = request.startRow + offset;
        if (targetRow < rowHeights.length) {
          rowHeights[targetRow] = Math.max(rowHeights[targetRow], share);
        }
      }
    }
    log("layout", "debug", "Table row heights calculated", { rowHeights });
    const colOffsets = this.prefixSums(colWidths);
    const rowOffsets = this.prefixSums(rowHeights);
    for (let r = 0; r < numRows; r++) {
      for (let c = 0; c < numCols; c++) {
        const cell = grid[r][c];
        if (cell && this.isOriginCell(cell, r, c)) {
          const colSpan = Math.min(this.cellColSpan(cell), numCols - c);
          const rowSpan = Math.min(this.cellRowSpan(cell), numRows - r);
          const spanWidth = colOffsets[c + colSpan] - colOffsets[c];
          const spanHeight = rowOffsets[r + rowSpan] - rowOffsets[r];
          const boxMetrics = this.resolveCellBoxMetrics(cell, spanWidth);
          const availableContentHeight = spanHeight - boxMetrics.borderTop - boxMetrics.borderBottom - boxMetrics.paddingTop - boxMetrics.paddingBottom;
          const alignOffsetY = this.computeVerticalAlignOffset(
            cell.style.verticalAlign,
            availableContentHeight,
            cell.box.contentHeight
          );
          const borderBoxX = node.box.x + colOffsets[c];
          const borderBoxY = node.box.y + rowOffsets[r];
          const contentX = borderBoxX + boxMetrics.borderLeft + boxMetrics.paddingLeft;
          const contentY = borderBoxY + boxMetrics.borderTop + boxMetrics.paddingTop;
          const deltaX = contentX - cell.box.x;
          const deltaY = contentY - cell.box.y;
          cell.box.x = borderBoxX;
          cell.box.y = borderBoxY;
          cell.walk((descendant) => {
            descendant.box.x += deltaX;
            descendant.box.y += deltaY + alignOffsetY;
            if (descendant.box.baseline !== void 0) {
              descendant.box.baseline += deltaY + alignOffsetY;
            }
          }, false);
          cell.box.borderBoxWidth = spanWidth;
          cell.box.borderBoxHeight = spanHeight;
          log("layout", "trace", "Positioning table cell", {
            row: r,
            col: c,
            x: cell.box.x,
            y: cell.box.y,
            width: cell.box.borderBoxWidth,
            height: cell.box.borderBoxHeight,
            contentWidth: cell.box.contentWidth,
            contentHeight: cell.box.contentHeight
          });
        }
      }
    }
    for (let r = 0; r < rowNodes.length; r++) {
      const rowNode = rowNodes[r];
      if (rowNode) {
        rowNode.box.x = node.box.x;
        rowNode.box.y = node.box.y + rowOffsets[r];
        rowNode.box.contentWidth = tableContentWidth;
        rowNode.box.contentHeight = rowHeights[r];
        rowNode.box.borderBoxWidth = tableContentWidth;
        rowNode.box.borderBoxHeight = rowHeights[r];
      }
    }
    node.box.contentHeight = rowOffsets[numRows];
    node.box.borderBoxWidth = node.box.contentWidth + horizontalNonContent(node, cb.width);
    node.box.borderBoxHeight = node.box.contentHeight + verticalNonContent(node, cb.width);
    node.box.scrollWidth = node.box.contentWidth;
    node.box.scrollHeight = node.box.contentHeight;
  }
  buildTableGrid(tableNode) {
    const grid = [];
    const rowNodes = [];
    const activeRowSpans = [];
    let currentRowIndex = -1;
    const processRow = (rowNode) => {
      currentRowIndex++;
      rowNodes.push(rowNode);
      const row = [];
      for (const span of activeRowSpans) {
        if (span.remainingRows <= 0) continue;
        while (row.length < span.colStart + span.colSpan) row.push(null);
        for (let i = 0; i < span.colSpan; i++) {
          row[span.colStart + i] = span.cell;
        }
        span.remainingRows--;
      }
      let currentColIndex = 0;
      for (const cellNode of rowNode.children) {
        if (cellNode.style.display === "table-cell" /* TableCell */) {
          while (row[currentColIndex]) currentColIndex++;
          const colSpan = Math.max(1, cellNode.tableColSpan ?? 1);
          const rowSpan = Math.max(1, cellNode.tableRowSpan ?? 1);
          cellNode.tableColSpan = colSpan;
          cellNode.tableRowSpan = rowSpan;
          cellNode.tableCellOrigin = { row: currentRowIndex, col: currentColIndex };
          while (row.length < currentColIndex + colSpan) row.push(null);
          for (let i = 0; i < colSpan; i++) {
            row[currentColIndex + i] = cellNode;
          }
          if (rowSpan > 1) {
            activeRowSpans.push({
              colStart: currentColIndex,
              colSpan,
              remainingRows: rowSpan - 1,
              cell: cellNode
            });
          }
          currentColIndex += colSpan;
        }
      }
      grid.push(row);
      for (let i = activeRowSpans.length - 1; i >= 0; i--) {
        if (activeRowSpans[i].remainingRows <= 0) {
          activeRowSpans.splice(i, 1);
        }
      }
    };
    for (const child of tableNode.children) {
      if (child.style.display === "table-row" /* TableRow */) {
        processRow(child);
      } else if (["table-row-group" /* TableRowGroup */, "table-header-group" /* TableHeaderGroup */, "table-footer-group" /* TableFooterGroup */].includes(child.style.display)) {
        for (const rowNode of child.children) {
          if (rowNode.style.display === "table-row" /* TableRow */) {
            processRow(rowNode);
          }
        }
      }
    }
    const maxCols = grid.reduce((max, row) => Math.max(max, row.length), 0);
    grid.forEach((row) => {
      while (row.length < maxCols) row.push(null);
    });
    return { grid, rowNodes };
  }
  calculateColumnWidths(grid, tableWidth) {
    const numCols = grid[0]?.length || 0;
    if (numCols === 0) return [];
    const minContentWidths = new Array(numCols).fill(0);
    for (let r = 0; r < grid.length; r++) {
      for (let c = 0; c < numCols; c++) {
        const cell = grid[r][c];
        if (!cell || !this.isOriginCell(cell, r, c)) continue;
        let maxIntrinsicWidth = 0;
        if (cell.intrinsicInlineSize) {
          maxIntrinsicWidth = cell.intrinsicInlineSize;
        }
        cell.walk((node) => {
          if (node.intrinsicInlineSize !== void 0) {
            maxIntrinsicWidth = Math.max(maxIntrinsicWidth, node.intrinsicInlineSize);
          }
        });
        const horizontalExtras = horizontalNonContent(cell, tableWidth);
        const cellMinWidth = maxIntrinsicWidth + horizontalExtras;
        const colSpan = Math.min(this.cellColSpan(cell), numCols - c);
        if (colSpan === 1) {
          minContentWidths[c] = Math.max(minContentWidths[c], cellMinWidth);
        } else {
          const share = cellMinWidth / colSpan;
          for (let offset = 0; offset < colSpan; offset++) {
            minContentWidths[c + offset] = Math.max(minContentWidths[c + offset], share);
          }
        }
      }
    }
    const totalMinWidth = minContentWidths.reduce((a, b) => a + b, 0);
    if (totalMinWidth < tableWidth) {
      const remainingWidth = tableWidth - totalMinWidth;
      const weights = minContentWidths.map((w) => w > 0 ? w : totalMinWidth > 0 ? 0 : 1);
      const totalWeight = weights.reduce((a, b) => a + b, 0);
      if (totalWeight > 0) {
        return minContentWidths.map((minWidth, i) => {
          return minWidth + remainingWidth * (weights[i] / totalWeight);
        });
      } else {
        return new Array(numCols).fill(tableWidth / numCols);
      }
    } else if (totalMinWidth > 0) {
      return minContentWidths;
    } else {
      return new Array(numCols).fill(tableWidth / numCols);
    }
  }
  isOriginCell(cell, row, col) {
    const origin = cell.tableCellOrigin;
    return !!origin && origin.row === row && origin.col === col;
  }
  cellColSpan(cell) {
    return Math.max(1, cell.tableColSpan ?? 1);
  }
  cellRowSpan(cell) {
    return Math.max(1, cell.tableRowSpan ?? 1);
  }
  isColumnBoundary(cell, column) {
    const origin = cell.tableCellOrigin;
    if (!origin) return false;
    return origin.col + this.cellColSpan(cell) - 1 === column;
  }
  isRowBoundary(cell, row) {
    const origin = cell.tableCellOrigin;
    if (!origin) return false;
    return origin.row + this.cellRowSpan(cell) - 1 === row;
  }
  sumColumns(colWidths, start, span) {
    let total = 0;
    for (let i = 0; i < span; i++) {
      total += colWidths[start + i] ?? 0;
    }
    return total;
  }
  prefixSums(values) {
    const offsets = [0];
    for (const value of values) {
      offsets.push(offsets[offsets.length - 1] + value);
    }
    return offsets;
  }
  resolveCellBoxMetrics(cell, referenceWidth) {
    const resolve = (value) => resolveLength(value, referenceWidth, { auto: "zero" });
    return {
      borderLeft: resolve(cell.style.borderLeft),
      borderRight: resolve(cell.style.borderRight),
      borderTop: resolve(cell.style.borderTop),
      borderBottom: resolve(cell.style.borderBottom),
      paddingLeft: resolve(cell.style.paddingLeft),
      paddingRight: resolve(cell.style.paddingRight),
      paddingTop: resolve(cell.style.paddingTop),
      paddingBottom: resolve(cell.style.paddingBottom)
    };
  }
  computeVerticalAlignOffset(verticalAlign, available, content) {
    const usedContent = Math.max(0, content ?? 0);
    const free = available - usedContent;
    if (!Number.isFinite(free) || free <= 0) return 0;
    const keyword = (verticalAlign ?? "top").toLowerCase();
    if (keyword === "middle" || keyword === "center") {
      return free / 2;
    }
    if (keyword === "bottom" || keyword === "text-bottom") {
      return free;
    }
    return 0;
  }
};

// src/layout/strategies/fallback.ts
var FallbackStrategy = class {
  canLayout() {
    return true;
  }
  layout(node, _context) {
    node.box.contentWidth = 0;
    node.box.contentHeight = 0;
    node.box.borderBoxWidth = 0;
    node.box.borderBoxHeight = 0;
  }
};

// src/layout/strategies/inline.ts
var InlineLayoutStrategy = class {
  canLayout(node) {
    return node.style.display === "inline" /* Inline */;
  }
  layout(node, context) {
    const refWidth = Math.max(context.env.viewport.width, 0);
    const paddingLeft = resolveLength(node.style.paddingLeft, refWidth, { auto: "zero" });
    const paddingRight = resolveLength(node.style.paddingRight, refWidth, { auto: "zero" });
    const paddingTop = resolveLength(node.style.paddingTop, refWidth, { auto: "zero" });
    const paddingBottom = resolveLength(node.style.paddingBottom, refWidth, { auto: "zero" });
    const borderLeft = resolveLength(node.style.borderLeft, refWidth, { auto: "zero" });
    const borderRight = resolveLength(node.style.borderRight, refWidth, { auto: "zero" });
    const borderTop = resolveLength(node.style.borderTop, refWidth, { auto: "zero" });
    const borderBottom = resolveLength(node.style.borderBottom, refWidth, { auto: "zero" });
    const marginLeft = resolveLength(node.style.marginLeft, refWidth, { auto: "zero" });
    const marginRight = resolveLength(node.style.marginRight, refWidth, { auto: "zero" });
    const marginTop = resolveLength(node.style.marginTop, refWidth, { auto: "zero" });
    const marginBottom = resolveLength(node.style.marginBottom, refWidth, { auto: "zero" });
    const horizontalExtras = paddingLeft + paddingRight + borderLeft + borderRight;
    const verticalExtras = paddingTop + paddingBottom + borderTop + borderBottom;
    const inlineNodes = collectInlineParticipants2(node);
    const floatContext = new FloatContext();
    const startY = node.box.y;
    const availableWidth = Math.max(refWidth, 0);
    const result = defaultInlineFormatter.layout({
      container: node,
      inlineNodes,
      context,
      floatContext,
      contentX: node.box.x + borderLeft + paddingLeft,
      contentWidth: availableWidth,
      startY
    });
    const extent = measureInlineExtent(inlineNodes, refWidth, node.box.x + borderLeft + paddingLeft);
    const floatBottom = Math.max(floatContext.bottom("left"), floatContext.bottom("right"));
    const measuredHeight = Math.max(result.newCursorY, floatBottom) - startY;
    node.box.contentWidth = Math.max(0, extent);
    node.box.contentHeight = Math.max(0, measuredHeight);
    node.box.borderBoxWidth = node.box.contentWidth + horizontalExtras;
    node.box.borderBoxHeight = node.box.contentHeight + verticalExtras;
    node.box.marginBoxWidth = node.box.borderBoxWidth + marginLeft + marginRight;
    node.box.marginBoxHeight = node.box.borderBoxHeight + marginTop + marginBottom;
    node.box.scrollWidth = Math.max(node.box.scrollWidth, node.box.contentWidth);
    node.box.scrollHeight = Math.max(node.box.scrollHeight, node.box.contentHeight);
    if (node.box.baseline === void 0) {
      node.box.baseline = node.box.y + node.box.contentHeight || node.box.y + resolvedLineHeight(node.style);
    }
  }
};
function collectInlineParticipants2(node) {
  const participants = [];
  for (const child of node.children) {
    if (child.style.display === "none" /* None */) {
      continue;
    }
    if (child.style.float !== "none" /* None */) {
      continue;
    }
    if (!isInlineDisplay4(child.style.display)) {
      continue;
    }
    participants.push(child);
  }
  return participants;
}
function isInlineDisplay4(display) {
  switch (display) {
    case "inline" /* Inline */:
    case "inline-block" /* InlineBlock */:
    case "inline-flex" /* InlineFlex */:
    case "inline-grid" /* InlineGrid */:
    case "inline-table" /* InlineTable */:
      return true;
    default:
      return false;
  }
}
function measureInlineExtent(inlineNodes, referenceWidth, contentStartX) {
  if (inlineNodes.length === 0) {
    return 0;
  }
  let minStart = Number.POSITIVE_INFINITY;
  let maxEnd = Number.NEGATIVE_INFINITY;
  for (const node of inlineNodes) {
    const marginLeft = resolveLength(node.style.marginLeft, referenceWidth, { auto: "zero" });
    const marginRight = resolveLength(node.style.marginRight, referenceWidth, { auto: "zero" });
    const paddingLeft = resolveLength(node.style.paddingLeft, referenceWidth, { auto: "zero" });
    const paddingRight = resolveLength(node.style.paddingRight, referenceWidth, { auto: "zero" });
    const borderLeft = resolveLength(node.style.borderLeft, referenceWidth, { auto: "zero" });
    const borderRight = resolveLength(node.style.borderRight, referenceWidth, { auto: "zero" });
    const marginStart = node.box.x - paddingLeft - borderLeft - marginLeft;
    const width = node.box.contentWidth + paddingLeft + paddingRight + borderLeft + borderRight + marginLeft + marginRight;
    const relativeStart = marginStart - contentStartX;
    const relativeEnd = relativeStart + width;
    minStart = Math.min(minStart, relativeStart);
    maxEnd = Math.max(maxEnd, relativeEnd);
  }
  if (!Number.isFinite(minStart) || !Number.isFinite(maxEnd)) {
    return 0;
  }
  return Math.max(0, maxEnd - minStart);
}

// src/layout/strategies/image.ts
var ImageStrategy = class {
  /**
   * Processes an image element and sets up its intrinsic dimensions
   */
  static processImage(node, imageInfo) {
    node.intrinsicInlineSize = imageInfo.width;
    node.intrinsicBlockSize = imageInfo.height;
    if (!node.style.display || node.style.display === "inline" /* Inline */) {
      node.style.display = "inline-block" /* InlineBlock */;
    }
    this.setupImageSizing(node, imageInfo);
  }
  /**
   * Sets up image sizing based on CSS properties
   */
  static setupImageSizing(node, _imageInfo) {
    if (node.style.width !== void 0 && typeof node.style.width === "number" && node.style.width > 0) {
      const specifiedWidth = resolveLength(node.style.width, node.intrinsicInlineSize, { auto: "zero" });
      const scale = specifiedWidth / node.intrinsicInlineSize;
      node.intrinsicBlockSize = Math.round(node.intrinsicBlockSize * scale);
    } else if (node.style.height !== void 0 && typeof node.style.height === "number" && node.style.height > 0) {
      const specifiedHeight = resolveLength(node.style.height, node.intrinsicBlockSize, { auto: "zero" });
      const scale = specifiedHeight / node.intrinsicBlockSize;
      node.intrinsicInlineSize = Math.round(node.intrinsicInlineSize * scale);
    } else if (node.style.maxWidth !== void 0 && typeof node.style.maxWidth === "number") {
      const maxWidth = resolveLength(node.style.maxWidth, node.intrinsicInlineSize, { auto: "zero" });
      if (maxWidth < node.intrinsicInlineSize) {
        const scale = maxWidth / node.intrinsicInlineSize;
        node.intrinsicInlineSize = maxWidth;
        node.intrinsicBlockSize = Math.round(node.intrinsicBlockSize * scale);
      }
    }
  }
  /**
   * Determines if an element should be treated as an image
  */
  static isImageElement(element) {
    if (!element.tagName) {
      return Boolean(element.textContent && element.textContent.includes("data:image"));
    }
    const tag = element.tagName.toLowerCase();
    if (tag === "img" || tag === "picture") {
      return true;
    }
    return Boolean(element.textContent && element.textContent.includes("data:image"));
  }
};
var ImageLayoutStrategy = class {
  canLayout(node) {
    const tag = node.tagName?.toLowerCase() ?? "";
    if (tag === "img") {
      return true;
    }
    if (tag === "svg") {
      return Boolean(node.customData && "svg" in node.customData);
    }
    return false;
  }
  layout(node, context) {
    const cb = containingBlock(node, context.env.viewport);
    const widthRef = Math.max(cb.width, 0);
    const heightRef = Math.max(cb.height, 0);
    const intrinsicWidth = Math.max(0, node.intrinsicInlineSize ?? 0);
    const intrinsicHeight = Math.max(0, node.intrinsicBlockSize ?? 0);
    const hasIntrinsic = intrinsicWidth > 0 && intrinsicHeight > 0;
    const paddingLeft = resolveLength(node.style.paddingLeft, widthRef, { auto: "zero" });
    const paddingRight = resolveLength(node.style.paddingRight, widthRef, { auto: "zero" });
    const paddingTop = resolveLength(node.style.paddingTop, heightRef, { auto: "zero" });
    const paddingBottom = resolveLength(node.style.paddingBottom, heightRef, { auto: "zero" });
    const borderLeft = resolveLength(node.style.borderLeft, widthRef, { auto: "zero" });
    const borderRight = resolveLength(node.style.borderRight, widthRef, { auto: "zero" });
    const borderTop = resolveLength(node.style.borderTop, heightRef, { auto: "zero" });
    const borderBottom = resolveLength(node.style.borderBottom, heightRef, { auto: "zero" });
    const marginLeft = resolveLength(node.style.marginLeft, widthRef, { auto: "zero" });
    const marginRight = resolveLength(node.style.marginRight, widthRef, { auto: "zero" });
    const marginTop = resolveLength(node.style.marginTop, heightRef, { auto: "zero" });
    const marginBottom = resolveLength(node.style.marginBottom, heightRef, { auto: "zero" });
    const horizontalExtras = paddingLeft + paddingRight + borderLeft + borderRight;
    const verticalExtras = paddingTop + paddingBottom + borderTop + borderBottom;
    const availableContentWidth = Math.max(
      0,
      widthRef - horizontalNonContent(node, widthRef) - horizontalMargin(node, widthRef)
    );
    const hasExplicitWidth = node.style.width !== "auto" && node.style.width !== void 0;
    const hasExplicitHeight = node.style.height !== "auto" && node.style.height !== void 0;
    let contentWidth = hasIntrinsic ? intrinsicWidth : availableContentWidth;
    let contentHeight = hasIntrinsic ? intrinsicHeight : 0;
    if (hasExplicitWidth) {
      const resolved = resolveLength(node.style.width, widthRef, { auto: "reference" });
      if (Number.isFinite(resolved) && resolved > 0) {
        contentWidth = resolved;
      }
    }
    if (hasExplicitHeight) {
      const resolved = resolveLength(node.style.height, heightRef, { auto: "reference" });
      if (Number.isFinite(resolved) && resolved > 0) {
        contentHeight = resolved;
      }
    }
    if (hasIntrinsic) {
      if (hasExplicitWidth && !hasExplicitHeight) {
        const scale = intrinsicWidth > 0 ? contentWidth / intrinsicWidth : 1;
        contentHeight = Math.max(1, Math.round(intrinsicHeight * scale));
      } else if (!hasExplicitWidth && hasExplicitHeight) {
        const scale = intrinsicHeight > 0 ? contentHeight / intrinsicHeight : 1;
        contentWidth = Math.max(1, Math.round(intrinsicWidth * scale));
      } else if (!hasExplicitWidth && !hasExplicitHeight) {
        contentWidth = intrinsicWidth;
        contentHeight = intrinsicHeight;
      }
    }
    if (!hasExplicitWidth && availableContentWidth > 0 && contentWidth > availableContentWidth) {
      if (hasIntrinsic && contentWidth > 0) {
        const scale = availableContentWidth / contentWidth;
        contentWidth = availableContentWidth;
        contentHeight = Math.max(1, Math.round(contentHeight * scale));
      } else {
        contentWidth = availableContentWidth;
      }
    }
    const lockAspectToWidth = hasIntrinsic && !hasExplicitHeight;
    const lockAspectToHeight = hasIntrinsic && !hasExplicitWidth;
    if (node.style.maxWidth !== void 0 && !isAutoLength(node.style.maxWidth)) {
      const maxWidth = resolveLength(node.style.maxWidth, widthRef, { auto: "reference" });
      if (Number.isFinite(maxWidth) && maxWidth > 0 && contentWidth > maxWidth) {
        if (lockAspectToWidth && contentWidth > 0) {
          const scale = maxWidth / contentWidth;
          contentHeight = Math.max(1, Math.round(contentHeight * scale));
        }
        contentWidth = maxWidth;
      }
    }
    if (node.style.minWidth !== void 0 && !isAutoLength(node.style.minWidth)) {
      const minWidth = resolveLength(node.style.minWidth, widthRef, { auto: "zero" });
      if (Number.isFinite(minWidth) && minWidth > 0 && contentWidth < minWidth) {
        if (lockAspectToWidth && contentWidth > 0) {
          const scale = minWidth / contentWidth;
          contentHeight = Math.max(1, Math.round(contentHeight * scale));
        }
        contentWidth = minWidth;
      }
    }
    if (node.style.maxHeight !== void 0 && !isAutoLength(node.style.maxHeight)) {
      const maxHeight = resolveLength(node.style.maxHeight, heightRef, { auto: "reference" });
      if (Number.isFinite(maxHeight) && maxHeight > 0 && contentHeight > maxHeight) {
        if (lockAspectToHeight && contentHeight > 0) {
          const scale = maxHeight / contentHeight;
          contentWidth = Math.max(1, Math.round(contentWidth * scale));
        }
        contentHeight = maxHeight;
      }
    }
    if (node.style.minHeight !== void 0 && !isAutoLength(node.style.minHeight)) {
      const minHeight = resolveLength(node.style.minHeight, heightRef, { auto: "zero" });
      if (Number.isFinite(minHeight) && minHeight > 0 && contentHeight < minHeight) {
        if (lockAspectToHeight && contentHeight > 0) {
          const scale = minHeight / contentHeight;
          contentWidth = Math.max(1, Math.round(contentWidth * scale));
        }
        contentHeight = minHeight;
      }
    }
    if (!Number.isFinite(contentWidth) || contentWidth <= 0) {
      contentWidth = Math.max(availableContentWidth, hasIntrinsic ? intrinsicWidth : 0);
    }
    if (!Number.isFinite(contentHeight) || contentHeight <= 0) {
      if (hasIntrinsic && contentWidth > 0 && intrinsicWidth > 0) {
        const scale = contentWidth / intrinsicWidth;
        contentHeight = Math.max(1, Math.round(intrinsicHeight * scale));
      } else {
        contentHeight = contentWidth;
      }
    }
    node.box.contentWidth = Math.max(0, contentWidth);
    node.box.contentHeight = Math.max(0, contentHeight);
    node.box.borderBoxWidth = node.box.contentWidth + horizontalExtras;
    node.box.borderBoxHeight = node.box.contentHeight + verticalExtras;
    node.box.marginBoxWidth = node.box.borderBoxWidth + marginLeft + marginRight;
    node.box.marginBoxHeight = node.box.borderBoxHeight + marginTop + marginBottom;
    node.box.scrollWidth = node.box.contentWidth;
    node.box.scrollHeight = node.box.contentHeight;
    node.box.baseline = node.box.borderBoxHeight;
    if (node.style.display === "block" /* Block */ && node.box.contentWidth > availableContentWidth && availableContentWidth > 0) {
      const scale = availableContentWidth / node.box.contentWidth;
      node.box.contentWidth = availableContentWidth;
      node.box.contentHeight = Math.max(1, Math.round(node.box.contentHeight * scale));
      node.box.borderBoxWidth = node.box.contentWidth + horizontalExtras;
      node.box.borderBoxHeight = node.box.contentHeight + verticalExtras;
      node.box.marginBoxWidth = node.box.borderBoxWidth + marginLeft + marginRight;
      node.box.marginBoxHeight = node.box.borderBoxHeight + marginTop + marginBottom;
      node.box.scrollWidth = node.box.contentWidth;
      node.box.scrollHeight = node.box.contentHeight;
      node.box.baseline = node.box.borderBoxHeight;
    }
  }
};

// src/layout/pipeline/default-engine.ts
function createDefaultLayoutEngine() {
  const strategies = [
    new DisplayNoneStrategy(),
    new ImageLayoutStrategy(),
    new InlineLayoutStrategy(),
    new BlockLayoutStrategy(),
    new FlexLayoutStrategy(),
    new GridLayoutStrategy(),
    new TableLayoutStrategy(),
    new FallbackStrategy()
  ];
  return new LayoutEngine({ strategies });
}

// src/layout/pipeline/layout-tree.ts
function layoutTree(root, viewport, fontEmbedder = null) {
  const engine = createDefaultLayoutEngine();
  return engine.layoutTree(root, viewport, fontEmbedder);
}

// src/css/named-colors.ts
var NAMED_COLORS = {
  "aliceblue": "#f0f8ff",
  "antiquewhite": "#faebd7",
  "aqua": "#00ffff",
  "aquamarine": "#7fffd4",
  "azure": "#f0ffff",
  "beige": "#f5f5dc",
  "bisque": "#ffe4c4",
  "black": "#000000",
  "blanchedalmond": "#ffebcd",
  "blue": "#0000ff",
  "blueviolet": "#8a2be2",
  "brown": "#a52a2a",
  "burlywood": "#deb887",
  "cadetblue": "#5f9ea0",
  "chartreuse": "#7fff00",
  "chocolate": "#d2691e",
  "coral": "#ff7f50",
  "cornflowerblue": "#6495ed",
  "cornsilk": "#fff8dc",
  "crimson": "#dc143c",
  "cyan": "#00ffff",
  "darkblue": "#00008b",
  "darkcyan": "#008b8b",
  "darkgoldenrod": "#b8860b",
  "darkgray": "#a9a9a9",
  "darkgreen": "#006400",
  "darkgrey": "#a9a9a9",
  "darkkhaki": "#bdb76b",
  "darkmagenta": "#8b008b",
  "darkolivegreen": "#556b2f",
  "darkorange": "#ff8c00",
  "darkorchid": "#9932cc",
  "darkred": "#8b0000",
  "darksalmon": "#e9967a",
  "darkseagreen": "#8fbc8f",
  "darkslateblue": "#483d8b",
  "darkslategray": "#2f4f4f",
  "darkslategrey": "#2f4f4f",
  "darkturquoise": "#00ced1",
  "darkviolet": "#9400d3",
  "deeppink": "#ff1493",
  "deepskyblue": "#00bfff",
  "dimgray": "#696969",
  "dimgrey": "#696969",
  "dodgerblue": "#1e90ff",
  "firebrick": "#b22222",
  "floralwhite": "#fffaf0",
  "forestgreen": "#228b22",
  "fuchsia": "#ff00ff",
  "gainsboro": "#dcdcdc",
  "ghostwhite": "#f8f8ff",
  "gold": "#ffd700",
  "goldenrod": "#daa520",
  "gray": "#808080",
  "green": "#008000",
  "greenyellow": "#adff2f",
  "grey": "#808080",
  "honeydew": "#f0fff0",
  "hotpink": "#ff69b4",
  "indianred": "#cd5c5c",
  "indigo": "#4b0082",
  "ivory": "#fffff0",
  "khaki": "#f0e68c",
  "lavender": "#e6e6fa",
  "lavenderblush": "#fff0f5",
  "lawngreen": "#7cfc00",
  "lemonchiffon": "#fffacd",
  "lightblue": "#add8e6",
  "lightcoral": "#f08080",
  "lightcyan": "#e0ffff",
  "lightgoldenrodyellow": "#fafad2",
  "lightgray": "#d3d3d3",
  "lightgreen": "#90ee90",
  "lightgrey": "#d3d3d3",
  "lightpink": "#ffb6c1",
  "lightsalmon": "#ffa07a",
  "lightseagreen": "#20b2aa",
  "lightskyblue": "#87cefa",
  "lightslategray": "#778899",
  "lightslategrey": "#778899",
  "lightsteelblue": "#b0c4de",
  "lightyellow": "#ffffe0",
  "lime": "#00ff00",
  "limegreen": "#32cd32",
  "linen": "#faf0e6",
  "magenta": "#ff00ff",
  "maroon": "#800000",
  "mediumaquamarine": "#66cdaa",
  "mediumblue": "#0000cd",
  "mediumorchid": "#ba55d3",
  "mediumpurple": "#9370db",
  "mediumseagreen": "#3cb371",
  "mediumslateblue": "#7b68ee",
  "mediumspringgreen": "#00fa9a",
  "mediumturquoise": "#48d1cc",
  "mediumvioletred": "#c71585",
  "midnightblue": "#191970",
  "mintcream": "#f5fffa",
  "mistyrose": "#ffe4e1",
  "moccasin": "#ffe4b5",
  "navajowhite": "#ffdead",
  "navy": "#000080",
  "oldlace": "#fdf5e6",
  "olive": "#808000",
  "olivedrab": "#6b8e23",
  "orange": "#ffa500",
  "orangered": "#ff4500",
  "orchid": "#da70d6",
  "palegoldenrod": "#eee8aa",
  "palegreen": "#98fb98",
  "paleturquoise": "#afeeee",
  "palevioletred": "#db7093",
  "papayawhip": "#ffefd5",
  "peachpuff": "#ffdab9",
  "peru": "#cd853f",
  "pink": "#ffc0cb",
  "plum": "#dda0dd",
  "powderblue": "#b0e0e6",
  "purple": "#800080",
  "rebeccapurple": "#663399",
  "red": "#ff0000",
  "rosybrown": "#bc8f8f",
  "royalblue": "#4169e1",
  "saddlebrown": "#8b4513",
  "salmon": "#fa8072",
  "sandybrown": "#f4a460",
  "seagreen": "#2e8b57",
  "seashell": "#fff5ee",
  "sienna": "#a0522d",
  "silver": "#c0c0c0",
  "skyblue": "#87ceeb",
  "slateblue": "#6a5acd",
  "slategray": "#708090",
  "slategrey": "#708090",
  "snow": "#fffafa",
  "springgreen": "#00ff7f",
  "steelblue": "#4682b4",
  "tan": "#d2b48c",
  "teal": "#008080",
  "thistle": "#d8bfd8",
  "tomato": "#ff6347",
  "turquoise": "#40e0d0",
  "violet": "#ee82ee",
  "wheat": "#f5deb3",
  "white": "#ffffff",
  "whitesmoke": "#f5f5f5",
  "yellow": "#ffff00",
  "yellowgreen": "#9acd32"
};

// src/pdf/utils/color-utils.ts
function parseColor(value) {
  if (!value) {
    return void 0;
  }
  let normalized = value.trim().toLowerCase();
  if (normalized in NAMED_COLORS) {
    normalized = NAMED_COLORS[normalized];
  }
  if (normalized === "transparent") {
    return void 0;
  }
  const hexMatch = normalized.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
  if (hexMatch) {
    const digits = hexMatch[1];
    if (digits.length === 3) {
      const r2 = parseHex(digits[0] + digits[0]);
      const g2 = parseHex(digits[1] + digits[1]);
      const b2 = parseHex(digits[2] + digits[2]);
      return { r: r2, g: g2, b: b2, a: 1 };
    }
    const r = parseHex(digits.slice(0, 2));
    const g = parseHex(digits.slice(2, 4));
    const b = parseHex(digits.slice(4, 6));
    return { r, g, b, a: 1 };
  }
  const rgbMatch = normalized.match(/^rgba?\((.+)\)$/);
  if (rgbMatch) {
    const parts = rgbMatch[1].split(",").map((part) => part.trim());
    const r = clampColor(Number.parseFloat(parts[0]));
    const g = clampColor(Number.parseFloat(parts[1]));
    const b = clampColor(Number.parseFloat(parts[2]));
    const a = parts[3] !== void 0 ? clampAlpha(Number.parseFloat(parts[3])) : 1;
    return { r, g, b, a };
  }
  return void 0;
}
function parseHex(value) {
  return Number.parseInt(value, 16);
}
function clampColor(value) {
  if (Number.isNaN(value)) {
    return 0;
  }
  if (value > 255) {
    return 255;
  }
  if (value < 0) {
    return 0;
  }
  return value;
}
function clampAlpha(value) {
  if (Number.isNaN(value)) {
    return 1;
  }
  if (value > 1) {
    return 1;
  }
  if (value < 0) {
    return 0;
  }
  return value;
}
function cloneColor(color) {
  return { r: color.r, g: color.g, b: color.b, a: color.a };
}

// src/pdf/utils/text-alignment-resolver.ts
function resolveTextAlign(node) {
  let current2 = node;
  while (current2) {
    const value = current2.style.textAlign;
    if (value && value !== "start" && value !== "auto") {
      return value;
    }
    current2 = current2.parent;
  }
  return void 0;
}
function resolveFallbackStartX(node, advanceWidth, textAlign) {
  let startX = node.box.x;
  if (advanceWidth > 0 && Number.isFinite(node.box.contentWidth) && node.box.contentWidth > 0) {
    const slack = Math.max(node.box.contentWidth - advanceWidth, 0);
    if (textAlign === "center") {
      startX = node.box.x + slack / 2;
    } else if (textAlign === "right" || textAlign === "end") {
      startX = node.box.x + slack;
    } else if (textAlign === "left" || textAlign === "start") {
      startX = node.box.x;
    }
  }
  const flexStart = resolveFlexSingleChildStart(node, advanceWidth);
  if (flexStart !== null) {
    startX = flexStart;
  }
  return startX;
}
function resolveFlexSingleChildStart(node, advanceWidth) {
  if (!node.parent || advanceWidth <= 0) {
    return null;
  }
  const parent = node.parent;
  if (parent.style.display !== "flex" /* Flex */) {
    return null;
  }
  if (parent.children.length !== 1) {
    return null;
  }
  const direction = parent.style.flexDirection ?? "row";
  if (direction !== "row" && direction !== "row-reverse") {
    return null;
  }
  const justify = parent.style.justifyContent ?? "flex-start" /* FlexStart */;
  const parentWidth = Number.isFinite(parent.box.contentWidth) ? parent.box.contentWidth : 0;
  if (!(parentWidth > 0)) {
    return null;
  }
  const constrainedWidth = advanceWidth > parentWidth ? parentWidth : advanceWidth;
  const slack = Math.max(parentWidth - constrainedWidth, 0);
  const parentStart = parent.box.x;
  const parentEnd = parentStart + parentWidth;
  const isReverse = direction === "row-reverse";
  switch (justify) {
    case "center" /* Center */:
      return parentStart + slack / 2;
    case "flex-end" /* FlexEnd */:
    case "end" /* End */:
    case "right" /* Right */:
      return isReverse ? parentStart : parentEnd - constrainedWidth;
    case "flex-start" /* FlexStart */:
    case "start" /* Start */:
    case "left" /* Left */:
      return isReverse ? parentEnd - constrainedWidth : parentStart;
    default:
      return null;
  }
}

// src/pdf/utils/border-radius-utils.ts
function resolveBorderRadius(style, borderBox) {
  const raw = {
    topLeft: {
      x: clampRadius(style.borderTopLeftRadiusX),
      y: clampRadius(style.borderTopLeftRadiusY)
    },
    topRight: {
      x: clampRadius(style.borderTopRightRadiusX),
      y: clampRadius(style.borderTopRightRadiusY)
    },
    bottomRight: {
      x: clampRadius(style.borderBottomRightRadiusX),
      y: clampRadius(style.borderBottomRightRadiusY)
    },
    bottomLeft: {
      x: clampRadius(style.borderBottomLeftRadiusX),
      y: clampRadius(style.borderBottomLeftRadiusY)
    }
  };
  return normalizeBorderRadius(raw, borderBox.width, borderBox.height);
}
function clampRadius(value) {
  if (!Number.isFinite(value ?? NaN)) {
    return 0;
  }
  const numeric = Number(value);
  return numeric > 0 ? numeric : 0;
}
function normalizeBorderRadius(input, width, height) {
  const result = {
    topLeft: { ...input.topLeft },
    topRight: { ...input.topRight },
    bottomRight: { ...input.bottomRight },
    bottomLeft: { ...input.bottomLeft }
  };
  const safeWidth = Math.max(width, 0);
  const safeHeight = Math.max(height, 0);
  if (safeWidth <= 0) {
    result.topLeft.x = 0;
    result.topRight.x = 0;
    result.bottomRight.x = 0;
    result.bottomLeft.x = 0;
  } else {
    const topSum = result.topLeft.x + result.topRight.x;
    if (topSum > safeWidth && topSum > 0) {
      const scale = safeWidth / topSum;
      result.topLeft.x *= scale;
      result.topRight.x *= scale;
    }
    const bottomSum = result.bottomLeft.x + result.bottomRight.x;
    if (bottomSum > safeWidth && bottomSum > 0) {
      const scale = safeWidth / bottomSum;
      result.bottomLeft.x *= scale;
      result.bottomRight.x *= scale;
    }
  }
  if (safeHeight <= 0) {
    result.topLeft.y = 0;
    result.topRight.y = 0;
    result.bottomRight.y = 0;
    result.bottomLeft.y = 0;
  } else {
    const leftSum = result.topLeft.y + result.bottomLeft.y;
    if (leftSum > safeHeight && leftSum > 0) {
      const scale = safeHeight / leftSum;
      result.topLeft.y *= scale;
      result.bottomLeft.y *= scale;
    }
    const rightSum = result.topRight.y + result.bottomRight.y;
    if (rightSum > safeHeight && rightSum > 0) {
      const scale = safeHeight / rightSum;
      result.topRight.y *= scale;
      result.bottomRight.y *= scale;
    }
  }
  return result;
}

// src/pdf/utils/shadow-utils.ts
function resolveBoxShadows(node, fallbackColor) {
  const result = [];
  const shadows = node.style.boxShadows ?? [];
  for (const shadow of shadows) {
    const color = resolveShadowColor(shadow.color, node.style.color, fallbackColor);
    if (!color) {
      continue;
    }
    result.push({
      inset: shadow.inset,
      offsetX: shadow.offsetX,
      offsetY: shadow.offsetY,
      blur: clampNonNegative(shadow.blurRadius),
      spread: shadow.spreadRadius ?? 0,
      color
    });
  }
  return result;
}
function resolveTextShadows(node, fallbackColor) {
  const result = [];
  const shadows = node.style.textShadows ?? [];
  for (const shadow of shadows) {
    const offsetX = shadow.offsetX ?? 0;
    const offsetY = shadow.offsetY ?? 0;
    const blur = clampNonNegative(shadow.blurRadius ?? 0);
    const color = resolveShadowColor(shadow.color, node.style.color, fallbackColor);
    if (!color) {
      continue;
    }
    result.push({
      inset: false,
      offsetX,
      offsetY,
      blur,
      spread: 0,
      color
    });
  }
  return result;
}
function resolveShadowColor(specified, styleColor, fallbackColor) {
  if (!specified || specified.trim().length === 0) {
    return cloneColor(fallbackColor);
  }
  const normalized = specified.trim().toLowerCase();
  if (normalized === "transparent") {
    return void 0;
  }
  if (normalized === "currentcolor") {
    const current2 = parseColor(styleColor);
    return cloneColor(current2 ?? fallbackColor);
  }
  const parsed = parseColor(specified);
  if (parsed) {
    return cloneColor(parsed);
  }
  return cloneColor(fallbackColor);
}
function computeShadowVisualOverflow(base, shadow) {
  const spread = shadow.spread;
  const blur = shadow.blur;
  const baseWidth = Math.max(base.width + spread * 2, 0);
  const baseHeight = Math.max(base.height + spread * 2, 0);
  const baseX = base.x + shadow.offsetX - spread;
  const baseY = base.y + shadow.offsetY - spread;
  const finalWidth = baseWidth + blur * 2;
  const finalHeight = baseHeight + blur * 2;
  if (finalWidth <= 0 || finalHeight <= 0) {
    return null;
  }
  return {
    x: baseX - blur,
    y: baseY - blur,
    width: finalWidth,
    height: finalHeight
  };
}
function calculateVisualOverflow(_node, borderBox, boxShadows) {
  const visualOverflow = cloneRect(borderBox);
  for (const shadow of boxShadows) {
    if (shadow.inset) {
      continue;
    }
    const shadowRect = computeShadowVisualOverflow(borderBox, shadow);
    if (shadowRect) {
      expandRectToInclude(visualOverflow, shadowRect);
    }
  }
  return visualOverflow;
}
function clampNonNegative(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  return value < 0 ? 0 : value;
}
function cloneRect(rect) {
  return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
}
function expandRectToInclude(target, addition) {
  if (addition.width <= 0 || addition.height <= 0) {
    return;
  }
  const minX = Math.min(target.x, addition.x);
  const minY = Math.min(target.y, addition.y);
  const maxX = Math.max(target.x + target.width, addition.x + addition.width);
  const maxY = Math.max(target.y + target.height, addition.y + addition.height);
  target.x = minX;
  target.y = minY;
  target.width = Math.max(0, maxX - minX);
  target.height = Math.max(0, maxY - minY);
}

// src/pdf/utils/image-utils.ts
function extractImageRef(node) {
  if (node.tagName !== "img") {
    return void 0;
  }
  const payload = node.customData?.image;
  if (!payload?.info) {
    return void 0;
  }
  const info = payload.info;
  const src = payload.resolvedSrc ?? payload.originalSrc ?? "";
  return {
    src,
    width: info.width,
    height: info.height,
    format: info.format,
    channels: info.channels,
    bitsPerComponent: info.bitsPerChannel,
    data: info.data
  };
}

// src/pdf/utils/box-dimensions-utils.ts
function calculateBoxDimensions(node) {
  const widthRef = Math.max(node.box.contentWidth, 0);
  const contentHeightRef = Math.max(node.box.contentHeight, 0);
  const padding = {
    top: resolveLength(node.style.paddingTop, widthRef, { auto: "zero" }),
    right: resolveLength(node.style.paddingRight, widthRef, { auto: "zero" }),
    bottom: resolveLength(node.style.paddingBottom, widthRef, { auto: "zero" }),
    left: resolveLength(node.style.paddingLeft, widthRef, { auto: "zero" })
  };
  const border = {
    top: resolveLength(node.style.borderTop, widthRef, { auto: "zero" }),
    right: resolveLength(node.style.borderRight, widthRef, { auto: "zero" }),
    bottom: resolveLength(node.style.borderBottom, widthRef, { auto: "zero" }),
    left: resolveLength(node.style.borderLeft, widthRef, { auto: "zero" })
  };
  const borderBox = {
    x: node.box.x,
    y: node.box.y,
    width: fallbackDimension(node.box.borderBoxWidth, node.box.contentWidth + padding.left + padding.right + border.left + border.right),
    height: fallbackDimension(
      node.box.borderBoxHeight,
      contentHeightRef + padding.top + padding.bottom + border.top + border.bottom
    )
  };
  const paddingBox = {
    x: borderBox.x + border.left,
    y: borderBox.y + border.top,
    width: borderBox.width - border.left - border.right,
    height: borderBox.height - border.top - border.bottom
  };
  const contentBox = {
    x: paddingBox.x + padding.left,
    y: paddingBox.y + padding.top,
    width: paddingBox.width - padding.left - padding.right,
    height: paddingBox.height - padding.top - padding.bottom
  };
  return { borderBox, paddingBox, contentBox };
}
function fallbackDimension(value, computed) {
  return value > 0 ? value : computed;
}

// src/pdf/utils/text-decoration-utils.ts
function resolveDecorations(style) {
  const value = style.textDecorationLine?.trim().toLowerCase();
  if (!value || value === "none") {
    return void 0;
  }
  const tokens = value.split(/\s+/);
  const decoration = {};
  for (const token of tokens) {
    switch (token) {
      case "underline":
        decoration.underline = true;
        break;
      case "overline":
        decoration.overline = true;
        break;
      case "line-through":
        decoration.lineThrough = true;
        break;
      default:
        break;
    }
  }
  if (!(decoration.underline || decoration.overline || decoration.lineThrough)) {
    return void 0;
  }
  const styleKeyword = style.textDecorationStyle?.trim().toLowerCase();
  switch (styleKeyword) {
    case "solid":
    case "double":
    case "dotted":
    case "dashed":
    case "wavy":
      decoration.style = styleKeyword;
      break;
    default:
      decoration.style = "solid";
      break;
  }
  const color = resolveDecorationColor(style);
  if (color) {
    decoration.color = color;
  }
  return decoration;
}
function resolveDecorationColor(style) {
  const raw = style.textDecorationColor;
  if (raw) {
    if (raw.toLowerCase() === "currentcolor") {
      return parseColor(style.color);
    }
    const parsed = parseColor(raw);
    if (parsed) {
      return parsed;
    }
  }
  return parseColor(style.color);
}

// src/pdf/utils/background-layer-resolver.ts
function resolveBackgroundLayers(node, boxes) {
  const layers = node.style.backgroundLayers ?? [];
  const background = {};
  for (let i = layers.length - 1; i >= 0; i--) {
    const layer = layers[i];
    if (layer.clip === "text") {
      continue;
    }
    if (layer.kind === "gradient" && background.gradient === void 0) {
      const gradient = createGradientBackground(layer, boxes);
      if (gradient) {
        background.gradient = gradient;
      }
    } else if (layer.kind === "image" && background.image === void 0) {
      const image = createBackgroundImage(layer, boxes);
      if (image) {
        background.image = image;
      }
    }
  }
  const color = parseColor(node.style.backgroundColor || void 0);
  if (color) {
    background.color = color;
  }
  return background;
}
function resolveTextGradientLayer(node, boxes) {
  const layers = node.style.backgroundLayers ?? [];
  for (let i = layers.length - 1; i >= 0; i--) {
    const layer = layers[i];
    if (layer.kind === "gradient" && layer.clip === "text") {
      const gradient = createGradientBackground(layer, boxes);
      if (gradient) {
        return gradient;
      }
    }
  }
  return void 0;
}
function createBackgroundImage(layer, boxes) {
  if (!layer.imageInfo) {
    return void 0;
  }
  const originRect = selectBackgroundOriginRect(layer, boxes);
  const size = resolveBackgroundImageSize(layer.size, originRect, layer.imageInfo);
  if (size.width <= 0 || size.height <= 0) {
    return void 0;
  }
  const position = resolveBackgroundPosition(layer.position, originRect, size.width, size.height);
  const imageRef = convertToImageRef(layer, layer.imageInfo);
  return {
    image: imageRef,
    rect: {
      x: position.x,
      y: position.y,
      width: size.width,
      height: size.height
    },
    repeat: layer.repeat ?? "repeat",
    originRect
  };
}
function createGradientBackground(layer, boxes) {
  const originRect = selectBackgroundOriginRect(layer, boxes);
  const size = resolveGradientSize(layer.size, originRect);
  if (size.width <= 0 || size.height <= 0) {
    return void 0;
  }
  const position = resolveBackgroundPosition(layer.position, originRect, size.width, size.height);
  const rect = {
    x: position.x,
    y: position.y,
    width: size.width,
    height: size.height
  };
  const normalizedGradient = normalizeGradientGeometry(layer.gradient, rect);
  if (!normalizedGradient) {
    return void 0;
  }
  return {
    gradient: normalizedGradient,
    rect,
    repeat: layer.repeat ?? "no-repeat",
    originRect
  };
}
function selectBackgroundOriginRect(layer, boxes) {
  switch (layer.origin) {
    case "border-box":
      return boxes.borderBox;
    case "padding-box":
      return boxes.paddingBox;
    case "content-box":
      return boxes.contentBox;
    default:
      return boxes.paddingBox;
  }
}
function resolveBackgroundImageSize(size, area, info) {
  const intrinsicWidth = info.width;
  const intrinsicHeight = info.height;
  const areaWidth = area.width;
  const areaHeight = area.height;
  const ratio = intrinsicWidth > 0 && intrinsicHeight > 0 ? intrinsicWidth / intrinsicHeight : 1;
  if (!size || typeof size === "string") {
    if (size === "cover") {
      if (ratio >= areaWidth / areaHeight) {
        return { width: ratio * areaHeight, height: areaHeight };
      }
      return { width: areaWidth, height: areaWidth / ratio };
    }
    if (size === "contain") {
      if (ratio >= areaWidth / areaHeight) {
        return { width: areaWidth, height: areaWidth / ratio };
      }
      return { width: ratio * areaHeight, height: areaHeight };
    }
    if (intrinsicWidth > 0 && intrinsicHeight > 0) {
      return { width: intrinsicWidth, height: intrinsicHeight };
    }
    return { width: areaWidth, height: areaHeight };
  }
  const widthComponent = parseBackgroundSizeComponent(size.width, areaWidth, intrinsicWidth) ?? parseBackgroundSizeComponent("auto", areaWidth, intrinsicWidth);
  const heightComponent = parseBackgroundSizeComponent(size.height, areaHeight, intrinsicHeight) ?? parseBackgroundSizeComponent("auto", areaHeight, intrinsicHeight);
  return { width: widthComponent ?? areaWidth, height: heightComponent ?? areaHeight };
}
function resolveGradientSize(size, area) {
  if (!size || typeof size === "string") {
    return { width: area.width, height: area.height };
  }
  const resolvedWidth = parseBackgroundSizeComponent(size.width, area.width, area.width) ?? area.width;
  const resolvedHeight = parseBackgroundSizeComponent(size.height, area.height, area.height) ?? area.height;
  return { width: resolvedWidth, height: resolvedHeight };
}
function resolveBackgroundPosition(position, area, width, height) {
  const x = resolvePositionComponent(position?.x, area.x, area.width - width, width, "x");
  const y = resolvePositionComponent(position?.y, area.y, area.height - height, height, "y");
  return { x, y };
}
function resolvePositionComponent(value, start, available, size, axis) {
  if (!value || value === "left" || value === "top") {
    return start;
  }
  if (value === "center") {
    return start + available / 2;
  }
  if (value === "right" || value === "bottom") {
    return start + available;
  }
  if (value.endsWith("%")) {
    const percent2 = parseFloat(value);
    if (!Number.isNaN(percent2)) {
      return start + percent2 / 100 * available;
    }
  }
  if (value.endsWith("px")) {
    const px = parseFloat(value);
    if (!Number.isNaN(px)) {
      return start + px;
    }
  }
  return axis === "x" ? start : start + available;
}
function parseBackgroundSizeComponent(component, axisLength, intrinsic) {
  if (!component || component === "auto") {
    return intrinsic > 0 ? intrinsic : void 0;
  }
  if (component.endsWith("%")) {
    const percent2 = parseFloat(component);
    if (!Number.isNaN(percent2)) {
      return percent2 / 100 * axisLength;
    }
    return void 0;
  }
  if (component.endsWith("px")) {
    const px = parseFloat(component);
    if (!Number.isNaN(px)) {
      return px;
    }
    return void 0;
  }
  const value = Number(component);
  if (Number.isFinite(value)) {
    return value;
  }
  return void 0;
}
function normalizeGradientGeometry(gradient, rect) {
  if (!gradient) {
    return void 0;
  }
  if (gradient.type === "radial") {
    return normalizeRadialGradient(gradient, rect);
  }
  return gradient;
}
function normalizeRadialGradient(gradient, rect) {
  if (gradient.coordsUnits === "userSpace") {
    return gradient;
  }
  if (rect.width <= 0 || rect.height <= 0) {
    return void 0;
  }
  const hasCssHints = !!gradient.at || !!gradient.size || !!gradient.shape || gradient.source === "css";
  if (!hasCssHints) {
    return gradient;
  }
  const cxPx = resolvePositionToPx(gradient.at?.x, rect.width, (gradient.cx ?? 0.5) * rect.width, "x");
  const cyPx = resolvePositionToPx(gradient.at?.y, rect.height, (gradient.cy ?? 0.5) * rect.height, "y");
  const radiusPx = resolveRadialRadiusPx(
    gradient.size,
    gradient.shape,
    rect.width,
    rect.height,
    cxPx,
    cyPx,
    gradient.r
  );
  const maxDimension = Math.max(rect.width, rect.height, 1);
  return {
    ...gradient,
    cx: clampUnit(cxPx / rect.width),
    cy: clampUnit(cyPx / rect.height),
    r: clampUnit(radiusPx / maxDimension),
    coordsUnits: "ratio"
  };
}
function resolvePositionToPx(raw, length, fallbackPx, axis) {
  if (!Number.isFinite(length) || length <= 0) {
    return fallbackPx;
  }
  if (!raw) {
    return clamp(rawNumber(fallbackPx), 0, length);
  }
  const lower = raw.trim().toLowerCase();
  if (lower === "left" || lower === "top") return 0;
  if (lower === "center") return length / 2;
  if (lower === "right" || lower === "bottom") return length;
  if (lower.endsWith("%")) {
    const pct = Number.parseFloat(lower.slice(0, -1));
    if (Number.isFinite(pct)) {
      return clamp(pct / 100 * length, 0, length);
    }
  }
  if (lower.endsWith("px")) {
    const px = Number.parseFloat(lower);
    if (Number.isFinite(px)) {
      return clamp(px, 0, length);
    }
  }
  const numeric = Number.parseFloat(lower);
  if (Number.isFinite(numeric)) {
    return clamp(numeric, 0, length);
  }
  return clamp(rawNumber(fallbackPx), 0, length);
}
function resolveRadialRadiusPx(size, shape, width, height, cx, cy, fallbackRatio) {
  const distanceLeft = Math.max(cx, 0);
  const distanceRight = Math.max(width - cx, 0);
  const distanceTop = Math.max(cy, 0);
  const distanceBottom = Math.max(height - cy, 0);
  const sideMin = Math.min(distanceLeft, distanceRight, distanceTop, distanceBottom);
  const sideMax = Math.max(distanceLeft, distanceRight, distanceTop, distanceBottom);
  const cornerDistances = [
    Math.hypot(cx, cy),
    Math.hypot(cx, Math.max(height - cy, 0)),
    Math.hypot(Math.max(width - cx, 0), cy),
    Math.hypot(Math.max(width - cx, 0), Math.max(height - cy, 0))
  ];
  const cornerMin = Math.min(...cornerDistances);
  const cornerMax = Math.max(...cornerDistances);
  const keyword = typeof size === "string" ? size.toLowerCase() : void 0;
  if (keyword === "closest-side") {
    return sideMin;
  }
  if (keyword === "farthest-side") {
    return sideMax;
  }
  if (keyword === "closest-corner") {
    return cornerMin;
  }
  if (keyword === "farthest-corner" || keyword === void 0) {
    return cornerMax;
  }
  const explicit = parseLength2(size, Math.max(width, height));
  if (explicit !== void 0) {
    return explicit;
  }
  const fallback = Number.isFinite(fallbackRatio) ? fallbackRatio * Math.max(width, height) : cornerMax;
  return fallback;
}
function parseLength2(value, relativeTo) {
  if (!value) {
    return void 0;
  }
  const trimmed = value.trim().toLowerCase();
  if (trimmed.endsWith("%")) {
    const pct = Number.parseFloat(trimmed.slice(0, -1));
    if (Number.isFinite(pct)) {
      return pct / 100 * relativeTo;
    }
    return void 0;
  }
  if (trimmed.endsWith("px")) {
    const px = Number.parseFloat(trimmed);
    return Number.isFinite(px) ? px : void 0;
  }
  const numeric = Number.parseFloat(trimmed);
  return Number.isFinite(numeric) ? numeric : void 0;
}
function clamp(value, min, max) {
  if (!Number.isFinite(value)) {
    return min;
  }
  if (value < min) return min;
  if (value > max) return max;
  return value;
}
function rawNumber(value) {
  return Number.isFinite(value) ? value : 0;
}
function clampUnit(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
}
function convertToImageRef(layer, info) {
  return {
    src: layer.resolvedUrl ?? layer.originalUrl ?? "",
    width: info.width,
    height: info.height,
    format: info.format,
    channels: info.channels,
    bitsPerComponent: info.bitsPerChannel,
    data: info.data
  };
}

// src/pdf/utils/clip-path-resolver.ts
function resolveClipPath(node, boxes) {
  const clip = node.style.clipPath;
  if (!clip || clip.type !== "polygon" || !clip.points.length) {
    return void 0;
  }
  const referenceRect = selectReferenceRect(clip.referenceBox, boxes);
  if (!referenceRect || referenceRect.width <= 0 || referenceRect.height <= 0) {
    return void 0;
  }
  const points = clip.points.map((point) => {
    const x = resolveClipLength(point.x, referenceRect.width);
    const y = resolveClipLength(point.y, referenceRect.height);
    return {
      x: referenceRect.x + x,
      y: referenceRect.y + y
    };
  });
  if (points.some((p) => !Number.isFinite(p.x) || !Number.isFinite(p.y))) {
    return void 0;
  }
  return { type: "polygon", points };
}
function selectReferenceRect(box, boxes) {
  switch (box) {
    case "padding-box":
      return boxes.paddingBox;
    case "content-box":
      return boxes.contentBox;
    case "border-box":
    default:
      return boxes.borderBox;
  }
}
function resolveClipLength(length, reference) {
  if (length.unit === "percent") {
    return length.value * reference;
  }
  return length.value;
}

// src/geometry/matrix.ts
function identityMatrix() {
  return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
}
function multiplyMatrices(m1, m2) {
  return {
    a: m1.a * m2.a + m1.c * m2.b,
    b: m1.b * m2.a + m1.d * m2.b,
    c: m1.a * m2.c + m1.c * m2.d,
    d: m1.b * m2.c + m1.d * m2.d,
    e: m1.a * m2.e + m1.c * m2.f + m1.e,
    f: m1.b * m2.e + m1.d * m2.f + m1.f
  };
}
function applyMatrixToPoint(matrix, x, y) {
  return {
    x: matrix.a * x + matrix.c * y + matrix.e,
    y: matrix.b * x + matrix.d * y + matrix.f
  };
}
function computeStrokeScale(viewportMatrix, transform) {
  const combined = multiplyMatrices(viewportMatrix, transform);
  const det = combined.a * combined.d - combined.b * combined.c;
  if (Number.isFinite(det) && det !== 0) {
    const scale = Math.sqrt(Math.abs(det));
    if (scale > 0) {
      return scale;
    }
  }
  const col1 = Math.hypot(combined.a, combined.b);
  const col2 = Math.hypot(combined.c, combined.d);
  const average = (col1 + col2) / 2;
  return average > 0 ? average : 1;
}

// src/transform/css-parser.ts
function parseTransform(raw) {
  if (!raw) {
    return null;
  }
  const regex = /([a-zA-Z]+)\(([^)]*)\)/g;
  let match;
  let current2 = identityMatrix();
  let found = false;
  while ((match = regex.exec(raw)) !== null) {
    const type = match[1].toLowerCase();
    const params = parseNumberList(match[2]);
    const matrix = transformFromValues(type, params);
    if (matrix) {
      current2 = multiplyMatrices(current2, matrix);
      found = true;
    }
  }
  return found ? current2 : null;
}
function transformFromValues(type, values) {
  switch (type) {
    case "matrix":
      if (values.length >= 6) {
        return {
          a: values[0],
          b: values[1],
          c: values[2],
          d: values[3],
          e: values[4],
          f: values[5]
        };
      }
      return null;
    case "translate": {
      const tx = Number.isFinite(values[0]) ? values[0] : 0;
      const ty = Number.isFinite(values[1]) ? values[1] : 0;
      return { a: 1, b: 0, c: 0, d: 1, e: tx, f: ty };
    }
    case "scale": {
      const sx = Number.isFinite(values[0]) ? values[0] : 1;
      const sy = Number.isFinite(values[1]) ? values[1] : sx;
      return { a: sx, b: 0, c: 0, d: sy, e: 0, f: 0 };
    }
    case "rotate": {
      const angle = (Number.isFinite(values[0]) ? values[0] : 0) * (Math.PI / 180);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      let base = { a: cos, b: sin, c: -sin, d: cos, e: 0, f: 0 };
      if (values.length >= 3 && Number.isFinite(values[1]) && Number.isFinite(values[2])) {
        const cx = values[1];
        const cy = values[2];
        const translateTo = { a: 1, b: 0, c: 0, d: 1, e: cx, f: cy };
        const translateBack = { a: 1, b: 0, c: 0, d: 1, e: -cx, f: -cy };
        base = multiplyMatrices(translateTo, multiplyMatrices(base, translateBack));
      }
      return base;
    }
    case "skewx": {
      const angle = (Number.isFinite(values[0]) ? values[0] : 0) * (Math.PI / 180);
      return { a: 1, b: 0, c: Math.tan(angle), d: 1, e: 0, f: 0 };
    }
    case "skewy": {
      const angle = (Number.isFinite(values[0]) ? values[0] : 0) * (Math.PI / 180);
      return { a: 1, b: Math.tan(angle), c: 0, d: 1, e: 0, f: 0 };
    }
    default:
      return null;
  }
}
function parseNumberList(value) {
  const result = [];
  const regex = /[-+]?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?/g;
  let match;
  while ((match = regex.exec(value)) !== null) {
    const parsed = Number.parseFloat(match[0]);
    if (Number.isFinite(parsed)) {
      result.push(parsed);
    }
  }
  return result;
}

// src/pdf/utils/text-utils.ts
function createTextRuns(node, color, inheritedDecorations) {
  const runs = [];
  const defaultColor = color ?? { r: 0, g: 0, b: 0, a: 1 };
  const effectiveTextAlign = resolveTextAlign(node) ?? node.style.textAlign;
  const decoration = inheritedDecorations ?? resolveDecorations(node.style);
  const fontFamily = node.style.fontFamily ?? "sans-serif";
  const fontSize = node.style.fontSize;
  const fontWeight = node.style.fontWeight;
  const fontStyle = node.style.fontStyle;
  const fontVariant = node.style.fontVariant;
  const letterSpacing = node.style.letterSpacing;
  if (node.inlineRuns && node.inlineRuns.length > 0) {
    for (const inlineRun of node.inlineRuns) {
      const justifyLine = effectiveTextAlign === "justify" && !inlineRun.isLastLine;
      let wordSpacing;
      const targetWidth = inlineRun.targetWidth ?? inlineRun.lineWidth ?? inlineRun.width;
      const lineWidth = inlineRun.lineWidth ?? inlineRun.width;
      if (justifyLine && inlineRun.spaceCount > 0) {
        const slack = Math.max(targetWidth - lineWidth, 0);
        if (slack > 0) {
          wordSpacing = slack / inlineRun.spaceCount;
        }
      }
      const spacesInRun = inlineRun.text.split("").reduce(
        (count, ch) => ch === " " ? count + 1 : count,
        0
      );
      const extraWidth = spacesInRun > 0 && wordSpacing !== void 0 ? spacesInRun * wordSpacing : 0;
      const advanceWidth = inlineRun.width + extraWidth;
      const resolvedShadows = resolveTextShadows(node, defaultColor);
      const baseLineMatrix = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: inlineRun.startX,
        f: inlineRun.baseline
      };
      runs.push({
        text: inlineRun.text.normalize("NFC"),
        fontFamily,
        fontSize,
        fontWeight,
        fontStyle,
        fontVariant,
        fill: defaultColor,
        letterSpacing,
        lineMatrix: baseLineMatrix,
        wordSpacing,
        decorations: decoration ? { ...decoration } : void 0,
        advanceWidth,
        textShadows: resolvedShadows,
        // New metadata
        lineIndex: inlineRun.lineIndex,
        isLastLine: inlineRun.isLastLine,
        spacesInRun
      });
    }
    return runs;
  }
  if (node.lineBoxes && node.lineBoxes.length > 0) {
    const lineHeight = resolvedLineHeight(node.style);
    const parentIsTableCell = node.parent && (node.parent.tagName === "td" || node.parent.tagName === "th");
    const contentWidth = parentIsTableCell ? Math.max(node.parent.box.contentWidth, 0) : Math.max(node.box.contentWidth, 0);
    let alignY = node.box.y;
    let totalTextHeight = node.lineBoxes.length * lineHeight;
    if (node.style.verticalAlign === "middle") {
      alignY = node.box.y + (node.box.contentHeight - totalTextHeight) / 2;
    } else if (node.style.verticalAlign === "bottom") {
      alignY = node.box.y + (node.box.contentHeight - totalTextHeight);
    }
    const justify = effectiveTextAlign === "justify";
    for (let i = 0; i < node.lineBoxes.length; i++) {
      const line = node.lineBoxes[i];
      const normalizedText = line.text.normalize("NFC");
      const baseWidth = line.width ?? estimateLineWidth(normalizedText, node.style);
      const lineYOffset = i * lineHeight;
      const baseline = alignY + lineYOffset + fontSize;
      let wordSpacing;
      if (justify && i < node.lineBoxes.length - 1) {
        const gapCount = line.spaceCount ?? 0;
        if (gapCount > 0) {
          const targetWidth2 = line.targetWidth ?? contentWidth ?? baseWidth;
          const slack = Math.max(targetWidth2 - baseWidth, 0);
          if (slack > 0) {
            wordSpacing = slack / gapCount;
          }
        }
      }
      const targetWidth = line.targetWidth ?? baseWidth;
      const advanceWidth = wordSpacing !== void 0 && wordSpacing !== 0 && targetWidth > 0 ? Math.max(targetWidth, baseWidth) : Math.max(baseWidth, 0);
      let startX = node.box.x;
      if (advanceWidth > 0 && Number.isFinite(contentWidth) && contentWidth > 0) {
        const slack = Math.max(contentWidth - advanceWidth, 0);
        if (effectiveTextAlign === "center") {
          startX = node.box.x + slack / 2;
        } else if (effectiveTextAlign === "right" || effectiveTextAlign === "end") {
          startX = node.box.x + slack;
        }
      }
      const resolvedShadows = resolveTextShadows(node, defaultColor);
      const baseLineMatrix = { a: 1, b: 0, c: 0, d: 1, e: startX, f: baseline };
      runs.push({
        text: normalizedText,
        fontFamily,
        fontSize,
        fontWeight,
        fontStyle,
        fontVariant,
        fill: defaultColor,
        letterSpacing,
        lineMatrix: baseLineMatrix,
        wordSpacing,
        decorations: decoration ? { ...decoration } : void 0,
        advanceWidth,
        textShadows: resolvedShadows
      });
    }
    return runs;
  }
  if (node.textContent) {
    const raw = node.textContent;
    const transformed = applyTextTransform(raw, node.style.textTransform);
    const normalized = transformed.normalize("NFC");
    const baseline = node.box.baseline > 0 ? node.box.baseline : node.box.y + node.box.contentHeight;
    const advanceWidth = Math.max(estimateLineWidth(normalized, node.style), 0);
    const startX = resolveFallbackStartX(node, advanceWidth, effectiveTextAlign);
    const resolvedShadows = resolveTextShadows(node, defaultColor);
    const baseLineMatrix = { a: 1, b: 0, c: 0, d: 1, e: startX, f: baseline };
    return [{
      text: normalized,
      fontFamily,
      fontSize,
      fontWeight,
      fontStyle,
      fontVariant,
      letterSpacing,
      fill: defaultColor,
      lineMatrix: baseLineMatrix,
      decorations: decoration ? { ...decoration } : void 0,
      advanceWidth,
      textShadows: resolvedShadows
    }];
  }
  return [];
}

// src/pdf/utils/list-utils.ts
function createListMarkerRun(node, contentBox, children, fallbackColor) {
  const styleType = resolveListStyleType(node);
  if (!styleType || styleType === "none") {
    return void 0;
  }
  const markerIndex = computeListItemIndex(node);
  const markerText = formatListMarker(styleType, markerIndex);
  if (!markerText) {
    return void 0;
  }
  const firstRun = findFirstDescendantTextRun(children);
  const fontFamily = node.style.fontFamily ?? "sans-serif";
  const fontSize = node.style.fontSize;
  const fontWeight = node.style.fontWeight;
  const color = fallbackColor ?? { r: 0, g: 0, b: 0, a: 1 };
  const baseline = firstRun?.lineMatrix.f ?? (node.box.baseline > 0 ? node.box.baseline : contentBox.y + fontSize);
  const textStartX = firstRun?.lineMatrix.e ?? contentBox.x;
  const markerWidth = Math.max(estimateLineWidth(markerText, node.style), 0);
  const gap = Math.max(fontSize * 0.5, 6);
  const markerX = textStartX - gap - markerWidth;
  return {
    text: markerText,
    fontFamily,
    fontSize,
    fontWeight,
    fill: color,
    lineMatrix: { a: 1, b: 0, c: 0, d: 1, e: markerX, f: baseline },
    advanceWidth: markerWidth + gap
  };
}
function findFirstDescendantTextRun(children) {
  for (const child of children) {
    if (child.textRuns.length > 0) {
      return child.textRuns[0];
    }
    const nested = findFirstDescendantTextRun(child.children);
    if (nested) {
      return nested;
    }
  }
  return void 0;
}
function computeListItemIndex(node) {
  const parent = node.parent;
  if (!parent) {
    return 1;
  }
  let index = 0;
  for (const sibling of parent.children) {
    if (sibling.tagName === "li") {
      index += 1;
    }
    if (sibling === node) {
      break;
    }
  }
  return Math.max(index, 1);
}
var LIST_STYLE_MARKERS = {
  disc: "\u2022",
  //  BULLET
  circle: "\u25E6",
  //  WHITE BULLET
  square: "\u25AA"
  //  BLACK SMALL SQUARE
};
var DEFAULT_MARKER = LIST_STYLE_MARKERS.disc;
function formatListMarker(styleType, index) {
  const normalized = styleType.trim().toLowerCase();
  switch (normalized) {
    case "none":
      return void 0;
    case "decimal":
      return `${index}.`;
    case "decimal-leading-zero":
      return `${String(index).padStart(2, "0")}.`;
    case "lower-alpha":
      return `${toAlphaSequence(index).toLowerCase()}.`;
    case "upper-alpha":
      return `${toAlphaSequence(index).toUpperCase()}.`;
    case "lower-roman": {
      const roman = toRomanNumeral(index);
      return roman ? `${roman.toLowerCase()}.` : `${index}.`;
    }
    case "upper-roman": {
      const roman = toRomanNumeral(index);
      return roman ? `${roman.toUpperCase()}.` : `${index}.`;
    }
    case "disc":
    case "circle":
    case "square":
      return LIST_STYLE_MARKERS[normalized];
    default:
      return DEFAULT_MARKER;
  }
}
function toAlphaSequence(index) {
  let n = Math.max(1, Math.floor(index));
  let result = "";
  while (n > 0) {
    n -= 1;
    const charCode = 65 + n % 26;
    result = String.fromCharCode(charCode) + result;
    n = Math.floor(n / 26);
  }
  return result;
}
function toRomanNumeral(index) {
  if (!Number.isFinite(index) || index <= 0 || index >= 4e3) {
    return void 0;
  }
  const romanPairs = [
    [1e3, "M"],
    [900, "CM"],
    [500, "D"],
    [400, "CD"],
    [100, "C"],
    [90, "XC"],
    [50, "L"],
    [40, "XL"],
    [10, "X"],
    [9, "IX"],
    [5, "V"],
    [4, "IV"],
    [1, "I"]
  ];
  let remainder = Math.floor(index);
  let result = "";
  for (const [value, numeral] of romanPairs) {
    while (remainder >= value) {
      result += numeral;
      remainder -= value;
    }
    if (remainder === 0) {
      break;
    }
  }
  return result;
}
function resolveListStyleType(node) {
  const own = normalizeListStyleType(node.style.listStyleType);
  if (own === "none") {
    return "none";
  }
  if (own && own !== "disc") {
    return own;
  }
  const parent = node.parent;
  if (parent) {
    const parentStyle = normalizeListStyleType(parent.style.listStyleType);
    if (parentStyle === "none") {
      return "none";
    }
    if (parentStyle) {
      return parentStyle;
    }
    if (parent.tagName === "ol") {
      return "decimal";
    }
    if (parent.tagName === "ul") {
      return "disc";
    }
  }
  return own ?? "disc";
}
function normalizeListStyleType(value) {
  if (!value) {
    return void 0;
  }
  const normalized = value.trim().toLowerCase();
  return normalized.length > 0 ? normalized : void 0;
}

// src/pdf/transform-adapter.ts
function svgMatrixToPdf(matrix) {
  if (!matrix) return null;
  const F = { a: 1, b: 0, c: 0, d: -1, e: 0, f: 0 };
  return multiplyMatrices(multiplyMatrices(F, matrix), F);
}

// src/pdf/utils/node-text-run-factory.ts
function buildNodeTextRuns(context) {
  const { node, children, borderBox, contentBox, textColor, decorations, transform, fallbackColor, fontResolver, textGradient } = context;
  const textRuns = createTextRuns(node, textColor, decorations);
  if (fontResolver) {
    enrichTextRunsWithGlyphs(textRuns, fontResolver);
  }
  if (node.tagName === "li") {
    const markerRun = createListMarkerRun(node, contentBox, children, textColor ?? fallbackColor);
    if (markerRun) {
      textRuns.unshift(markerRun);
    }
  }
  if (textGradient) {
    for (const run of textRuns) {
      run.textGradient = textGradient;
    }
  }
  if (transform && textRuns.length > 0) {
    applyTransformToTextRuns(textRuns, transform, borderBox);
  }
  return textRuns;
}
function applyTransformToTextRuns(runs, cssMatrix, originBox) {
  if (runs.length === 0) {
    return;
  }
  const pdfMatrix = svgMatrixToPdf(cssMatrix);
  if (!pdfMatrix) {
    return;
  }
  const baseOriginX = Number.isFinite(originBox.x) ? originBox.x : 0;
  const baseOriginY = Number.isFinite(originBox.y) ? originBox.y : 0;
  const originWidth = Number.isFinite(originBox.width) ? originBox.width : 0;
  const originHeight = Number.isFinite(originBox.height) ? originBox.height : 0;
  const originX = baseOriginX + originWidth / 2;
  const originY = baseOriginY + originHeight / 2;
  const toOrigin = translationMatrix(-originX, -originY);
  const fromOrigin = translationMatrix(originX, originY);
  for (const run of runs) {
    const baseMatrix = run.lineMatrix ?? { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
    const localMatrix = multiplyMatrices(toOrigin, baseMatrix);
    const transformedLocal = multiplyMatrices(pdfMatrix, localMatrix);
    run.lineMatrix = multiplyMatrices(fromOrigin, transformedLocal);
  }
}
function translationMatrix(tx, ty) {
  return { a: 1, b: 0, c: 0, d: 1, e: tx, f: ty };
}
function enrichTextRunsWithGlyphs(runs, fontResolver) {
  for (const run of runs) {
    try {
      const font = fontResolver.resolveSync ? fontResolver.resolveSync(run.fontFamily, run.fontWeight, run.fontStyle) : void 0;
      if (!font) {
        continue;
      }
      const glyphRun = computeGlyphRun(font, run.text, run.fontSize, run.letterSpacing ?? 0);
      if (run.wordSpacing !== void 0 && glyphRun.positions.length > 0) {
        applyWordSpacingToGlyphRun(glyphRun, run.text, run.wordSpacing);
      }
      run.glyphs = glyphRun;
    } catch (error) {
      console.warn(`Failed to create GlyphRun for text "${run.text}": ${error}`);
    }
  }
}
function computeGlyphRun(font, text, fontSize, letterSpacing) {
  const glyphIds = [];
  const positions = [];
  let currentX = 0;
  const kerning = font.metrics.kerning;
  const unitsPerEm = font.metrics.metrics.unitsPerEm;
  let prevGid = null;
  for (let i = 0; i < text.length; i++) {
    const codePoint = text.codePointAt(i) ?? 0;
    const glyphId = font.metrics.cmap.getGlyphId(codePoint);
    glyphIds.push(glyphId);
    const glyphMetric = font.metrics.glyphMetrics.get(glyphId);
    const advanceWidth = glyphMetric?.advanceWidth ?? 0;
    if (prevGid !== null && kerning) {
      const kernAdjust = getKerningAdjustment(kerning, prevGid, glyphId);
      if (kernAdjust !== 0) {
        currentX += kernAdjust / unitsPerEm * fontSize;
      }
    }
    const scaledAdvance = advanceWidth / unitsPerEm * fontSize;
    positions.push({ x: currentX, y: 0 });
    currentX += scaledAdvance;
    if (i < text.length - 1) {
      currentX += letterSpacing;
    }
    if (codePoint > 65535) {
      i++;
    }
    prevGid = glyphId;
  }
  return {
    font,
    glyphIds,
    positions,
    text,
    fontSize,
    width: currentX
  };
}
function applyWordSpacingToGlyphRun(glyphRun, text, wordSpacing) {
  if (!wordSpacing) {
    return;
  }
  const additional = wordSpacing;
  for (let idx = 0; idx < glyphRun.positions.length; idx++) {
    const ch = text[idx];
    if (ch === " " && idx < glyphRun.positions.length - 1) {
      for (let j = idx + 1; j < glyphRun.positions.length; j++) {
        glyphRun.positions[j] = {
          x: glyphRun.positions[j].x + additional,
          y: glyphRun.positions[j].y
        };
      }
    }
  }
}
function getKerningAdjustment(map, left, right) {
  const rightMap = map.get(left);
  if (!rightMap) return 0;
  return rightMap.get(right) ?? 0;
}

// src/pdf/layout-tree-builder.ts
function buildRenderTree(root, options = {}) {
  const dpiAssumption = options.dpiAssumption ?? 96;
  const stylesheets = {
    fontFaces: options.stylesheets?.fontFaces ?? []
  };
  const headerFooter = {
    headerHtml: options.headerFooter?.headerHtml,
    footerHtml: options.headerFooter?.footerHtml,
    headerFirstHtml: options.headerFooter?.headerFirstHtml,
    footerFirstHtml: options.headerFooter?.footerFirstHtml,
    headerEvenHtml: options.headerFooter?.headerEvenHtml,
    footerEvenHtml: options.headerFooter?.footerEvenHtml,
    headerOddHtml: options.headerFooter?.headerOddHtml,
    footerOddHtml: options.headerFooter?.footerOddHtml,
    placeholders: options.headerFooter?.placeholders ?? {},
    layerMode: options.headerFooter?.layerMode ?? "under" /* Under */,
    maxHeaderHeightPx: options.headerFooter?.maxHeaderHeightPx ?? 0,
    maxFooterHeightPx: options.headerFooter?.maxFooterHeightPx ?? 0,
    clipOverflow: options.headerFooter?.clipOverflow ?? false,
    fontFamily: options.headerFooter?.fontFamily
  };
  const state = { counter: 0, fontResolver: options.fontResolver };
  const renderRoot = convertNode(root, state);
  return {
    root: renderRoot,
    dpiAssumption,
    css: stylesheets,
    hf: headerFooter
  };
}
var DEFAULT_TEXT_COLOR = { r: 0, g: 0, b: 0, a: 1 };
function mapNodeKind(node) {
  if (node.tagName === "img") {
    return "image" /* Image */;
  }
  if (node.tagName === "svg" && node.customData && "svg" in node.customData) {
    return "svg" /* Svg */;
  }
  if (node.tagName === "li") {
    return "list-item" /* ListItem */;
  }
  if (node.textContent && node.textContent.length > 0) {
    return "text-runs" /* TextRuns */;
  }
  return "container" /* Container */;
}
function mapPosition(style) {
  if (style.float !== "none" /* None */) {
    return { type: "float" };
  }
  switch (style.position) {
    case "absolute" /* Absolute */:
      return { type: "absolute" };
    case "fixed" /* Fixed */:
      return { type: "fixed" };
    case "sticky" /* Sticky */:
      return { type: "sticky" };
    default:
      return { type: "normal" };
  }
}
function mapOverflow(mode) {
  switch (mode) {
    case "hidden" /* Hidden */:
      return "hidden" /* Hidden */;
    case "scroll" /* Scroll */:
      return "scroll" /* Scroll */;
    case "auto" /* Auto */:
      return "auto" /* Auto */;
    case "clip" /* Clip */:
      return "clip" /* Clip */;
    default:
      return "visible" /* Visible */;
  }
}
function convertNode(node, state, inheritedTextGradient) {
  const originalId = node.customData?.id;
  const id = originalId || `node-${state.counter++}`;
  const { borderBox, paddingBox, contentBox } = calculateBoxDimensions(node);
  const textColor = parseColor(node.style.color);
  const fallbackShadowColor = textColor ?? DEFAULT_TEXT_COLOR;
  const boxShadows = resolveBoxShadows(node, fallbackShadowColor);
  const visualOverflow = calculateVisualOverflow(node, borderBox, boxShadows);
  const borderRadius = resolveBorderRadius(node.style, borderBox);
  const transformString = node.style.transform;
  const transform = transformString ? parseTransform(transformString) ?? void 0 : void 0;
  const ownTextGradient = resolveTextGradientLayer(node, { borderBox, paddingBox, contentBox });
  if (ownTextGradient) {
    log("layout", "debug", "node has background-clip:text gradient", {
      tagName: node.tagName,
      rect: ownTextGradient.rect
    });
  }
  const textGradient = ownTextGradient ?? inheritedTextGradient;
  const children = node.children.map((child) => convertNode(child, state, textGradient));
  const imageRef = extractImageRef(node);
  const decorations = resolveDecorations(node.style);
  const textRuns = buildNodeTextRuns({
    node,
    children,
    borderBox,
    contentBox,
    textColor,
    decorations,
    transform: transform ?? void 0,
    fallbackColor: textColor ?? DEFAULT_TEXT_COLOR,
    fontResolver: state.fontResolver,
    textGradient
  });
  log("layout", "debug", "node converted", {
    tagName: node.tagName,
    textContent: node.textContent?.slice(0, 40),
    fontFamily: node.style.fontFamily,
    fontSize: node.style.fontSize,
    contentBox
  });
  const background = resolveBackgroundLayers(node, { borderBox, paddingBox, contentBox });
  const clipPath = resolveClipPath(node, { borderBox, paddingBox, contentBox });
  const zIndex = typeof node.style.zIndex === "number" ? node.style.zIndex : 0;
  const establishesStackingContext = typeof node.style.zIndex === "number" && node.style.position !== "static" /* Static */;
  const borderStyle = {
    top: normalizeBorderStyle(node.style.borderStyleTop),
    right: normalizeBorderStyle(node.style.borderStyleRight),
    bottom: normalizeBorderStyle(node.style.borderStyleBottom),
    left: normalizeBorderStyle(node.style.borderStyleLeft)
  };
  const rawTextAlign = resolveTextAlign(node);
  const textAlign = rawTextAlign === "left" || rawTextAlign === "center" || rawTextAlign === "right" || rawTextAlign === "justify" ? rawTextAlign : void 0;
  return {
    id,
    tagName: node.tagName,
    textContent: node.textContent,
    kind: mapNodeKind(node),
    contentBox,
    paddingBox,
    borderBox,
    visualOverflow,
    padding: {
      top: resolveLength(node.style.paddingTop, Math.max(node.box.contentWidth, 0), { auto: "zero" }),
      right: resolveLength(node.style.paddingRight, Math.max(node.box.contentWidth, 0), { auto: "zero" }),
      bottom: resolveLength(node.style.paddingBottom, Math.max(node.box.contentWidth, 0), { auto: "zero" }),
      left: resolveLength(node.style.paddingLeft, Math.max(node.box.contentWidth, 0), { auto: "zero" })
    },
    border: {
      top: resolveLength(node.style.borderTop, Math.max(node.box.contentWidth, 0), { auto: "zero" }),
      right: resolveLength(node.style.borderRight, Math.max(node.box.contentWidth, 0), { auto: "zero" }),
      bottom: resolveLength(node.style.borderBottom, Math.max(node.box.contentWidth, 0), { auto: "zero" }),
      left: resolveLength(node.style.borderLeft, Math.max(node.box.contentWidth, 0), { auto: "zero" })
    },
    borderRadius,
    opacity: node.style.opacity ?? 1,
    overflow: mapOverflow(node.style.overflowX ?? "visible" /* Visible */),
    textRuns,
    decorations: decorations ?? {},
    textShadows: resolveTextShadows(node, fallbackShadowColor),
    boxShadows: resolveBoxShadows(node, textColor ?? DEFAULT_TEXT_COLOR),
    establishesStackingContext,
    zIndexComputed: zIndex,
    positioning: mapPosition(node.style),
    children,
    links: [],
    borderColor: parseColor(node.style.borderColor),
    borderStyle,
    color: textColor,
    background,
    clipPath,
    image: imageRef,
    customData: node.customData ? { ...node.customData } : void 0,
    textAlign,
    transform
  };
}
function normalizeBorderStyle(value) {
  if (!value) {
    return "solid";
  }
  const keyword = value.toLowerCase();
  if (keyword === "dashed" || keyword === "dotted" || keyword === "double") {
    return keyword;
  }
  if (keyword === "none" || keyword === "hidden") {
    return "none";
  }
  return "solid";
}

// src/pdf/primitives/pdf-reference-manager.ts
var PdfReferenceManager = class {
  constructor() {
    this.currentObjectNumber = 1;
  }
  /**
   * Creates a new PDF object reference with an unassigned object number.
   * The actual number will be assigned later by ensureRefNumber().
   */
  createRef() {
    return { objectNumber: -1 };
  }
  /**
   * Ensures the given reference has a valid object number.
   * If the reference already has a number, it updates the internal counter.
   * Otherwise, it assigns the next available number.
   */
  ensureRefNumber(ref) {
    if (ref.objectNumber <= 0) {
      ref.objectNumber = this.currentObjectNumber++;
    } else if (ref.objectNumber >= this.currentObjectNumber) {
      this.currentObjectNumber = ref.objectNumber + 1;
    }
    return ref;
  }
  /**
   * Returns the next available object number without incrementing.
   */
  getNextObjectNumber() {
    return this.currentObjectNumber;
  }
  /**
   * Returns the current total count of objects (for PDF size field).
   */
  getObjectCount() {
    return this.currentObjectNumber;
  }
};

// src/pdf/primitives/pdf-resource-registries.ts
var FontRegistry = class {
  constructor() {
    this.fonts = /* @__PURE__ */ new Map();
  }
  register(baseFont) {
    const existing = this.fonts.get(baseFont);
    if (existing) {
      return existing.objectRef;
    }
    const objectRef = { objectNumber: -1 };
    this.fonts.set(baseFont, { name: baseFont, baseFont, objectRef });
    return objectRef;
  }
  getAll() {
    return Array.from(this.fonts.values());
  }
};
var ImageRegistry = class {
  constructor() {
    this.images = [];
  }
  register(image) {
    if (image.src) {
      for (const existing of this.images) {
        if (existing.src === image.src && existing.width === image.width && existing.height === image.height) {
          return existing.ref;
        }
      }
    }
    if (image.format === "png" && image.channels === 4) {
      return this.registerPngWithAlpha(image);
    }
    const colorSpace = image.channels === 1 ? "DeviceGray" : image.channels === 3 ? "DeviceRGB" : "DeviceRGB";
    const filter2 = image.format === "jpeg" ? "DCTDecode" : void 0;
    const ref = { objectNumber: -1 };
    this.images.push({
      ref,
      src: image.src,
      width: image.width,
      height: image.height,
      colorSpace,
      bitsPerComponent: image.bitsPerComponent,
      filter: filter2,
      data: image.data.slice(),
      sMask: void 0
    });
    return ref;
  }
  registerPngWithAlpha(image) {
    const rgbData = new Uint8Array(image.width * image.height * 3);
    const alphaData = new Uint8Array(image.width * image.height);
    for (let i = 0, j = 0, k = 0; i < image.data.length; i += 4, j += 3, k++) {
      rgbData[j] = image.data[i];
      rgbData[j + 1] = image.data[i + 1];
      rgbData[j + 2] = image.data[i + 2];
      alphaData[k] = image.data[i + 3];
    }
    const sMaskRef = { objectNumber: -1 };
    this.images.push({
      ref: sMaskRef,
      src: image.src,
      width: image.width,
      height: image.height,
      colorSpace: "DeviceGray",
      bitsPerComponent: 8,
      data: alphaData,
      sMask: void 0
    });
    const ref = { objectNumber: -1 };
    this.images.push({
      ref,
      src: image.src,
      width: image.width,
      height: image.height,
      colorSpace: "DeviceRGB",
      bitsPerComponent: 8,
      data: rgbData,
      sMask: sMaskRef
    });
    return ref;
  }
  getAll() {
    return this.images;
  }
};
var ExtGStateRegistry = class {
  constructor() {
    this.states = /* @__PURE__ */ new Map();
  }
  register(alpha) {
    const normalized = this.clampAlpha(alpha);
    const key2 = normalized.toFixed(4);
    const existing = this.states.get(key2);
    if (existing) {
      return existing.ref;
    }
    const ref = { objectNumber: -1 };
    this.states.set(key2, { ref, alpha: normalized });
    return ref;
  }
  clampAlpha(value) {
    if (!Number.isFinite(value)) return 1;
    if (value <= 0) return 0;
    if (value >= 1) return 1;
    return value;
  }
  getAll() {
    return Array.from(this.states.values());
  }
};
var ShadingRegistry = class {
  constructor() {
    this.shadings = /* @__PURE__ */ new Map();
  }
  register(name, dict) {
    const existing = this.shadings.get(name);
    if (existing) {
      return existing.ref;
    }
    const ref = { objectNumber: -1 };
    this.shadings.set(name, { ref, dict });
    return ref;
  }
  getAll() {
    return Array.from(this.shadings.values());
  }
};
var PatternRegistry = class {
  constructor() {
    this.patterns = /* @__PURE__ */ new Map();
  }
  register(name, dict) {
    const existing = this.patterns.get(name);
    if (existing) {
      return existing.ref;
    }
    const ref = { objectNumber: -1 };
    this.patterns.set(name, { ref, dict });
    return ref;
  }
  getAll() {
    return Array.from(this.patterns.values());
  }
};
var ObjectRegistry = class {
  constructor() {
    this.objects = [];
  }
  register(value) {
    const ref = { objectNumber: -1 };
    this.objects.push({ ref, value });
    return ref;
  }
  getAll() {
    return this.objects;
  }
};
var StreamRegistry = class {
  constructor() {
    this.streams = [];
  }
  register(data, headers = {}) {
    const ref = { objectNumber: -1 };
    this.streams.push({ ref, data, headers });
    return ref;
  }
  getAll() {
    return this.streams;
  }
};

// src/pdf/utils/encoding.ts
var WIN_ANSI_UNICODE = (() => {
  const table = new Array(256);
  for (let code = 0; code <= 255; code++) {
    table[code] = code;
  }
  const overrides = {
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376
  };
  for (const [codePoint, unicode] of Object.entries(overrides)) {
    const code = Number(codePoint);
    table[code] = unicode;
  }
  return table;
})();
var UNICODE_TO_WIN_ANSI = (() => {
  const map = /* @__PURE__ */ new Map();
  for (let code = 0; code <= 255; code++) {
    const unicode = WIN_ANSI_UNICODE[code];
    if (!map.has(unicode)) {
      map.set(unicode, code);
    }
  }
  return map;
})();
function encodeToWinAnsi(text) {
  let result = "", misses = 0, details = [];
  for (const char of text) {
    const codePoint = char.codePointAt(0);
    if (codePoint === void 0) {
      continue;
    }
    const byte = UNICODE_TO_WIN_ANSI.get(codePoint);
    if (byte === void 0) {
      misses++;
      details.push(codePoint);
      result += "?";
      continue;
    }
    result += String.fromCharCode(byte);
  }
  if (misses) {
    log("encoding", "debug", "WinAnsi misses", {
      misses,
      codepoints: details.slice(0, 20)
    });
  }
  return result;
}
function escapePdfLiteral(text) {
  return text.replace(/([()\\])/g, "\\$1");
}
function encodeAndEscapePdfText(text, scheme = "WinAnsi") {
  const before2 = text;
  const payload = scheme === "WinAnsi" ? encodeToWinAnsi(text) : text;
  log("encoding", "trace", "PdfText transformation", { scheme, before: before2, after: payload });
  return escapePdfLiteral(payload);
}

// src/pdf/primitives/pdf-bytes.ts
function encodeBinaryString(value) {
  const out = new Uint8Array(value.length);
  for (let i = 0; i < value.length; i++) {
    out[i] = value.charCodeAt(i) & 255;
  }
  return out;
}
var utf8Encoder = new TextEncoder();
function concatBytes(chunks) {
  let total = 0;
  for (const chunk of chunks) total += chunk.length;
  const out = new Uint8Array(total);
  let offset = 0;
  for (const chunk of chunks) {
    out.set(chunk, offset);
    offset += chunk.length;
  }
  return out;
}

// src/pdf/primitives/pdf-serializers.ts
function serializeValue(value) {
  if (typeof value === "number") return formatNumber(value);
  if (typeof value === "string") return value;
  if (Array.isArray(value))
    return `[${value.map((v) => serializeValue(v)).join(" ")}]`;
  if (typeof value === "object" && value !== null && "objectNumber" in value)
    return `${value.objectNumber} 0 R`;
  if (typeof value === "object" && value !== null) {
    const entries2 = Object.entries(value).map(
      ([k, v]) => `/${k} ${serializeValue(v)}`
    );
    return `<< ${entries2.join(" ")} >>`;
  }
  return "null";
}
function serializeType1Font(baseFont) {
  const body = [
    "<<",
    "/Type /Font",
    "/Subtype /Type1",
    `/BaseFont /${sanitizeName(baseFont)}`
  ];
  if (!usesSymbolEncoding(baseFont)) {
    body.push("/Encoding /WinAnsiEncoding");
  }
  body.push(">>");
  return body.join("\n");
}
function serializeExtGState(alpha) {
  const safeAlpha = clampUnitAlpha(alpha);
  const formatted = formatNumber(safeAlpha);
  return ["<<", "/Type /ExtGState", `/ca ${formatted}`, `/CA ${formatted}`, ">>"].join("\n");
}
function serializeStream(content, extraEntries = []) {
  const encoded = typeof content === "string" ? encodeBinaryString(content) : new Uint8Array(content);
  const entries2 = [`/Length ${encoded.length}`, ...extraEntries].join(" ");
  const header = encodeBinaryString(`<< ${entries2} >>
stream
`);
  const footer = encodeBinaryString("\nendstream");
  return concatBytes([header, encoded, footer]);
}
function serializeInfo(meta) {
  const entries2 = [];
  if (meta.title) {
    const encoded = encodeAndEscapePdfText(meta.title);
    log("pdf", "debug", "serializing metadata title", {
      title: meta.title.slice(0, 50),
      encoded
    });
    entries2.push(`/Title (${encoded})`);
  }
  if (meta.author) {
    const encoded = encodeAndEscapePdfText(meta.author);
    log("pdf", "debug", "serializing metadata author", {
      author: meta.author.slice(0, 50),
      encoded
    });
    entries2.push(`/Author (${encoded})`);
  }
  if (meta.subject) {
    const encoded = encodeAndEscapePdfText(meta.subject);
    log("pdf", "debug", "serializing metadata subject", {
      subject: meta.subject.slice(0, 50),
      encoded
    });
    entries2.push(`/Subject (${encoded})`);
  }
  if (meta.keywords?.length) {
    const keywordsText = meta.keywords.join(", ");
    const encoded = encodeAndEscapePdfText(keywordsText);
    log("pdf", "debug", "serializing metadata keywords", {
      keywords: keywordsText.slice(0, 50),
      encoded
    });
    entries2.push(`/Keywords (${encoded})`);
  }
  if (meta.producer) {
    const encoded = encodeAndEscapePdfText(meta.producer);
    log("pdf", "debug", "serializing metadata producer", {
      producer: meta.producer.slice(0, 50),
      encoded
    });
    entries2.push(`/Producer (${encoded})`);
  }
  return `<< ${entries2.join(" ")} >>`;
}
function serializeTrailer(size, catalogRef, infoRef) {
  const entries2 = [`/Size ${size}`, `/Root ${catalogRef.objectNumber} 0 R`];
  if (infoRef) {
    entries2.push(`/Info ${infoRef.objectNumber} 0 R`);
  }
  return `<< ${entries2.join(" ")} >>`;
}
function formatXref(offset) {
  return `${offset.toString().padStart(10, "0")} 00000 n 
`;
}
function formatNumber(value) {
  return Number.isInteger(value) ? value.toString() : value.toFixed(2).replace(/0+$/, "").replace(/\.$/, "");
}
function sanitizeName(name) {
  return name.replace(/[^!-~]/g, "");
}
function usesSymbolEncoding(baseFont) {
  const normalized = sanitizeName(baseFont).toLowerCase();
  return normalized === "symbol" || normalized === "zapfdingbats";
}
function hasMetadata(meta) {
  return Boolean(
    meta.title || meta.author || meta.subject || meta.keywords?.length || meta.producer
  );
}
function clampUnitAlpha(value) {
  if (!Number.isFinite(value)) return 1;
  if (value <= 0) return 0;
  if (value >= 1) return 1;
  return value;
}

// src/pdf/primitives/pdf-builder.ts
var PdfBuilder = class {
  constructor(metadata = {}) {
    this.metadata = metadata;
    this.pages = [];
    this.refManager = new PdfReferenceManager();
    // Public registries for resource management
    this.fontRegistry = new FontRegistry();
    this.imageRegistry = new ImageRegistry();
    this.extGStateRegistry = new ExtGStateRegistry();
    this.shadingRegistry = new ShadingRegistry();
    this.patternRegistry = new PatternRegistry();
    this.objectRegistry = new ObjectRegistry();
    this.streamRegistry = new StreamRegistry();
  }
  /**
   * Adds a page to the document.
   */
  addPage(page) {
    this.pages.push(page);
  }
  /**
   * Finalizes the document and returns the complete PDF as bytes.
   */
  finalize() {
    const objects = [];
    const header = encodeBinaryString("%PDF-1.4\n");
    const pushObject = (body, ref) => {
      const objectRef = this.refManager.ensureRefNumber(ref ?? { objectNumber: 0 });
      let payload;
      if (typeof body === "string") {
        payload = encodeBinaryString(body);
      } else if (body instanceof Uint8Array) {
        payload = body;
      } else {
        const serialized = serializeValue(body);
        payload = encodeBinaryString(serialized);
      }
      objects.push({ ref: objectRef, body: payload });
      return objectRef;
    };
    this.reserveObjectNumbers();
    this.buildFonts(pushObject);
    this.buildExtGStates(pushObject);
    this.buildShadings(pushObject);
    this.buildPatterns(pushObject);
    this.buildImages(pushObject);
    this.buildStreams(pushObject);
    this.buildCustomObjects(pushObject);
    const pageRefs = this.buildPages(pushObject);
    const pagesRef = this.buildPagesTree(pageRefs, pushObject);
    const catalogRef = this.buildCatalog(pagesRef, pushObject);
    const infoRef = this.buildMetadata(pushObject);
    return this.assemblePdf(header, objects, catalogRef, infoRef);
  }
  /**
   * Reserves object numbers for resources that may be referenced by others.
   */
  reserveObjectNumbers() {
    for (const stream of this.streamRegistry.getAll()) {
      this.refManager.ensureRefNumber(stream.ref);
    }
    for (const obj of this.objectRegistry.getAll()) {
      this.refManager.ensureRefNumber(obj.ref);
    }
    for (const pattern of this.patternRegistry.getAll()) {
      this.refManager.ensureRefNumber(pattern.ref);
    }
  }
  /**
   * Builds font objects.
   */
  buildFonts(pushObject) {
    for (const font of this.fontRegistry.getAll()) {
      font.objectRef = pushObject(serializeType1Font(font.baseFont), font.objectRef);
    }
  }
  /**
   * Builds ExtGState objects.
   */
  buildExtGStates(pushObject) {
    for (const state of this.extGStateRegistry.getAll()) {
      state.ref = pushObject(serializeExtGState(state.alpha), state.ref);
    }
  }
  /**
   * Builds shading objects.
   */
  buildShadings(pushObject) {
    for (const shading of this.shadingRegistry.getAll()) {
      shading.ref = pushObject(shading.dict, shading.ref);
    }
  }
  /**
   * Builds pattern objects.
   */
  buildPatterns(pushObject) {
    for (const pattern of this.patternRegistry.getAll()) {
      pattern.ref = pushObject(pattern.dict, pattern.ref);
    }
  }
  /**
   * Builds image XObject streams.
   */
  buildImages(pushObject) {
    for (const image of this.imageRegistry.getAll()) {
      const entries2 = [
        "/Type /XObject",
        "/Subtype /Image",
        `/Width ${image.width}`,
        `/Height ${image.height}`,
        `/ColorSpace /${image.colorSpace}`,
        `/BitsPerComponent ${image.bitsPerComponent}`
      ];
      if (image.filter) {
        entries2.push(`/Filter /${image.filter}`);
      }
      if (image.sMask) {
        entries2.push(`/SMask ${image.sMask.objectNumber} 0 R`);
      }
      const stream = serializeStream(image.data, entries2);
      image.ref = pushObject(stream, image.ref);
    }
  }
  /**
   * Builds custom stream objects.
   */
  buildStreams(pushObject) {
    for (const stream of this.streamRegistry.getAll()) {
      const entries2 = Object.entries(stream.headers).map(([k, v]) => `/${k} ${v}`);
      const body = serializeStream(stream.data, entries2);
      stream.ref = pushObject(body, stream.ref);
    }
  }
  /**
   * Builds custom registered objects.
   */
  buildCustomObjects(pushObject) {
    for (const obj of this.objectRegistry.getAll()) {
      obj.ref = pushObject(obj.value, obj.ref);
    }
  }
  /**
   * Builds page objects and returns their references.
   */
  buildPages(pushObject) {
    const pageRefs = [];
    for (const page of this.pages) {
      const contentRef = pushObject(serializeStream(page.contents));
      const resourcesParts = this.buildPageResources(page);
      const annotationRefs = this.buildPageAnnotations(page, pushObject);
      const resources = resourcesParts.length > 0 ? `/Resources << ${resourcesParts.join(" ")} >>` : "";
      const annots = annotationRefs.length > 0 ? `/Annots [${annotationRefs.map((r) => `${r.objectNumber} 0 R`).join(" ")}]` : "";
      const pageBody = [
        "<<",
        "/Type /Page",
        `/MediaBox [0 0 ${formatNumber(page.width)} ${formatNumber(page.height)}]`,
        resources,
        annots,
        `/Contents ${contentRef.objectNumber} 0 R`,
        ">>"
      ].filter(Boolean).join("\n");
      const pageRef = pushObject(pageBody);
      pageRefs.push(pageRef);
    }
    return pageRefs;
  }
  /**
   * Builds page resources dictionary parts.
   */
  buildPageResources(page) {
    const resourcesParts = [];
    const fontEntries = [];
    for (const [alias, ref] of page.resources.fonts) {
      fontEntries.push(`/${alias} ${ref.objectNumber} 0 R`);
    }
    if (fontEntries.length > 0) {
      resourcesParts.push(`/Font << ${fontEntries.join(" ")} >>`);
    }
    const xObjectEntries = [];
    for (const [alias, ref] of page.resources.xObjects) {
      xObjectEntries.push(`/${alias} ${ref.objectNumber} 0 R`);
    }
    if (xObjectEntries.length > 0) {
      resourcesParts.push(`/XObject << ${xObjectEntries.join(" ")} >>`);
    }
    const gStateEntries = [];
    for (const [alias, ref] of page.resources.extGStates) {
      gStateEntries.push(`/${alias} ${ref.objectNumber} 0 R`);
    }
    if (gStateEntries.length > 0) {
      resourcesParts.push(`/ExtGState << ${gStateEntries.join(" ")} >>`);
    }
    const shadingEntries = [];
    for (const [alias, ref] of page.resources.shadings) {
      shadingEntries.push(`/${alias} ${ref.objectNumber} 0 R`);
    }
    if (shadingEntries.length > 0) {
      resourcesParts.push(`/Shading << ${shadingEntries.join(" ")} >>`);
    }
    const patternEntries = [];
    if (page.resources.patterns) {
      for (const [alias, ref] of page.resources.patterns) {
        patternEntries.push(`/${alias} ${ref.objectNumber} 0 R`);
      }
      if (patternEntries.length > 0) {
        resourcesParts.push(`/Pattern << ${patternEntries.join(" ")} >>`);
      }
    }
    return resourcesParts;
  }
  /**
   * Builds page annotation objects.
   */
  buildPageAnnotations(page, pushObject) {
    const annotationRefs = [];
    for (const annotation of page.annotations) {
      const annotRef = pushObject(annotation);
      annotationRefs.push(annotRef);
    }
    return annotationRefs;
  }
  /**
   * Builds the Pages tree object.
   */
  buildPagesTree(pageRefs, pushObject) {
    const kids = pageRefs.map((ref) => `${ref.objectNumber} 0 R`).join(" ");
    return pushObject(
      ["<<", "/Type /Pages", `/Count ${pageRefs.length}`, `/Kids [${kids}]`, ">>"].join("\n")
    );
  }
  /**
   * Builds the Catalog object.
   */
  buildCatalog(pagesRef, pushObject) {
    return pushObject(
      ["<<", "/Type /Catalog", `/Pages ${pagesRef.objectNumber} 0 R`, ">>"].join("\n")
    );
  }
  /**
   * Builds the Info (metadata) object if metadata is present.
   */
  buildMetadata(pushObject) {
    if (hasMetadata(this.metadata)) {
      return pushObject(serializeInfo(this.metadata));
    }
    return null;
  }
  /**
   * Assembles the final PDF byte array.
   */
  assemblePdf(header, objects, catalogRef, infoRef) {
    const xrefEntries = ["0000000000 65535 f \n"];
    const chunks = [header];
    let offset = header.length;
    for (const object of objects) {
      const objectHeader = encodeBinaryString(`${object.ref.objectNumber} 0 obj
`);
      const objectFooter = encodeBinaryString("\nendobj\n");
      const objectBuffer = concatBytes([objectHeader, object.body, objectFooter]);
      xrefEntries.push(formatXref(offset));
      chunks.push(objectBuffer);
      offset += objectBuffer.length;
    }
    const xrefStart = offset;
    const size = this.refManager.getObjectCount();
    const trailerBody = encodeBinaryString(
      `xref
0 ${size}
${xrefEntries.join("")}trailer
${serializeTrailer(size, catalogRef, infoRef)}
startxref
${xrefStart}
%%EOF
`
    );
    chunks.push(trailerBody);
    return concatBytes(chunks);
  }
};

// src/pdf/primitives/pdf-document.ts
var PdfDocument = class {
  constructor(metadata = {}) {
    this.builder = new PdfBuilder(metadata);
  }
  /**
   * Registers a standard Type1 font and returns a reference to it.
   */
  registerStandardFont(baseFont) {
    return this.builder.fontRegistry.register(baseFont);
  }
  /**
   * Adds a page to the document.
   */
  addPage(page) {
    const resources = {
      fonts: page.resources?.fonts ?? /* @__PURE__ */ new Map(),
      xObjects: page.resources?.xObjects ?? /* @__PURE__ */ new Map(),
      extGStates: page.resources?.extGStates ?? /* @__PURE__ */ new Map(),
      shadings: page.resources?.shadings ?? /* @__PURE__ */ new Map(),
      patterns: page.resources?.patterns ?? /* @__PURE__ */ new Map()
    };
    this.builder.addPage({
      width: page.width,
      height: page.height,
      contents: page.contents,
      resources,
      annotations: page.annotations ?? []
    });
  }
  /**
   * Registers an image and returns a reference to it.
   * Handles deduplication and PNG alpha channel separation automatically.
   */
  registerImage(image) {
    return this.builder.imageRegistry.register(image);
  }
  /**
   * Registers an ExtGState with the given alpha value.
   * Automatically deduplicates by alpha value.
   */
  registerExtGState(alpha) {
    return this.builder.extGStateRegistry.register(alpha);
  }
  /**
   * Registers a shading resource.
   */
  registerShading(name, dict) {
    return this.builder.shadingRegistry.register(name, dict);
  }
  /**
   * Registers a pattern resource.
   */
  registerPattern(name, dict) {
    return this.builder.patternRegistry.register(name, dict);
  }
  /**
   * Registers a custom PDF object.
   */
  register(value) {
    return this.builder.objectRegistry.register(value);
  }
  /**
   * Registers a stream object with custom headers.
   */
  registerStream(data, extraHeaders = {}) {
    return this.builder.streamRegistry.register(data, extraHeaders);
  }
  /**
   * Finalizes the PDF document and returns the complete PDF as a byte array.
   */
  finalize() {
    return this.builder.finalize();
  }
};

// src/pdf/header-footer-layout.ts
function initHeaderFooterContext(hf, pageSize, basePageBox) {
  return { hf, pageSize, baseBox: basePageBox };
}
function layoutHeaderFooterTrees(ctx, pxToPt3) {
  const headerVariants = prepareVariants(ctx.hf, pxToPt3, "header");
  const footerVariants = prepareVariants(ctx.hf, pxToPt3, "footer");
  const headerHeightPt = resolveVariantHeight(headerVariants);
  const footerHeightPt = resolveVariantHeight(footerVariants);
  const headerHeightPx = resolveVariantHeightPx(headerVariants);
  const footerHeightPx = resolveVariantHeightPx(footerVariants);
  return {
    headerHeightPt,
    footerHeightPt,
    headerHeightPx,
    footerHeightPx,
    layerMode: ctx.hf.layerMode,
    header: headerVariants,
    footer: footerVariants,
    clipOverflow: ctx.hf.clipOverflow
  };
}
function adjustPageBoxForHf(baseBox, layout) {
  return {
    x: baseBox.x,
    y: baseBox.y + layout.headerHeightPx,
    width: baseBox.width,
    height: Math.max(0, baseBox.height - layout.headerHeightPx - layout.footerHeightPx)
  };
}
function pickHeaderVariant(layout, pageIndex, totalPages) {
  return pickVariant(layout.header, pageIndex, totalPages);
}
function pickFooterVariant(layout, pageIndex, totalPages) {
  return pickVariant(layout.footer, pageIndex, totalPages);
}
function prepareVariants(hf, pxToPt3, position) {
  const maxHeightPx = position === "header" ? hf.maxHeaderHeightPx ?? 0 : hf.maxFooterHeightPx ?? 0;
  const createVariant = (content) => {
    if (!content) {
      return void 0;
    }
    return {
      content,
      maxHeightPt: pxToPt3(maxHeightPx),
      maxHeightPx
    };
  };
  if (position === "header") {
    return {
      defaultVariant: createVariant(hf.headerHtml),
      firstVariant: createVariant(hf.headerFirstHtml),
      evenVariant: createVariant(hf.headerEvenHtml),
      oddVariant: createVariant(hf.headerOddHtml)
    };
  }
  return {
    defaultVariant: createVariant(hf.footerHtml),
    firstVariant: createVariant(hf.footerFirstHtml),
    evenVariant: createVariant(hf.footerEvenHtml),
    oddVariant: createVariant(hf.footerOddHtml)
  };
}
function resolveVariantHeight(variants) {
  const heights = [
    variants.defaultVariant?.maxHeightPt ?? 0,
    variants.firstVariant?.maxHeightPt ?? 0,
    variants.evenVariant?.maxHeightPt ?? 0,
    variants.oddVariant?.maxHeightPt ?? 0
  ];
  return Math.max(...heights);
}
function resolveVariantHeightPx(variants) {
  const heights = [
    variants.defaultVariant?.maxHeightPx ?? 0,
    variants.firstVariant?.maxHeightPx ?? 0,
    variants.evenVariant?.maxHeightPx ?? 0,
    variants.oddVariant?.maxHeightPx ?? 0
  ];
  return Math.max(...heights);
}
function pickVariant(variants, pageIndex, totalPages) {
  if (pageIndex === 1 && variants.firstVariant) {
    return variants.firstVariant;
  }
  if (totalPages > 1) {
    if (pageIndex % 2 === 0 && variants.evenVariant) {
      return variants.evenVariant;
    }
    if (pageIndex % 2 === 1 && variants.oddVariant) {
      return variants.oddVariant;
    }
  }
  return variants.defaultVariant;
}

// src/pdf/header-footer-tokens.ts
function computeHfTokens(placeholders, _totalPages, meta = {}) {
  const tokens = /* @__PURE__ */ new Map();
  for (const [key2, value] of Object.entries(placeholders ?? {})) {
    tokens.set(key2, value);
  }
  tokens.set("page", (page, _total) => String(page));
  tokens.set("pageNumber", (page, _total) => String(page));
  tokens.set("pages", (_page, total) => String(total));
  tokens.set("totalPages", (_page, total) => String(total));
  if (!tokens.has("title") && meta.title) {
    tokens.set("title", meta.title);
  }
  tokens.set("date", () => (/* @__PURE__ */ new Date()).toLocaleDateString());
  return tokens;
}
function applyPlaceholders(template, tokens, pageIndex, totalPages) {
  let result = template.replace(/\{\{([^}]+)\}\}/g, (_, key2) => {
    const entry = tokens.get(key2.trim());
    if (entry === void 0) {
      return "";
    }
    if (typeof entry === "string") {
      return entry;
    }
    return entry(pageIndex, totalPages);
  });
  result = result.replace(/\{([^}]+)\}/g, (_, key2) => {
    const entry = tokens.get(key2.trim());
    if (entry === void 0) {
      return "";
    }
    if (typeof entry === "string") {
      return entry;
    }
    return entry(pageIndex, totalPages);
  });
  return result;
}

// src/css/parsers/registry.ts
var propertyParserRegistry = /* @__PURE__ */ new Map();
function registerPropertyParser(property, parser) {
  propertyParserRegistry.set(property, parser);
}
function getPropertyParser(property) {
  return propertyParserRegistry.get(property);
}

// src/css/parsers/flex-parser.ts
function mapDisplay(value) {
  switch (value) {
    case "block":
      return "block" /* Block */;
    case "inline":
      return "inline" /* Inline */;
    case "inline-block":
      return "inline-block" /* InlineBlock */;
    case "flex":
      return "flex" /* Flex */;
    case "grid":
      return "grid" /* Grid */;
    case "table":
      return "table" /* Table */;
    case "table-row":
      return "table-row" /* TableRow */;
    case "table-cell":
      return "table-cell" /* TableCell */;
    case "table-row-group":
      return "table-row-group" /* TableRowGroup */;
    case "table-header-group":
      return "table-header-group" /* TableHeaderGroup */;
    case "table-footer-group":
      return "table-footer-group" /* TableFooterGroup */;
    case "table-caption":
      return "table-caption" /* TableCaption */;
    case "none":
      return "none" /* None */;
    default:
      return void 0;
  }
}
function mapJustifyContent(value) {
  if (!value) {
    return void 0;
  }
  switch (value.trim().toLowerCase()) {
    case "flex-start":
      return "flex-start" /* FlexStart */;
    case "flex-end":
      return "flex-end" /* FlexEnd */;
    case "center":
      return "center" /* Center */;
    case "space-between":
      return "space-between" /* SpaceBetween */;
    case "space-around":
      return "space-around" /* SpaceAround */;
    case "space-evenly":
      return "space-evenly" /* SpaceEvenly */;
    case "start":
      return "start" /* Start */;
    case "end":
      return "end" /* End */;
    case "left":
      return "left" /* Left */;
    case "right":
      return "right" /* Right */;
    default:
      return void 0;
  }
}
function mapAlignItemsValue(value) {
  if (!value) {
    return void 0;
  }
  switch (value.trim().toLowerCase()) {
    case "flex-start":
      return "flex-start" /* FlexStart */;
    case "flex-end":
      return "flex-end" /* FlexEnd */;
    case "center":
      return "center" /* Center */;
    case "baseline":
      return "baseline" /* Baseline */;
    case "stretch":
      return "stretch" /* Stretch */;
    default:
      return void 0;
  }
}
function mapAlignContentValue(value) {
  if (!value) {
    return void 0;
  }
  switch (value.trim().toLowerCase()) {
    case "flex-start":
      return "flex-start" /* FlexStart */;
    case "flex-end":
      return "flex-end" /* FlexEnd */;
    case "center":
      return "center" /* Center */;
    case "space-between":
      return "space-between" /* SpaceBetween */;
    case "space-around":
      return "space-around" /* SpaceAround */;
    case "space-evenly":
      return "space-evenly" /* SpaceEvenly */;
    case "stretch":
      return "stretch" /* Stretch */;
    default:
      return void 0;
  }
}
function mapAlignSelfValue(value) {
  if (!value) {
    return void 0;
  }
  const normalized = value.trim().toLowerCase();
  if (normalized === "auto") {
    return "auto";
  }
  return mapAlignItemsValue(normalized);
}
function parseFlexDirectionValue(value) {
  if (!value) {
    return void 0;
  }
  const normalized = value.trim().toLowerCase();
  switch (normalized) {
    case "row":
    case "row-reverse":
    case "column":
    case "column-reverse":
      return normalized;
    default:
      return void 0;
  }
}

// src/css/parsers/display-flex-parser.ts
function parseDisplay(value, target) {
  target.display = mapDisplay(value);
}
function parseJustifyContent(value, target) {
  const mapped = mapJustifyContent(value);
  if (mapped !== void 0) {
    target.justifyContent = mapped;
  }
}
function parseAlignItems(value, target) {
  const mapped = mapAlignItemsValue(value);
  if (mapped !== void 0) {
    target.alignItems = mapped;
  }
}
function parseAlignContent(value, target) {
  const mapped = mapAlignContentValue(value);
  if (mapped !== void 0) {
    target.alignContent = mapped;
  }
}
function parseAlignSelf(value, target) {
  const mapped = mapAlignSelfValue(value);
  if (mapped !== void 0) {
    target.alignSelf = mapped;
  }
}
function parseFlexDirection(value, target) {
  const mapped = parseFlexDirectionValue(value);
  if (mapped !== void 0) {
    target.flexDirection = mapped;
  }
}
function parseFlexWrap(value, target) {
  const normalized = value.trim().toLowerCase();
  if (normalized === "nowrap") {
    target.flexWrap = false;
  } else if (normalized === "wrap" || normalized === "wrap-reverse") {
    target.flexWrap = true;
  }
}

// src/css/parsers/color-parser.ts
function parseColor2(value, target) {
  target.color = value;
}
function parseBackgroundColor(value, target) {
  if (!target.backgroundLayers) {
    target.backgroundLayers = [];
  }
  target.backgroundLayers.push({ kind: "color", color: value });
}

// src/css/utils.ts
function clampPositive(value) {
  if (!Number.isFinite(value ?? NaN)) {
    return 0;
  }
  const numeric = Number(value);
  return numeric > 0 ? numeric : 0;
}
function clampNonNegative2(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  return value < 0 ? 0 : value;
}
function splitCssCommaList(value) {
  const result = [];
  let current2 = "";
  let depth = 0;
  let quote = null;
  for (const char of value) {
    if (quote) {
      current2 += char;
      if (char === quote) {
        quote = null;
      }
      continue;
    }
    if (char === "'" || char === '"') {
      quote = char;
      current2 += char;
      continue;
    }
    if (char === "(") {
      depth += 1;
      current2 += char;
      continue;
    }
    if (char === ")") {
      depth = Math.max(0, depth - 1);
      current2 += char;
      continue;
    }
    if (char === "," && depth === 0) {
      if (current2.trim()) {
        result.push(current2.trim());
      }
      current2 = "";
      continue;
    }
    current2 += char;
  }
  if (current2.trim()) {
    result.push(current2.trim());
  }
  return result;
}
function splitCssList(value) {
  const result = [];
  let current2 = "";
  let depth = 0;
  let quote = null;
  for (const char of value) {
    if (quote) {
      current2 += char;
      if (char === quote) {
        quote = null;
      }
      continue;
    }
    if (char === "'" || char === '"') {
      quote = char;
      current2 += char;
      continue;
    }
    if (char === "(") {
      depth += 1;
      current2 += char;
      continue;
    }
    if (char === ")") {
      depth = Math.max(0, depth - 1);
      current2 += char;
      continue;
    }
    if (/\s/.test(char) && depth === 0) {
      if (current2.trim()) {
        result.push(current2.trim());
      }
      current2 = "";
      continue;
    }
    current2 += char;
  }
  if (current2.trim()) {
    result.push(current2.trim());
  }
  return result;
}

// src/css/parsers/border-parser.ts
var BORDER_STYLE_KEYWORDS = /* @__PURE__ */ new Set([
  "none",
  "hidden",
  "solid",
  "dashed",
  "dotted",
  "double",
  "groove",
  "ridge",
  "inset",
  "outset"
]);
var BORDER_WIDTH_KEYWORD_MAP = {
  thin: 1,
  medium: 3,
  thick: 5
};
var DEFAULT_BORDER_WIDTH = BORDER_WIDTH_KEYWORD_MAP.medium;
function parseBorderShorthand(value) {
  const parts = splitCssList(value);
  if (parts.length === 0) {
    return null;
  }
  let width;
  let style;
  let color;
  for (const part of parts) {
    const trimmed = part.trim();
    if (!trimmed) {
      continue;
    }
    if (width === void 0) {
      const maybeWidth = parseBorderWidth(trimmed);
      if (maybeWidth !== void 0) {
        width = maybeWidth;
        continue;
      }
    }
    const lower = trimmed.toLowerCase();
    if (!style && BORDER_STYLE_KEYWORDS.has(lower)) {
      style = lower;
      continue;
    }
    if (color === void 0) {
      color = trimmed;
    }
  }
  if (style === "none" || style === "hidden") {
    width = 0;
  } else if (width === void 0 && style) {
    width = DEFAULT_BORDER_WIDTH;
  }
  return { width, style, color };
}
function parseBorderWidth(value) {
  const trimmed = value.trim().toLowerCase();
  if (!trimmed) {
    return void 0;
  }
  if (trimmed in BORDER_WIDTH_KEYWORD_MAP) {
    return BORDER_WIDTH_KEYWORD_MAP[trimmed];
  }
  return parseLength(value);
}
function parseBorderRadiusShorthand(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return null;
  }
  const [horizontalPart, verticalPart] = trimmed.split("/").map((part) => part.trim());
  const horizontalValues = expandBorderRadiusList(horizontalPart);
  if (!horizontalValues) {
    return null;
  }
  const verticalValues = verticalPart ? expandBorderRadiusList(verticalPart) : horizontalValues;
  if (!verticalValues) {
    return null;
  }
  return {
    topLeft: { x: horizontalValues[0], y: verticalValues[0] },
    topRight: { x: horizontalValues[1], y: verticalValues[1] },
    bottomRight: { x: horizontalValues[2], y: verticalValues[2] },
    bottomLeft: { x: horizontalValues[3], y: verticalValues[3] }
  };
}
function parseBorderCornerRadius(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return void 0;
  }
  const [horizontalRaw, verticalRaw] = trimmed.split("/").map((part) => part.trim());
  const horizontalList = splitCssList(horizontalRaw);
  if (horizontalList.length === 0) {
    return void 0;
  }
  const horizontal = parseRadiusValue(horizontalList[0]);
  let vertical;
  if (verticalRaw) {
    const verticalList = splitCssList(verticalRaw);
    vertical = parseRadiusValue(verticalList[0]);
  } else if (horizontalList.length > 1) {
    vertical = parseRadiusValue(horizontalList[1]);
  } else {
    vertical = horizontal;
  }
  return { x: horizontal, y: vertical };
}
function parseRadiusValue(value) {
  const parsed = parseLength(value);
  if (parsed === void 0) {
    return 0;
  }
  if (typeof parsed === "number") {
    return clampPositive(parsed);
  }
  return parsed;
}
function expandBorderRadiusList(input) {
  if (!input) {
    return null;
  }
  const parts = splitCssList(input);
  if (parts.length === 0) {
    return null;
  }
  const resolved = parts.map((part) => parseRadiusValue(part));
  switch (resolved.length) {
    case 1:
      return [resolved[0], resolved[0], resolved[0], resolved[0]];
    case 2:
      return [resolved[0], resolved[1], resolved[0], resolved[1]];
    case 3:
      return [resolved[0], resolved[1], resolved[2], resolved[1]];
    default:
      return [resolved[0], resolved[1], resolved[2], resolved[3]];
  }
}

// src/css/parsers/box-shadow-parser.ts
function parseBoxShadowList(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return void 0;
  }
  const keyword = trimmed.toLowerCase();
  if (keyword === "none" || keyword === "initial") {
    return [];
  }
  if (keyword === "inherit" || keyword === "revert" || keyword === "revert-layer") {
    return void 0;
  }
  const layers = splitCssCommaList(trimmed);
  const result = [];
  for (const layer of layers) {
    const parsed = parseSingleBoxShadow(layer);
    if (parsed) {
      result.push(parsed);
    }
  }
  return result;
}
function parseSingleBoxShadow(input) {
  const tokens = splitCssList(input);
  if (tokens.length === 0) {
    return null;
  }
  let inset = false;
  const lengths = [];
  let color;
  for (const token of tokens) {
    const lowered = token.toLowerCase();
    if (lowered === "inset") {
      inset = true;
      continue;
    }
    const length = parseLength(token);
    if (length !== void 0) {
      lengths.push(length);
      continue;
    }
    if (color === void 0) {
      if (isColorLike(token)) {
        color = token;
        continue;
      }
    }
    continue;
  }
  if (lengths.length < 2) {
    return null;
  }
  const asLength = (value, clamp3 = false) => {
    if (value === void 0) {
      return 0;
    }
    if (typeof value === "number" && clamp3) {
      return clampNonNegative2(value);
    }
    if (typeof value === "number") {
      return value;
    }
    return value;
  };
  const offsetX = asLength(lengths[0]);
  const offsetY = asLength(lengths[1]);
  const blurRadius = asLength(lengths[2], true);
  const spreadRadius = asLength(lengths[3]);
  return {
    inset,
    offsetX,
    offsetY,
    blurRadius,
    spreadRadius,
    color
  };
}
function isColorLike(value) {
  const lowerValue = value.toLowerCase();
  if (lowerValue.startsWith("#") || lowerValue.startsWith("rgb(") || lowerValue.startsWith("rgba(") || lowerValue.startsWith("hsl(") || lowerValue.startsWith("hsla(")) {
    return true;
  }
  const colorNames = ["transparent", "black", "white", "red", "green", "blue", "yellow", "gray", "grey"];
  return colorNames.includes(lowerValue);
}

// src/css/shorthands/border-shorthand.ts
function applyBorderShorthand(value, applyWidth, applyColor, applyStyle) {
  const parsed = parseBorderShorthand(value);
  if (!parsed) {
    return;
  }
  if (applyStyle) {
    applyStyle(parsed.style);
  }
  if (parsed.style === "none" || parsed.style === "hidden") {
    applyWidth(0);
  } else if (parsed.width !== void 0) {
    applyWidth(parsed.width);
  } else if (parsed.style) {
    applyWidth(DEFAULT_BORDER_WIDTH);
  }
  if (parsed.color !== void 0) {
    applyColor(parsed.color);
  }
}
function applyBorderColorShorthand(value, applyColor) {
  const parts = splitCssList(value);
  if (parts.length === 0) {
    return;
  }
  const [top] = parts.length === 1 ? [parts[0], parts[0], parts[0], parts[0]] : parts.length === 2 ? [parts[0], parts[1], parts[0], parts[1]] : parts.length === 3 ? [parts[0], parts[1], parts[2], parts[1]] : [parts[0], parts[1], parts[2], parts[3]];
  if (top) {
    applyColor(top);
  }
}
function applyBorderStyleShorthand(value, apply) {
  const parts = splitCssList(value);
  if (parts.length === 0) {
    return;
  }
  apply(parts[0]?.toLowerCase());
}
function isNoneBorderStyle(value) {
  const parts = splitCssList(value);
  if (parts.length === 0) {
    return false;
  }
  const keyword = parts[0]?.toLowerCase();
  return keyword === "none" || keyword === "hidden";
}

// src/css/shorthands/box-shorthand.ts
function applyBoxShorthand(value, apply, parser = parseLengthOrAuto) {
  const parts = splitCssList(value);
  if (parts.length === 0) {
    return;
  }
  const resolved = parts.map((part) => parser(part));
  const [top, right, bottom, left] = resolved.length === 1 ? [resolved[0], resolved[0], resolved[0], resolved[0]] : resolved.length === 2 ? [resolved[0], resolved[1], resolved[0], resolved[1]] : resolved.length === 3 ? [resolved[0], resolved[1], resolved[2], resolved[1]] : [resolved[0], resolved[1], resolved[2], resolved[3]];
  apply(top, right, bottom, left);
}

// src/css/parsers/border-parser-extended.ts
function parseBorderColor(value, target) {
  applyBorderColorShorthand(value, (color) => {
    target.borderColor = color;
  });
}
function parseBoxShadow(value, target) {
  const parsed = parseBoxShadowList(value);
  if (parsed !== void 0) {
    target.boxShadows = parsed;
  }
}
function parseBorder(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderTop = width;
    target.borderRight = width;
    target.borderBottom = width;
    target.borderLeft = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    const keyword = style.toLowerCase();
    target.borderStyleTop = keyword;
    target.borderStyleRight = keyword;
    target.borderStyleBottom = keyword;
    target.borderStyleLeft = keyword;
  });
}
function parseBorderTop(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderTop = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    target.borderStyleTop = style.toLowerCase();
  });
}
function parseBorderRight(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderRight = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    target.borderStyleRight = style.toLowerCase();
  });
}
function parseBorderBottom(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderBottom = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    target.borderStyleBottom = style.toLowerCase();
  });
}
function parseBorderLeft(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderLeft = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    target.borderStyleLeft = style.toLowerCase();
  });
}
function parseBorderRadius(value, target) {
  const parsed = parseBorderRadiusShorthand(value);
  if (parsed) {
    target.borderTopLeftRadiusX = parsed.topLeft.x;
    target.borderTopLeftRadiusY = parsed.topLeft.y;
    target.borderTopRightRadiusX = parsed.topRight.x;
    target.borderTopRightRadiusY = parsed.topRight.y;
    target.borderBottomRightRadiusX = parsed.bottomRight.x;
    target.borderBottomRightRadiusY = parsed.bottomRight.y;
    target.borderBottomLeftRadiusX = parsed.bottomLeft.x;
    target.borderBottomLeftRadiusY = parsed.bottomLeft.y;
  }
}
function parseBorderTopLeftRadius(value, target) {
  const parsed = parseBorderCornerRadius(value);
  if (parsed) {
    target.borderTopLeftRadiusX = parsed.x;
    target.borderTopLeftRadiusY = parsed.y;
  }
}
function parseBorderTopRightRadius(value, target) {
  const parsed = parseBorderCornerRadius(value);
  if (parsed) {
    target.borderTopRightRadiusX = parsed.x;
    target.borderTopRightRadiusY = parsed.y;
  }
}
function parseBorderBottomRightRadius(value, target) {
  const parsed = parseBorderCornerRadius(value);
  if (parsed) {
    target.borderBottomRightRadiusX = parsed.x;
    target.borderBottomRightRadiusY = parsed.y;
  }
}
function parseBorderBottomLeftRadius(value, target) {
  const parsed = parseBorderCornerRadius(value);
  if (parsed) {
    target.borderBottomLeftRadiusX = parsed.x;
    target.borderBottomLeftRadiusY = parsed.y;
  }
}
function parseBorderWidth2(value, target) {
  applyBoxShorthand(
    value,
    (top, right, bottom, left) => {
      target.borderTop = top;
      target.borderRight = right;
      target.borderBottom = bottom;
      target.borderLeft = left;
    },
    parseBorderWidth
  );
}
function parseBorderTopWidth(value, target) {
  target.borderTop = parseBorderWidth(value) ?? target.borderTop;
}
function parseBorderRightWidth(value, target) {
  target.borderRight = parseBorderWidth(value) ?? target.borderRight;
}
function parseBorderBottomWidth(value, target) {
  target.borderBottom = parseBorderWidth(value) ?? target.borderBottom;
}
function parseBorderLeftWidth(value, target) {
  target.borderLeft = parseBorderWidth(value) ?? target.borderLeft;
}
function parseBorderTopColor(value, target) {
  if (value.trim()) {
    target.borderColor = value.trim();
  }
}
function parseBorderRightColor(value, target) {
  if (value.trim()) {
    target.borderColor = value.trim();
  }
}
function parseBorderBottomColor(value, target) {
  if (value.trim()) {
    target.borderColor = value.trim();
  }
}
function parseBorderLeftColor(value, target) {
  if (value.trim()) {
    target.borderColor = value.trim();
  }
}
function parseBorderStyle(value, target) {
  applyBorderStyleShorthand(value, (style) => {
    if (!style) {
      return;
    }
    const keyword = style.toLowerCase();
    target.borderStyleTop = keyword;
    target.borderStyleRight = keyword;
    target.borderStyleBottom = keyword;
    target.borderStyleLeft = keyword;
    if (keyword === "none" || keyword === "hidden") {
      target.borderTop = 0;
      target.borderRight = 0;
      target.borderBottom = 0;
      target.borderLeft = 0;
    }
  });
}
function parseBorderTopStyle(value, target) {
  const parts = value.trim().toLowerCase();
  if (!parts) return;
  target.borderStyleTop = parts;
  if (isNoneBorderStyle(value)) {
    target.borderTop = 0;
  }
}
function parseBorderRightStyle(value, target) {
  const parts = value.trim().toLowerCase();
  if (!parts) return;
  target.borderStyleRight = parts;
  if (isNoneBorderStyle(value)) {
    target.borderRight = 0;
  }
}
function parseBorderBottomStyle(value, target) {
  const parts = value.trim().toLowerCase();
  if (!parts) return;
  target.borderStyleBottom = parts;
  if (isNoneBorderStyle(value)) {
    target.borderBottom = 0;
  }
}
function parseBorderLeftStyle(value, target) {
  const parts = value.trim().toLowerCase();
  if (!parts) return;
  target.borderStyleLeft = parts;
  if (isNoneBorderStyle(value)) {
    target.borderLeft = 0;
  }
}
function parseBorderCollapse(value, target) {
  const keyword = value.trim().toLowerCase();
  target.borderModel = keyword === "collapse" ? "collapse" /* Collapse */ : "separate" /* Separate */;
}

// src/css/parsers/border-block-parser.ts
function parseBorderBlockStart(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderTop = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    target.borderStyleTop = style.toLowerCase();
  });
}
function parseBorderBlockEnd(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderBottom = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    target.borderStyleBottom = style.toLowerCase();
  });
}

// src/css/parsers/border-inline-parser.ts
function parseBorderInlineStart(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderLeft = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    target.borderStyleLeft = style.toLowerCase();
  });
}
function parseBorderInlineEnd(value, target) {
  applyBorderShorthand(value, (width) => {
    target.borderRight = width;
  }, (color) => {
    target.borderColor = color ?? target.borderColor;
  }, (style) => {
    if (!style) return;
    target.borderStyleRight = style.toLowerCase();
  });
}

// src/css/parsers/margin-parser.ts
function parseMargin(value, target) {
  applyBoxShorthand(value, (top, right, bottom, left) => {
    target.marginTop = top;
    target.marginRight = right;
    target.marginBottom = bottom;
    target.marginLeft = left;
  });
}
function parseMarginTop(value, target) {
  target.marginTop = parseLength(value) ?? target.marginTop;
}
function parseMarginRight(value, target) {
  target.marginRight = parseLengthOrAuto(value) ?? target.marginRight;
}
function parseMarginBottom(value, target) {
  target.marginBottom = parseLength(value) ?? target.marginBottom;
}
function parseMarginLeft(value, target) {
  target.marginLeft = parseLengthOrAuto(value) ?? target.marginLeft;
}

// src/css/parsers/margin-block-parser.ts
function parseMarginBlockStart(value, target) {
  target.marginTop = parseLength(value) ?? target.marginTop;
}
function parseMarginBlockEnd(value, target) {
  target.marginBottom = parseLength(value) ?? target.marginBottom;
}

// src/css/parsers/margin-inline-parser.ts
function parseMarginInlineStart(value, target) {
  target.marginLeft = parseLengthOrAuto(value) ?? target.marginLeft;
}
function parseMarginInlineEnd(value, target) {
  target.marginRight = parseLengthOrAuto(value) ?? target.marginRight;
}

// src/css/parsers/padding-parser.ts
function parsePadding(value, target) {
  applyBoxShorthand(value, (top, right, bottom, left) => {
    target.paddingTop = top;
    target.paddingRight = right;
    target.paddingBottom = bottom;
    target.paddingLeft = left;
  }, parseLength);
}
function parsePaddingTop(value, target) {
  target.paddingTop = parseLength(value) ?? target.paddingTop;
}
function parsePaddingRight(value, target) {
  target.paddingRight = parseLength(value) ?? target.paddingRight;
}
function parsePaddingBottom(value, target) {
  target.paddingBottom = parseLength(value) ?? target.paddingBottom;
}
function parsePaddingLeft(value, target) {
  target.paddingLeft = parseLength(value) ?? target.paddingLeft;
}

// src/css/parsers/padding-block-parser.ts
function parsePaddingBlockStart(value, target) {
  target.paddingTop = parseLength(value) ?? target.paddingTop;
}
function parsePaddingBlockEnd(value, target) {
  target.paddingBottom = parseLength(value) ?? target.paddingBottom;
}

// src/css/parsers/padding-inline-parser.ts
function parsePaddingInlineStart(value, target) {
  target.paddingLeft = parseLength(value) ?? target.paddingLeft;
}
function parsePaddingInlineEnd(value, target) {
  target.paddingRight = parseLength(value) ?? target.paddingRight;
}

// src/css/parsers/dimension-parser.ts
var PERCENT_LENGTH_REGEX2 = /^(-?\d+(?:\.\d+)?)%$/;
function parseLengthOrPercent2(value) {
  const parsed = parseLength(value);
  if (parsed !== void 0) {
    return parsed;
  }
  const match = PERCENT_LENGTH_REGEX2.exec(value.trim());
  if (!match) {
    return void 0;
  }
  const numeric = Number.parseFloat(match[1]);
  if (Number.isNaN(numeric)) {
    return void 0;
  }
  return percent(numeric / 100);
}
function parseWidth(value, target) {
  const parsed = parseLengthOrPercent2(value);
  if (parsed !== void 0) {
    target.width = parsed;
  }
}
function parseMinWidth(value, target) {
  const parsed = parseLengthOrPercent2(value);
  if (parsed !== void 0) {
    target.minWidth = parsed;
  }
}
function parseMaxWidth(value, target) {
  const parsed = parseLengthOrPercent2(value);
  if (parsed !== void 0) {
    target.maxWidth = parsed;
  }
}
function parseHeight(value, target) {
  const parsed = parseLengthOrPercent2(value);
  if (parsed !== void 0) {
    target.height = parsed;
  }
}
function parseMinHeight(value, target) {
  const parsed = parseLengthOrPercent2(value);
  if (parsed !== void 0) {
    target.minHeight = parsed;
  }
}
function parseMaxHeight(value, target) {
  const parsed = parseLengthOrPercent2(value);
  if (parsed !== void 0) {
    target.maxHeight = parsed;
  }
}
function parseFontSize(value, target) {
  target.fontSize = parseNumeric(value) ?? target.fontSize;
}
function parseLineHeightValue(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return void 0;
  }
  const normalized = trimmed.toLowerCase();
  if (normalized === "normal") {
    return { kind: "normal" };
  }
  if (/^[+-]?\d+(?:\.\d+)?%$/.test(normalized)) {
    const numeric = Number.parseFloat(normalized.slice(0, -1));
    if (Number.isNaN(numeric)) {
      return void 0;
    }
    return { kind: "unitless", value: numeric / 100 };
  }
  if (/^[+-]?\d+(?:\.\d+)?$/.test(normalized)) {
    const numeric = Number.parseFloat(normalized);
    if (Number.isNaN(numeric)) {
      return void 0;
    }
    return { kind: "unitless", value: numeric };
  }
  const parsed = parseLength(trimmed);
  if (parsed !== void 0) {
    return { kind: "length", value: parsed };
  }
  return void 0;
}
function parseLineHeight(value, target) {
  const parsed = parseLineHeightValue(value);
  if (parsed) {
    target.lineHeight = parsed;
  }
}
function parseZIndex(value, target) {
  const trimmed = value.trim();
  if (trimmed.toLowerCase() === "auto") {
    target.zIndex = "auto";
  } else if (/^-?\d+$/.test(trimmed)) {
    target.zIndex = Number.parseInt(trimmed, 10);
  }
}

// src/css/parsers/font-parser.ts
function parseFontFamily2(value, target) {
  target.fontFamily = value;
}
function parseFontStyle(value, target) {
  const normalized = value.trim().toLowerCase();
  if (normalized === "inherit") {
    return;
  }
  if (normalized === "normal" || normalized === "italic" || normalized === "oblique" || normalized.startsWith("oblique ")) {
    target.fontStyle = normalized.startsWith("oblique") ? "oblique" : normalized;
  }
}
function parseFontWeight(value, target, _units, inheritedFontWeight) {
  const parsed = parseFontWeightValue(value, inheritedFontWeight);
  if (parsed !== void 0) {
    target.fontWeight = parsed;
  }
}
function parseFontVariant(value, target) {
  const normalized = value.trim().toLowerCase();
  if (normalized === "inherit") {
    return;
  }
  if (normalized === "normal" || normalized === "small-caps") {
    target.fontVariant = normalized;
  }
}

// src/css/parsers/position-parser.ts
var PERCENT_LENGTH_REGEX3 = /^(-?\d+(?:\.\d+)?)%$/;
function parseLengthLike(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return void 0;
  }
  if (trimmed.toLowerCase() === "auto") {
    return "auto";
  }
  const parsed = parseLength(trimmed);
  if (parsed !== void 0) {
    return parsed;
  }
  const percentMatch = PERCENT_LENGTH_REGEX3.exec(trimmed);
  if (percentMatch) {
    const numeric = Number.parseFloat(percentMatch[1]);
    if (!Number.isNaN(numeric)) {
      return percent(numeric / 100);
    }
  }
  return void 0;
}
function parsePosition(value, target) {
  const normalized = value.trim().toLowerCase();
  switch (normalized) {
    case "static" /* Static */:
    case "relative" /* Relative */:
    case "absolute" /* Absolute */:
    case "fixed" /* Fixed */:
    case "sticky" /* Sticky */:
      target.position = normalized;
      break;
    default:
      break;
  }
}
function parseTop(value, target) {
  const parsed = parseLengthLike(value);
  if (parsed !== void 0) {
    target.top = parsed;
  }
}
function parseRight(value, target) {
  const parsed = parseLengthLike(value);
  if (parsed !== void 0) {
    target.right = parsed;
  }
}
function parseBottom(value, target) {
  const parsed = parseLengthLike(value);
  if (parsed !== void 0) {
    target.bottom = parsed;
  }
}
function parseLeft(value, target) {
  const parsed = parseLengthLike(value);
  if (parsed !== void 0) {
    target.left = parsed;
  }
}

// src/css/parsers/text-parser.ts
function parseTextDecorationLine(value) {
  if (!value) {
    return void 0;
  }
  const tokens = value.trim().toLowerCase().split(/\s+/).filter(Boolean);
  if (tokens.length === 0) {
    return void 0;
  }
  if (tokens.includes("none")) {
    return "none";
  }
  const allowed = /* @__PURE__ */ new Set(["underline", "overline", "line-through"]);
  const matches2 = tokens.filter((token) => allowed.has(token));
  if (matches2.length === 0) {
    return void 0;
  }
  const unique = [...new Set(matches2)];
  return unique.join(" ");
}

// src/css/parsers/text-parser-extended.ts
function parseTextAlign(value, target) {
  target.textAlign = value.toLowerCase();
}
function parseTextDecoration(value, target) {
  const parsed = parseTextDecorationLine(value);
  if (parsed !== void 0) {
    target.textDecorationLine = parsed;
  }
  const style = extractTextDecorationStyle(value);
  if (style) {
    target.textDecorationStyle = style;
  }
  const color = extractTextDecorationColor(value);
  if (color) {
    target.textDecorationColor = color;
  }
}
function parseTextDecorationLine2(value, target) {
  const parsed = parseTextDecorationLine(value);
  if (parsed !== void 0) {
    target.textDecorationLine = parsed;
  }
}
function parseTextDecorationColor(value, target) {
  const trimmed = value.trim();
  if (!trimmed) {
    return;
  }
  target.textDecorationColor = trimmed;
}
function parseTextDecorationStyle(value, target) {
  const style = extractTextDecorationStyle(value);
  if (style) {
    target.textDecorationStyle = style;
  }
}
function parseFloat2(value, target) {
  target.float = value;
}
function parseTextIndent(value, target) {
  const parsed = parseLengthOrPercent(value);
  if (parsed !== void 0) {
    target.textIndent = parsed;
  }
}
function parseTextTransform(value, target) {
  const normalized = value.trim().toLowerCase();
  if (normalized === "initial") {
    target.textTransform = "none";
    return;
  }
  if (INHERITABLE_KEYWORDS.has(normalized)) {
    return;
  }
  const resolved = TEXT_TRANSFORM_KEYWORDS[normalized];
  if (resolved) {
    target.textTransform = resolved;
  }
}
function parseLetterSpacing(value, target) {
  const normalized = value.trim().toLowerCase();
  if (!normalized) {
    return;
  }
  if (normalized === "normal") {
    target.letterSpacing = 0;
    return;
  }
  if (INHERITABLE_KEYWORDS.has(normalized)) {
    return;
  }
  const parsed = parseNumeric(value);
  if (parsed !== void 0) {
    target.letterSpacing = parsed;
  }
}
var TEXT_TRANSFORM_KEYWORDS = {
  none: "none",
  uppercase: "uppercase",
  lowercase: "lowercase",
  capitalize: "capitalize"
};
var INHERITABLE_KEYWORDS = /* @__PURE__ */ new Set(["inherit", "unset", "revert", "revert-layer"]);
var COLOR_KEYWORDS = new Set(Object.keys(NAMED_COLORS).map((name) => name.toLowerCase()));
COLOR_KEYWORDS.add("transparent");
COLOR_KEYWORDS.add("currentcolor");
var DECORATION_LINE_KEYWORDS = /* @__PURE__ */ new Set(["underline", "overline", "line-through", "none"]);
var DECORATION_STYLE_KEYWORDS = /* @__PURE__ */ new Set(["solid", "double", "dotted", "dashed", "wavy"]);
function extractTextDecorationStyle(value) {
  if (!value) {
    return void 0;
  }
  const tokens = value.trim().toLowerCase().split(/\s+/);
  for (const token of tokens) {
    if (DECORATION_STYLE_KEYWORDS.has(token)) {
      return token;
    }
  }
  return void 0;
}
function extractTextDecorationColor(value) {
  if (!value) {
    return void 0;
  }
  const functionalMatch = value.match(/\b(?:rgba?|hsla?)\([^)]*\)/i);
  if (functionalMatch) {
    return functionalMatch[0].trim();
  }
  const hexMatch = value.match(/#[0-9a-f]{3,8}\b/i);
  if (hexMatch) {
    return hexMatch[0];
  }
  const tokens = value.trim().split(/\s+/);
  for (const token of tokens) {
    const normalized = token.toLowerCase();
    if (DECORATION_LINE_KEYWORDS.has(normalized)) {
      continue;
    }
    if (COLOR_KEYWORDS.has(normalized)) {
      return normalized;
    }
  }
  return void 0;
}

// src/css/parsers/overflow-wrap-parser.ts
function normalizeOverflowWrap(value) {
  switch (value) {
    case "normal":
      return "normal";
    case "anywhere":
      return "anywhere";
    case "break-word":
      return "break-word";
    default:
      return void 0;
  }
}
function parseOverflowWrap(value, target) {
  if (!value) {
    return;
  }
  const keyword = normalizeOverflowWrap(value.trim().toLowerCase());
  if (keyword) {
    target.overflowWrap = keyword;
  }
}
function parseWordWrap(value, target) {
  if (!value) {
    return;
  }
  const keyword = normalizeOverflowWrap(value.trim().toLowerCase());
  if (!keyword) {
    return;
  }
  target.overflowWrap = keyword === "anywhere" ? "break-word" : keyword;
}

// src/css/parsers/text-shadow-parser.ts
function parseTextShadowList(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return void 0;
  }
  const keyword = trimmed.toLowerCase();
  if (keyword === "none" || keyword === "initial") {
    return [];
  }
  if (keyword === "inherit" || keyword === "revert" || keyword === "revert-layer") {
    return void 0;
  }
  const layers = splitCssCommaList(trimmed);
  const result = [];
  for (const layer of layers) {
    const parsed = parseSingleTextShadow(layer);
    if (parsed) {
      result.push(parsed);
    }
  }
  return result;
}
function parseTextShadow(value, target) {
  const parsed = parseTextShadowList(value);
  if (parsed !== void 0) {
    target.textShadows = parsed;
  }
}
function parseSingleTextShadow(input) {
  const tokens = splitCssList(input);
  if (tokens.length === 0) {
    return null;
  }
  const lengths = [];
  let color;
  for (const token of tokens) {
    const length = parseLength(token);
    if (length !== void 0) {
      lengths.push(length);
      continue;
    }
    if (color === void 0) {
      const lowered = token.toLowerCase();
      if (isColorLike2(lowered)) {
        color = token;
        continue;
      }
    }
  }
  if (lengths.length < 2) {
    return null;
  }
  const asLength = (value, clamp3 = false) => {
    if (value === void 0) return 0;
    if (typeof value === "number" && clamp3) {
      return clampNonNegative2(value);
    }
    if (typeof value === "number") return value;
    return value;
  };
  const offsetX = asLength(lengths[0]);
  const offsetY = asLength(lengths[1]);
  const blurRadius = asLength(lengths[2], true);
  return {
    offsetX,
    offsetY,
    blurRadius,
    color
  };
}
function isColorLike2(value) {
  if (!value) return false;
  if (value.startsWith("#") || value.startsWith("rgb(") || value.startsWith("rgba(") || value.startsWith("hsl(") || value.startsWith("hsla(")) {
    return true;
  }
  const colorNames = ["transparent", "black", "white", "red", "green", "blue", "yellow", "gray", "grey"];
  return colorNames.includes(value.toLowerCase());
}

// src/css/parsers/list-style-parser.ts
var LIST_STYLE_KEYWORD_MAP = {
  none: "none",
  disc: "disc",
  circle: "circle",
  square: "square",
  decimal: "decimal",
  "decimal-leading-zero": "decimal-leading-zero",
  "lower-alpha": "lower-alpha",
  "lower-latin": "lower-alpha",
  "upper-alpha": "upper-alpha",
  "upper-latin": "upper-alpha",
  "lower-roman": "lower-roman",
  "upper-roman": "upper-roman"
};
var INHERITABLE_KEYWORDS2 = /* @__PURE__ */ new Set(["inherit", "unset", "revert", "revert-layer"]);
function parseListStyleType(value, target) {
  if (!value) {
    return;
  }
  const normalized = value.trim().toLowerCase();
  if (!normalized) {
    return;
  }
  if (normalized === "initial") {
    target.listStyleType = "disc";
    return;
  }
  if (INHERITABLE_KEYWORDS2.has(normalized)) {
    return;
  }
  target.listStyleType = LIST_STYLE_KEYWORD_MAP[normalized] ?? normalized;
}

// src/css/parsers/gradient-parser.ts
function parseLinearGradient(value) {
  const trimmed = value.trim();
  console.log("parseLinearGradient - input:", value);
  console.log("parseLinearGradient - trimmed:", trimmed);
  if (!trimmed.toLowerCase().startsWith("linear-gradient(")) {
    console.log("parseLinearGradient - not a linear gradient, returning null");
    return null;
  }
  const content = trimmed.slice("linear-gradient(".length, -1);
  if (!content) {
    return null;
  }
  let direction = "to bottom";
  let colorStopsContent = content;
  let commaPos = -1;
  let parenCount = 0;
  for (let i = 0; i < content.length; i++) {
    if (content[i] === "(") {
      parenCount++;
    } else if (content[i] === ")") {
      parenCount--;
    } else if (content[i] === "," && parenCount === 0) {
      commaPos = i;
      break;
    }
  }
  if (commaPos !== -1) {
    const potentialDirection = content.substring(0, commaPos).trim();
    const lowerDirection = potentialDirection.toLowerCase();
    const directionPatterns = ["to", "to bottom", "to right", "to left", "to top right", "to top left", "to bottom right", "to bottom left"];
    const isDirection = directionPatterns.some((pattern) => lowerDirection === pattern) || lowerDirection.endsWith("deg");
    if (isDirection) {
      direction = lowerDirection;
      colorStopsContent = content.substring(commaPos + 1).trim();
    } else {
      colorStopsContent = content;
    }
  } else {
    const trimmedContent = content.trim().toLowerCase();
    if (trimmedContent === "to" || trimmedContent.startsWith("to ") || trimmedContent.endsWith("deg")) {
      direction = trimmedContent;
      colorStopsContent = "";
    } else {
      colorStopsContent = content;
    }
  }
  if (direction.startsWith("to ")) {
    if (direction === "to righ") {
      direction = "to right";
    } else if (direction === "to botto") {
      direction = "to bottom";
    } else if (direction === "to bott") {
      direction = "to bottom";
    } else if (direction === "to bot") {
      direction = "to bottom";
    }
    direction = direction.replace(/,$/, "");
  } else if (direction.endsWith("deg")) {
    direction = direction.replace(/,$/, "");
  }
  if (direction.startsWith("to ")) {
    direction = direction.replace(/,$/, "");
  } else if (direction.endsWith("deg")) {
    direction = direction.replace(/,$/, "");
  }
  const colorStopValues = splitCssCommaList(colorStopsContent);
  console.log("Gradient parser - input value:", value);
  console.log("Gradient parser - content:", content);
  console.log("Gradient parser - direction:", direction);
  console.log("Gradient parser - colorStopsContent:", colorStopsContent);
  console.log("Gradient parser - colorStopValues:", colorStopValues);
  const stops = [];
  for (const stopValue of colorStopValues) {
    if (!stopValue.trim()) continue;
    const stop = parseGradientStop(stopValue);
    if (stop) {
      stops.push(stop);
    }
  }
  console.log("Gradient parser - parsed stops:", stops);
  if (stops.length === 0) {
    stops.push({ color: "#000000" });
  }
  return {
    type: "linear",
    direction,
    stops
  };
}
function parseRadialGradient(value) {
  const trimmed = value.trim();
  const lower = trimmed.toLowerCase();
  if (!lower.startsWith("radial-gradient(") || !trimmed.endsWith(")")) {
    return null;
  }
  const content = trimmed.slice("radial-gradient(".length, -1);
  if (!content) {
    return null;
  }
  const commaIndex = findTopLevelComma(content);
  const descriptorPart = commaIndex === -1 ? "" : content.slice(0, commaIndex).trim();
  let stopsContent = commaIndex === -1 ? content : content.slice(commaIndex + 1).trim();
  const descriptor = parseRadialDescriptor(descriptorPart);
  if (!descriptor.hasDescriptor) {
    stopsContent = content;
  }
  const stops = [];
  const colorStopValues = splitCssCommaList(stopsContent);
  for (const stopValue of colorStopValues) {
    if (!stopValue.trim()) continue;
    const stop = parseGradientStop(stopValue);
    if (stop) {
      stops.push(stop);
    }
  }
  if (stops.length === 0) {
    stops.push({ color: "#000000" });
  }
  return {
    type: "radial",
    cx: 0.5,
    cy: 0.5,
    r: 0.5,
    stops,
    coordsUnits: "ratio",
    shape: descriptor.shape,
    size: descriptor.size,
    at: descriptor.position,
    source: "css"
  };
}
function parseGradientStop(value) {
  const parts = splitCssList(value);
  if (parts.length === 0) {
    return null;
  }
  let color = parts[0].trim();
  if (!color) {
    return null;
  }
  const colorNames = {
    "red": true,
    "yellow": true,
    "green": true,
    "blue": true,
    "black": true,
    "white": true,
    "gray": true,
    "grey": true,
    "lime": true
  };
  if (colorNames[color.toLowerCase()]) {
  }
  let position;
  if (parts.length > 1) {
    const positionStr = parts[1].trim();
    const num = parseFloat(positionStr.slice(0, -1));
    if (!isNaN(num)) {
      position = num / 100;
    } else {
      const num2 = parseFloat(positionStr);
      if (!isNaN(num2) && num2 >= 0 && num2 <= 1) {
        position = num2;
      }
    }
  }
  return { color, position };
}
function parseRadialDescriptor(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return { hasDescriptor: false };
  }
  const tokens = trimmed.split(/\s+/).filter(Boolean);
  if (tokens.length === 0) {
    return { hasDescriptor: false };
  }
  const atIndex = tokens.findIndex((token) => token.toLowerCase() === "at");
  const beforeAt = atIndex === -1 ? tokens : tokens.slice(0, atIndex);
  const positionTokens = atIndex === -1 ? [] : tokens.slice(atIndex + 1);
  let shape;
  let size;
  for (const token of beforeAt) {
    const lower = token.toLowerCase();
    if (lower === "circle" || lower === "ellipse") {
      shape = lower;
      continue;
    }
    if (isRadialSizeKeyword(lower)) {
      size = lower;
      continue;
    }
  }
  const position = parseRadialPosition(positionTokens);
  const hasDescriptor = !!shape || !!size || !!position;
  return { shape, size, position, hasDescriptor };
}
function parseRadialPosition(tokens) {
  if (!tokens || tokens.length === 0) {
    return void 0;
  }
  if (tokens.length === 1) {
    const token = tokens[0];
    if (isVerticalKeyword(token)) {
      return { x: "50%", y: keywordToPositionValue(token, "y") };
    }
    return { x: keywordToPositionValue(token, "x"), y: "50%" };
  }
  const xToken = tokens[0];
  const yToken = tokens[1];
  return {
    x: keywordToPositionValue(xToken, "x"),
    y: keywordToPositionValue(yToken, "y")
  };
}
function keywordToPositionValue(token, axis) {
  const lower = token.toLowerCase();
  if (axis === "x") {
    if (lower === "left") return "0%";
    if (lower === "right") return "100%";
  } else {
    if (lower === "top") return "0%";
    if (lower === "bottom") return "100%";
  }
  if (lower === "center") return "50%";
  return token;
}
function isVerticalKeyword(value) {
  const lower = value.toLowerCase();
  return lower === "top" || lower === "bottom";
}
function isRadialSizeKeyword(value) {
  switch (value) {
    case "closest-side":
    case "farthest-side":
    case "closest-corner":
    case "farthest-corner":
      return true;
    default:
      return false;
  }
}
function findTopLevelComma(value) {
  let depth = 0;
  for (let i = 0; i < value.length; i++) {
    const char = value[i];
    if (char === "(") {
      depth++;
    } else if (char === ")") {
      depth = Math.max(0, depth - 1);
    } else if (char === "," && depth === 0) {
      return i;
    }
  }
  return -1;
}

// src/css/parsers/background-parser.ts
function normalizeBackgroundSizeKeyword(value) {
  const trimmed = value.trim().toLowerCase();
  if (!trimmed) {
    return void 0;
  }
  const matchesKeyword = (keyword) => {
    return trimmed === keyword || trimmed.startsWith(`${keyword} `) || trimmed.startsWith(`${keyword}(`);
  };
  if (matchesKeyword("cover")) {
    return "cover";
  }
  if (matchesKeyword("contain")) {
    return "contain";
  }
  if (matchesKeyword("auto")) {
    return "auto";
  }
  return void 0;
}
function normalizeBackgroundSizeComponent(value) {
  const keyword = normalizeBackgroundSizeKeyword(value);
  return keyword ?? value.trim();
}
function extractFunctionCall(value, fnName) {
  const lower = value.toLowerCase();
  const needle = `${fnName.toLowerCase()}(`;
  const start = lower.indexOf(needle);
  if (start === -1) {
    return null;
  }
  let depth = 0;
  for (let i = start; i < value.length; i++) {
    const ch = value[i];
    if (ch === "(") {
      depth++;
    } else if (ch === ")") {
      depth--;
      if (depth === 0) {
        return { text: value.slice(start, i + 1), start, end: i + 1 };
      }
    }
  }
  return null;
}
function ensureLayers(style) {
  if (!style.backgroundLayers) {
    style.backgroundLayers = [];
  }
  return style.backgroundLayers;
}
function getOrCreateTopRenderableLayer(style) {
  const layers = ensureLayers(style);
  for (let i = layers.length - 1; i >= 0; i--) {
    if (layers[i].kind !== "color") {
      return layers[i];
    }
  }
  const newLayer = { kind: "image", url: "" };
  layers.push(newLayer);
  return newLayer;
}
function parseBackgroundShorthand(value) {
  const trimmed = value.trim();
  if (!trimmed) return [];
  const layerStrings = splitBackgroundLayers(trimmed);
  const layers = [];
  for (const layerStr of layerStrings) {
    const layer = parseSingleBackgroundLayer(layerStr);
    if (layer) {
      layers.push(layer);
    }
  }
  return layers;
}
function splitBackgroundLayers(value) {
  const result = [];
  let current2 = "";
  let parenCount = 0;
  let i = 0;
  while (i < value.length) {
    const char = value[i];
    if (char === "(") {
      parenCount++;
      current2 += char;
    } else if (char === ")") {
      parenCount--;
      current2 += char;
    } else if (char === "," && parenCount === 0) {
      result.push(current2.trim());
      current2 = "";
    } else {
      current2 += char;
    }
    i++;
  }
  if (current2.trim()) {
    result.push(current2.trim());
  }
  return result;
}
function parseSingleBackgroundLayer(value) {
  const trimmed = value.trim();
  if (!trimmed) return null;
  const gradientSlice = extractFunctionCall(trimmed, "radial-gradient") ?? extractFunctionCall(trimmed, "linear-gradient");
  if (gradientSlice) {
    const gradientLayer = parseGradientLayer(gradientSlice.text);
    if (gradientLayer) {
      const before2 = trimmed.slice(0, gradientSlice.start).trim();
      const after2 = trimmed.slice(gradientSlice.end).trim();
      const remainder = [before2, after2].filter(Boolean).join(" ");
      if (remainder && gradientLayer.kind === "gradient") {
        const tokens = remainder.split(/\s+/).filter(Boolean);
        for (const token of tokens) {
          const lower = token.toLowerCase();
          if (isRepeatKeyword(lower)) {
            gradientLayer.repeat = lower;
          } else if (isBoxKeyword(lower)) {
            gradientLayer.origin = lower;
          }
        }
      }
      return gradientLayer;
    }
  }
  if (isColorValue(trimmed)) {
    return { kind: "color", color: trimmed };
  }
  return parseImageLayer(trimmed);
}
function parseGradientLayer(value) {
  const normalized = value.trim().toLowerCase();
  const gradient = normalized.startsWith("linear-gradient(") ? parseLinearGradient(value) : normalized.startsWith("radial-gradient(") ? parseRadialGradient(value) : null;
  if (!gradient) {
    return null;
  }
  return {
    kind: "gradient",
    gradient
  };
}
function parseImageLayer(value) {
  const parts = value.split(/\s+/).filter((p) => p.length > 0);
  if (parts.length === 0) return null;
  let url = "";
  let position = { x: "left", y: "top" };
  let size = "auto";
  let repeat = "repeat";
  let origin;
  let currentIndex = 0;
  for (let i = 0; i < parts.length; i++) {
    if (parts[i].startsWith("url(")) {
      url = parts[i];
      currentIndex = i + 1;
      break;
    }
  }
  if (!url) return null;
  while (currentIndex < parts.length) {
    const partRaw = parts[currentIndex];
    const part = partRaw.toLowerCase();
    if (part.includes("/")) {
      size = parseBackgroundSizeValue(partRaw);
      currentIndex++;
    } else if (isPositionKeyword(part)) {
      position = parseBackgroundPosition(part, parts[currentIndex + 1]);
      currentIndex += position.y !== "top" ? 2 : 1;
    } else if (isRepeatKeyword(part)) {
      repeat = part;
      currentIndex++;
    } else if (isBoxKeyword(part) && origin === void 0) {
      origin = part;
      currentIndex++;
    } else {
      currentIndex++;
    }
  }
  return {
    kind: "image",
    url,
    position,
    size,
    repeat,
    origin
  };
}
function parseBackgroundSizeValue(value) {
  const slashIndex = value.indexOf("/");
  if (slashIndex === -1) {
    const keyword = normalizeBackgroundSizeKeyword(value);
    if (keyword) {
      return keyword;
    }
    const tokens = value.trim().split(/\s+/).filter(Boolean);
    if (tokens.length === 1) {
      return { width: normalizeBackgroundSizeComponent(tokens[0]), height: "auto" };
    }
    return {
      width: normalizeBackgroundSizeComponent(tokens[0]),
      height: normalizeBackgroundSizeComponent(tokens[1] ?? "auto")
    };
  } else {
    const width = value.substring(0, slashIndex).trim();
    const height = value.substring(slashIndex + 1).trim();
    return {
      width: width ? normalizeBackgroundSizeComponent(width) : "auto",
      height: height ? normalizeBackgroundSizeComponent(height) : "auto"
    };
  }
}
var VERTICAL_POSITION_KEYWORDS = /* @__PURE__ */ new Set(["top", "bottom"]);
function parseBackgroundPosition(x, y) {
  return {
    x: x.toLowerCase(),
    y: y.toLowerCase()
  };
}
function isColorValue(value) {
  const lowerValue = value.toLowerCase();
  if (lowerValue in NAMED_COLORS) {
    return true;
  }
  if (lowerValue === "transparent") {
    return true;
  }
  if (lowerValue.startsWith("#") && (lowerValue.length === 4 || lowerValue.length === 7)) {
    return true;
  }
  if (lowerValue.startsWith("rgb(") || lowerValue.startsWith("rgba(")) {
    return true;
  }
  if (lowerValue.startsWith("hsl(") || lowerValue.startsWith("hsla(")) {
    return true;
  }
  return false;
}
function isPositionKeyword(value) {
  const positions = ["left", "center", "right", "top", "bottom"];
  return positions.includes(value.toLowerCase());
}
function isRepeatKeyword(value) {
  const repeats = ["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"];
  return repeats.includes(value.toLowerCase());
}
function isBoxKeyword(value) {
  const lower = value.toLowerCase();
  return lower === "border-box" || lower === "padding-box" || lower === "content-box";
}
function applyBackgroundSize(style, value) {
  ensureLayers(style);
  const layer = getOrCreateTopRenderableLayer(style);
  const keyword = normalizeBackgroundSizeKeyword(value);
  let size;
  if (keyword) {
    size = keyword;
  } else {
    const tokens = value.trim().split(/\s+/).filter(Boolean);
    if (tokens.length === 0) {
      size = "auto";
    } else if (tokens.length === 1) {
      size = { width: normalizeBackgroundSizeComponent(tokens[0]), height: "auto" };
    } else {
      size = {
        width: normalizeBackgroundSizeComponent(tokens[0]),
        height: normalizeBackgroundSizeComponent(tokens[1] ?? "auto")
      };
    }
  }
  if (layer.kind === "image" || layer.kind === "gradient") {
    layer.size = size;
  }
}
function parseBackgroundPositionValue(value) {
  const tokens = value.trim().split(/\s+/).filter(Boolean);
  if (tokens.length === 0) {
    return { x: "left", y: "top" };
  }
  const normalizedTokens = tokens.map((token) => token.toLowerCase());
  const first = normalizedTokens[0];
  if (tokens.length === 1) {
    if (first === "center") {
      return parseBackgroundPosition("center", "center");
    }
    if (VERTICAL_POSITION_KEYWORDS.has(first)) {
      return parseBackgroundPosition("center", first);
    }
    return parseBackgroundPosition(first, "center");
  }
  const second = normalizedTokens[1];
  const firstIsVertical = VERTICAL_POSITION_KEYWORDS.has(first);
  if (firstIsVertical) {
    const horizontalToken = tokens[1] ?? "center";
    return parseBackgroundPosition(horizontalToken, first);
  }
  return parseBackgroundPosition(first, second ?? "center");
}
function applyBackgroundPosition(style, value) {
  ensureLayers(style);
  const layer = getOrCreateTopRenderableLayer(style);
  const position = parseBackgroundPositionValue(value);
  if (layer.kind === "image" || layer.kind === "gradient") {
    layer.position = position;
  }
}
function applyBackgroundOrigin(style, value) {
  ensureLayers(style);
  const token = value.trim().toLowerCase();
  if (!isBoxKeyword(token)) {
    return;
  }
  const layer = getOrCreateTopRenderableLayer(style);
  if (layer.kind === "image" || layer.kind === "gradient") {
    layer.origin = token;
  }
}
function applyBackgroundRepeat(style, value) {
  ensureLayers(style);
  const token = value.trim().toLowerCase();
  if (!isRepeatKeyword(token)) {
    return;
  }
  const layer = getOrCreateTopRenderableLayer(style);
  if (layer.kind === "image" || layer.kind === "gradient") {
    layer.repeat = token;
  }
}

// src/css/parsers/background-parser-extended.ts
var BACKGROUND_CLIP_VALUES = /* @__PURE__ */ new Set([
  "border-box",
  "padding-box",
  "content-box",
  "text"
]);
function applyBackgroundSizeDecl(value, target) {
  applyBackgroundSize(target, value);
}
function applyBackgroundPositionDecl(value, target) {
  applyBackgroundPosition(target, value);
}
function applyBackgroundOriginDecl(value, target) {
  applyBackgroundOrigin(target, value);
}
function applyBackgroundRepeatDecl(value, target) {
  applyBackgroundRepeat(target, value);
}
function applyBackgroundClipDecl(value, target) {
  const layers = ensureLayers(target);
  if (layers.length === 0) {
    return;
  }
  const tokens = value.split(",").map((token) => token.trim().toLowerCase()).filter((token) => token.length > 0);
  if (tokens.length === 0) {
    return;
  }
  for (let i = 0; i < tokens.length; i++) {
    const clipValue = tokens[i];
    if (!BACKGROUND_CLIP_VALUES.has(clipValue)) {
      continue;
    }
    const layerIndex = Math.min(i, layers.length - 1);
    const layer = layers[layerIndex];
    if (layer) {
      layer.clip = clipValue;
    }
  }
}
function parseBackgroundImage(value, target) {
  const trimmed = value.trim();
  const gradient = parseLinearGradient(value) ?? parseRadialGradient(value);
  if (gradient) {
    if (!target.backgroundLayers) {
      target.backgroundLayers = [];
    }
    target.backgroundLayers.push({ kind: "gradient", gradient });
    return;
  }
  if (trimmed.startsWith("url(")) {
    if (!target.backgroundLayers) {
      target.backgroundLayers = [];
    }
    target.backgroundLayers.push({
      kind: "image",
      url: trimmed,
      position: { x: "left", y: "top" },
      size: "auto",
      repeat: "repeat"
    });
  }
}
function parseBackground(value, target) {
  console.log("Processing background property:", value);
  const layers = parseBackgroundShorthand(value);
  console.log("Parsed background layers:", layers);
  if (layers.length > 0) {
    if (!target.backgroundLayers) {
      target.backgroundLayers = [];
    }
    target.backgroundLayers.push(...layers);
  }
}
function parseObjectFit(value, target) {
  const normalized = value.trim().toLowerCase();
  if (["contain", "cover", "fill", "none", "scale-down"].includes(normalized)) {
    target.objectFit = normalized;
  }
}

// src/css/parsers/clip-path-parser.ts
function parseClipPath(value, target) {
  const parsed = parseClipPathValue(value);
  if (!parsed) {
    return;
  }
  target.clipPath = parsed;
}
function parseClipPathValue(value) {
  if (!value) return void 0;
  const normalized = value.trim();
  if (normalized === "none") {
    return void 0;
  }
  const polygon = parsePolygon(normalized);
  if (polygon) {
    return polygon;
  }
  return void 0;
}
function parsePolygon(input) {
  const match = /^polygon\s*\((.+)\)$/i.exec(input);
  if (!match) {
    return void 0;
  }
  const body = match[1].trim();
  if (!body) {
    return void 0;
  }
  const rawPoints = body.includes(",") ? body.split(/\s*,\s*/) : splitEvenTokens(body.split(/\s+/));
  const points = [];
  for (const raw of rawPoints) {
    const coords = raw.trim().split(/\s+/).filter(Boolean);
    if (coords.length < 2) {
      return void 0;
    }
    const x = parseClipLength(coords[0]);
    const y = parseClipLength(coords[1]);
    if (!x || !y) {
      return void 0;
    }
    points.push({ x, y });
  }
  if (points.length < 3) {
    return void 0;
  }
  const referenceBox = "border-box";
  return {
    type: "polygon",
    points,
    referenceBox
  };
}
function splitEvenTokens(tokens) {
  const result = [];
  for (let i = 0; i < tokens.length; i += 2) {
    const a = tokens[i];
    const b = tokens[i + 1];
    if (!a || !b) {
      break;
    }
    result.push(`${a} ${b}`);
  }
  return result;
}
function parseClipLength(token) {
  const parsed = parseLengthOrPercent(token);
  if (parsed === void 0) {
    return void 0;
  }
  if (typeof parsed === "number") {
    return { unit: "px", value: parsed };
  }
  if (typeof parsed === "object" && parsed.unit === "percent") {
    return { unit: "percent", value: parsed.value };
  }
  return void 0;
}

// src/css/parsers/grid-parser.ts
function tokenizeTrackList(value) {
  const tokens = [];
  let buffer = "";
  let depth = 0;
  for (let i = 0; i < value.length; i++) {
    const char = value[i];
    if (char === "(") {
      depth += 1;
      buffer += char;
      continue;
    }
    if (char === ")") {
      depth = Math.max(0, depth - 1);
      buffer += char;
      continue;
    }
    if (/\s/.test(char) && depth === 0) {
      if (buffer) {
        tokens.push(buffer.trim());
        buffer = "";
      }
      continue;
    }
    buffer += char;
  }
  if (buffer) {
    tokens.push(buffer.trim());
  }
  return tokens;
}
function splitArgs(value) {
  const args = [];
  let buffer = "";
  let depth = 0;
  for (let i = 0; i < value.length; i++) {
    const char = value[i];
    if (char === "(") {
      depth += 1;
      buffer += char;
      continue;
    }
    if (char === ")") {
      depth = Math.max(0, depth - 1);
      buffer += char;
      continue;
    }
    if (char === "," && depth === 0) {
      args.push(buffer.trim());
      buffer = "";
      continue;
    }
    buffer += char;
  }
  if (buffer) {
    args.push(buffer.trim());
  }
  return args;
}
function parseFlex(value) {
  const match = value.trim().match(/^(-?\d+(?:\.\d+)?)fr$/i);
  if (!match) {
    return void 0;
  }
  const parsed = Number.parseFloat(match[1]);
  return Number.isNaN(parsed) ? void 0 : parsed;
}
function parseTrackSize(token) {
  const normalized = token.trim().toLowerCase();
  if (normalized.startsWith("minmax(") && normalized.endsWith(")")) {
    const inner = normalized.slice(7, -1);
    const [minArg, maxArg] = splitArgs(inner);
    if (!minArg || !maxArg) {
      return void 0;
    }
    const min = parseLength(minArg);
    if (min === void 0) {
      return void 0;
    }
    const flex2 = parseFlex(maxArg);
    if (flex2 !== void 0) {
      const track = { kind: "flex", flex: flex2, min };
      return track;
    }
    const maxLength = parseLength(maxArg);
    if (maxLength !== void 0) {
      if (typeof min === "number" && typeof maxLength === "number") {
        return {
          kind: "fixed",
          size: Math.max(min, maxLength)
        };
      }
      return {
        kind: "fixed",
        size: maxLength
      };
    }
    if (maxArg.trim() === "auto") {
      return { kind: "auto", min };
    }
    return void 0;
  }
  const flex = parseFlex(normalized);
  if (flex !== void 0) {
    return { kind: "flex", flex };
  }
  if (normalized === "auto") {
    return { kind: "auto" };
  }
  const length = parseLength(normalized);
  if (length !== void 0) {
    return { kind: "fixed", size: length };
  }
  return void 0;
}
function parseGridTemplate(value) {
  if (!value) {
    return void 0;
  }
  const tokens = tokenizeTrackList(value.trim());
  if (tokens.length === 0) {
    return void 0;
  }
  const tracks = [];
  for (const token of tokens) {
    const normalized = token.trim().toLowerCase();
    if (normalized.startsWith("repeat(") && normalized.endsWith(")")) {
      const inner = token.trim().slice(7, -1);
      const [countArg, trackArg] = splitArgs(inner);
      if (!countArg || !trackArg) {
        return void 0;
      }
      const track2 = parseTrackSize(trackArg);
      if (!track2) {
        return void 0;
      }
      const normalizedCount = countArg.trim().toLowerCase();
      if (normalizedCount === "auto-fit" || normalizedCount === "auto-fill") {
        const repeat2 = {
          kind: "repeat-auto",
          mode: normalizedCount,
          track: track2
        };
        tracks.push(repeat2);
        continue;
      }
      const numericCount = Number.parseInt(normalizedCount, 10);
      if (!Number.isFinite(numericCount) || numericCount <= 0) {
        return void 0;
      }
      const repeat = {
        kind: "repeat",
        count: numericCount,
        track: track2
      };
      tracks.push(repeat);
      continue;
    }
    const track = parseTrackSize(token);
    if (!track) {
      return void 0;
    }
    tracks.push(track);
  }
  return tracks;
}
function parseGap(value) {
  if (!value) {
    return void 0;
  }
  const tokens = value.split(/\s+/).map((token) => token.trim()).filter((token) => token.length > 0);
  if (tokens.length === 0) {
    return void 0;
  }
  const first = parseLength(tokens[0]);
  if (first === void 0) {
    return void 0;
  }
  const second = tokens.length > 1 ? parseLength(tokens[1]) : void 0;
  return {
    row: first,
    column: second ?? first
  };
}

// src/css/parsers/grid-parser-extended.ts
function parseGridTemplateColumns(value, target) {
  const parsed = parseGridTemplate(value);
  if (parsed) {
    target.trackListColumns = parsed;
  }
}
function parseGridTemplateRows(value, target) {
  const parsed = parseGridTemplate(value);
  if (parsed) {
    target.trackListRows = parsed;
  }
}
function parseGridAutoFlow(value, target) {
  const normalized = value.trim().toLowerCase();
  switch (normalized) {
    case "row":
    case "column":
    case "row dense":
    case "column dense":
      target.autoFlow = normalized;
      break;
    default:
      break;
  }
}
function parseGap2(value, target) {
  const parsed = parseGap(value);
  if (parsed) {
    target.rowGap = parsed.row;
    target.columnGap = parsed.column;
  }
}
function parseRowGap(value, target) {
  const parsed = parseLength(value);
  if (parsed !== void 0) {
    target.rowGap = parsed;
  }
}
function parseColumnGap(value, target) {
  const parsed = parseLength(value);
  if (parsed !== void 0) {
    target.columnGap = parsed;
  }
}

// src/css/parsers/opacity-parser.ts
function parseOpacity(value, target) {
  console.log(`DEBUG: parseOpacity called with value: "${value}"`);
  const normalizedValue = value.trim().toLowerCase();
  let opacityValue;
  if (normalizedValue.endsWith("%")) {
    const percentStr = normalizedValue.slice(0, -1);
    const percent2 = parseFloat(percentStr);
    if (isNaN(percent2)) {
      return;
    }
    opacityValue = percent2 / 100;
  } else {
    opacityValue = parseFloat(normalizedValue);
    if (isNaN(opacityValue)) {
      return;
    }
  }
  opacityValue = Math.max(0, Math.min(1, opacityValue));
  target.opacity = opacityValue;
}

// src/css/parsers/register-parsers.ts
var parsersRegistered = false;
function registerAllPropertyParsers() {
  if (parsersRegistered) {
    return;
  }
  parsersRegistered = true;
  registerPropertyParser("display", parseDisplay);
  registerPropertyParser("justify-content", parseJustifyContent);
  registerPropertyParser("align-items", parseAlignItems);
  registerPropertyParser("align-content", parseAlignContent);
  registerPropertyParser("align-self", parseAlignSelf);
  registerPropertyParser("flex-direction", parseFlexDirection);
  registerPropertyParser("flex-wrap", parseFlexWrap);
  registerPropertyParser("color", parseColor2);
  registerPropertyParser("background-color", parseBackgroundColor);
  registerPropertyParser("border-color", parseBorderColor);
  registerPropertyParser("box-shadow", parseBoxShadow);
  registerPropertyParser("border", parseBorder);
  registerPropertyParser("border-top", parseBorderTop);
  registerPropertyParser("border-right", parseBorderRight);
  registerPropertyParser("border-bottom", parseBorderBottom);
  registerPropertyParser("border-left", parseBorderLeft);
  registerPropertyParser("border-radius", parseBorderRadius);
  registerPropertyParser("border-top-left-radius", parseBorderTopLeftRadius);
  registerPropertyParser("border-top-right-radius", parseBorderTopRightRadius);
  registerPropertyParser("border-bottom-right-radius", parseBorderBottomRightRadius);
  registerPropertyParser("border-bottom-left-radius", parseBorderBottomLeftRadius);
  registerPropertyParser("border-width", parseBorderWidth2);
  registerPropertyParser("border-top-width", parseBorderTopWidth);
  registerPropertyParser("border-right-width", parseBorderRightWidth);
  registerPropertyParser("border-bottom-width", parseBorderBottomWidth);
  registerPropertyParser("border-left-width", parseBorderLeftWidth);
  registerPropertyParser("border-top-color", parseBorderTopColor);
  registerPropertyParser("border-right-color", parseBorderRightColor);
  registerPropertyParser("border-bottom-color", parseBorderBottomColor);
  registerPropertyParser("border-left-color", parseBorderLeftColor);
  registerPropertyParser("border-style", parseBorderStyle);
  registerPropertyParser("border-top-style", parseBorderTopStyle);
  registerPropertyParser("border-right-style", parseBorderRightStyle);
  registerPropertyParser("border-bottom-style", parseBorderBottomStyle);
  registerPropertyParser("border-left-style", parseBorderLeftStyle);
  registerPropertyParser("border-collapse", parseBorderCollapse);
  registerPropertyParser("border-block-start", parseBorderBlockStart);
  registerPropertyParser("border-block-end", parseBorderBlockEnd);
  registerPropertyParser("border-inline-start", parseBorderInlineStart);
  registerPropertyParser("border-inline-end", parseBorderInlineEnd);
  registerPropertyParser("margin", parseMargin);
  registerPropertyParser("margin-top", parseMarginTop);
  registerPropertyParser("margin-right", parseMarginRight);
  registerPropertyParser("margin-bottom", parseMarginBottom);
  registerPropertyParser("margin-left", parseMarginLeft);
  registerPropertyParser("margin-block-start", parseMarginBlockStart);
  registerPropertyParser("margin-block-end", parseMarginBlockEnd);
  registerPropertyParser("margin-inline-start", parseMarginInlineStart);
  registerPropertyParser("margin-inline-end", parseMarginInlineEnd);
  registerPropertyParser("padding", parsePadding);
  registerPropertyParser("padding-top", parsePaddingTop);
  registerPropertyParser("padding-right", parsePaddingRight);
  registerPropertyParser("padding-bottom", parsePaddingBottom);
  registerPropertyParser("padding-left", parsePaddingLeft);
  registerPropertyParser("padding-block-start", parsePaddingBlockStart);
  registerPropertyParser("padding-block-end", parsePaddingBlockEnd);
  registerPropertyParser("padding-inline-start", parsePaddingInlineStart);
  registerPropertyParser("padding-inline-end", parsePaddingInlineEnd);
  registerPropertyParser("width", parseWidth);
  registerPropertyParser("min-width", parseMinWidth);
  registerPropertyParser("max-width", parseMaxWidth);
  registerPropertyParser("height", parseHeight);
  registerPropertyParser("min-height", parseMinHeight);
  registerPropertyParser("max-height", parseMaxHeight);
  registerPropertyParser("font-size", parseFontSize);
  registerPropertyParser("line-height", parseLineHeight);
  registerPropertyParser("z-index", parseZIndex);
  registerPropertyParser("font-family", parseFontFamily2);
  registerPropertyParser("font-style", parseFontStyle);
  registerPropertyParser("font-variant", parseFontVariant);
  registerPropertyParser("font-weight", parseFontWeight);
  registerPropertyParser("position", parsePosition);
  registerPropertyParser("top", parseTop);
  registerPropertyParser("right", parseRight);
  registerPropertyParser("bottom", parseBottom);
  registerPropertyParser("left", parseLeft);
  registerPropertyParser("text-align", parseTextAlign);
  registerPropertyParser("text-decoration", parseTextDecoration);
  registerPropertyParser("text-decoration-line", parseTextDecorationLine2);
  registerPropertyParser("text-decoration-color", parseTextDecorationColor);
  registerPropertyParser("text-decoration-style", parseTextDecorationStyle);
  registerPropertyParser("letter-spacing", parseLetterSpacing);
  registerPropertyParser("text-indent", parseTextIndent);
  registerPropertyParser("text-transform", parseTextTransform);
  registerPropertyParser("float", parseFloat2);
  registerPropertyParser("overflow-wrap", parseOverflowWrap);
  registerPropertyParser("word-wrap", parseWordWrap);
  registerPropertyParser("text-shadow", parseTextShadow);
  registerPropertyParser("list-style-type", parseListStyleType);
  registerPropertyParser("transform", (value, target) => {
    target.transform = value;
  });
  registerPropertyParser("background-size", applyBackgroundSizeDecl);
  registerPropertyParser("background-position", applyBackgroundPositionDecl);
  registerPropertyParser("background-origin", applyBackgroundOriginDecl);
  registerPropertyParser("background-repeat", applyBackgroundRepeatDecl);
  registerPropertyParser("background-clip", applyBackgroundClipDecl);
  registerPropertyParser("background-image", parseBackgroundImage);
  registerPropertyParser("background", parseBackground);
  registerPropertyParser("object-fit", parseObjectFit);
  registerPropertyParser("clip-path", parseClipPath);
  registerPropertyParser("grid-template-columns", parseGridTemplateColumns);
  registerPropertyParser("grid-template-rows", parseGridTemplateRows);
  registerPropertyParser("grid-auto-flow", parseGridAutoFlow);
  registerPropertyParser("gap", parseGap2);
  registerPropertyParser("row-gap", parseRowGap);
  registerPropertyParser("column-gap", parseColumnGap);
  registerPropertyParser("opacity", parseOpacity);
}

// src/css/apply-declarations.ts
registerAllPropertyParsers();
var SHORTHAND_PROPERTIES = /* @__PURE__ */ new Set([
  "border",
  "border-color",
  "border-style",
  "border-width",
  "border-radius",
  "margin",
  "padding",
  "background",
  "font",
  "text-decoration",
  "flex",
  "gap"
]);
var parserCache = /* @__PURE__ */ new Map();
function getCachedParser(property) {
  if (parserCache.has(property)) {
    return parserCache.get(property);
  }
  const parser = getPropertyParser(property);
  if (parser) {
    parserCache.set(property, parser);
  }
  return parser;
}
function applyDeclarationsToStyle(declarations, target, units, inheritedFontWeight) {
  const normalizedDeclarations = {};
  for (const [property, value] of Object.entries(declarations)) {
    normalizedDeclarations[property.toLowerCase()] = value.trim();
  }
  const shorthands = [];
  const longhands = [];
  for (const [property, value] of Object.entries(normalizedDeclarations)) {
    if (SHORTHAND_PROPERTIES.has(property)) {
      shorthands.push([property, value]);
    } else {
      longhands.push([property, value]);
    }
  }
  for (const [property, value] of shorthands) {
    const parser = getCachedParser(property);
    if (parser) {
      parser(value, target, units, inheritedFontWeight);
    } else if (!property.startsWith("--")) {
      console.warn(`Unsupported CSS property: ${property}`);
    }
  }
  for (const [property, value] of longhands) {
    const parser = getCachedParser(property);
    if (parser) {
      parser(value, target, units, inheritedFontWeight);
    } else if (!property.startsWith("--")) {
      console.warn(`Unsupported CSS property: ${property}`);
    }
  }
}

// src/css/inline-style-parser.ts
function parseInlineStyle(style) {
  const properties = {};
  if (!style || typeof style !== "string") {
    return properties;
  }
  const declarations = style.split(";");
  for (const decl of declarations) {
    const colonIndex = decl.indexOf(":");
    if (colonIndex === -1) continue;
    const property = decl.substring(0, colonIndex).trim();
    const value = decl.substring(colonIndex + 1).trim();
    if (property && value) {
      properties[property] = value;
    }
  }
  return properties;
}

// src/css/style-inheritance.ts
var StyleInheritanceResolver = class {
  /**
   * Resolve inherited properties from parent style
   */
  static resolveInheritedProperties(parentStyle, mergedDefaults) {
    return {
      color: parentStyle.color ?? mergedDefaults.color,
      fontSize: parentStyle.fontSize,
      lineHeight: cloneLineHeight(parentStyle.lineHeight),
      fontFamily: parentStyle.fontFamily ?? mergedDefaults.fontFamily,
      fontStyle: parentStyle.fontStyle ?? mergedDefaults.fontStyle,
      fontVariant: parentStyle.fontVariant ?? mergedDefaults.fontVariant,
      fontWeight: parentStyle.fontWeight ?? mergedDefaults.fontWeight,
      letterSpacing: parentStyle.letterSpacing ?? mergedDefaults.letterSpacing,
      textDecorationLine: parentStyle.textDecorationLine ?? mergedDefaults.textDecorationLine,
      textDecorationColor: parentStyle.textDecorationColor ?? mergedDefaults.textDecorationColor,
      textDecorationStyle: parentStyle.textDecorationStyle ?? mergedDefaults.textDecorationStyle,
      overflowWrap: parentStyle.overflowWrap ?? mergedDefaults.overflowWrap,
      textIndent: parentStyle.textIndent ?? mergedDefaults.textIndent ?? 0,
      textTransform: parentStyle.textTransform ?? mergedDefaults.textTransform ?? "none",
      listStyleType: parentStyle.listStyleType ?? mergedDefaults.listStyleType ?? "disc"
    };
  }
};

// src/css/css-unit-resolver.ts
var CssUnitResolver = class {
  constructor(fontSize, rootFontSize) {
    this.fontSize = fontSize;
    this.rootFontSize = rootFontSize;
  }
  /**
   * Resolve a LengthInput to absolute pixels
   */
  resolveLengthInput(value) {
    return resolveLengthInput(value, this.fontSize, this.rootFontSize);
  }
  /**
   * Resolve a numeric length (number or relative) to pixels
   */
  resolveNumberLike(value) {
    return resolveNumberLike(value, this.fontSize, this.rootFontSize);
  }
  /**
   * Resolve shadow length with optional clamping to non-negative
   */
  resolveShadowLength(value, clamp3 = false) {
    const resolved = this.resolveNumberLike(value);
    if (resolved === void 0) {
      return 0;
    }
    if (clamp3 && resolved < 0) {
      return 0;
    }
    return resolved;
  }
  /**
   * Create a callback to assign resolved length
   */
  createLengthAssigner(setter) {
    return (value) => {
      const resolved = this.resolveLengthInput(value);
      if (resolved !== void 0) {
        setter(resolved);
      }
    };
  }
  /**
   * Create a callback to assign resolved numeric length
   */
  createNumberAssigner(setter) {
    return (value) => {
      const resolved = this.resolveNumberLike(value);
      if (resolved !== void 0) {
        setter(resolved);
      }
    };
  }
};

// src/css/layout-property-resolver.ts
var LayoutPropertyResolver = class _LayoutPropertyResolver {
  /**
   * Resolve a track size input to absolute values
   */
  static resolveTrackSizeInputToAbsolute(track, fontSize, rootFontSize) {
    if (track.kind === "fixed") {
      return {
        kind: "fixed",
        size: resolveNumberLike(track.size, fontSize, rootFontSize) ?? 0
      };
    }
    if (track.kind === "flex") {
      return {
        kind: "flex",
        flex: track.flex,
        min: resolveNumberLike(track.min, fontSize, rootFontSize),
        max: resolveNumberLike(track.max, fontSize, rootFontSize)
      };
    }
    return {
      kind: "auto",
      min: resolveNumberLike(track.min, fontSize, rootFontSize),
      max: resolveNumberLike(track.max, fontSize, rootFontSize)
    };
  }
  /**
   * Resolve track definitions (for CSS Grid)
   */
  static resolveTrackDefinitionsInput(definitions, fontSize, rootFontSize) {
    if (!definitions) {
      return void 0;
    }
    return definitions.map((definition) => {
      if (definition.kind === "repeat") {
        return {
          kind: "repeat",
          count: definition.count,
          track: _LayoutPropertyResolver.resolveTrackSizeInputToAbsolute(
            definition.track,
            fontSize,
            rootFontSize
          )
        };
      }
      if (definition.kind === "repeat-auto") {
        return {
          kind: "repeat-auto",
          mode: definition.mode,
          track: _LayoutPropertyResolver.resolveTrackSizeInputToAbsolute(
            definition.track,
            fontSize,
            rootFontSize
          )
        };
      }
      return _LayoutPropertyResolver.resolveTrackSizeInputToAbsolute(definition, fontSize, rootFontSize);
    });
  }
};

// src/css/compute-style.ts
function mapFloat(value) {
  switch (value) {
    case "left":
      return "left" /* Left */;
    case "right":
      return "right" /* Right */;
    case "none":
      return "none" /* None */;
    default:
      return void 0;
  }
}
function defaultDisplayForTag(tag) {
  let display;
  switch (tag) {
    case "span":
    case "a":
    case "strong":
    case "em":
    case "b":
    case "s":
    case "strike":
    case "del":
    case "label":
    case "code":
    case "small":
    case "time":
    case "i":
    case "u":
    case "sub":
    case "sup":
    case "mark":
    case "abbr":
    case "cite":
    case "dfn":
    case "kbd":
    case "q":
    case "tt":
      display = "inline" /* Inline */;
      break;
    case "table":
      display = "table" /* Table */;
      break;
    case "tbody":
    case "thead":
    case "tfoot":
      display = "table-row-group" /* TableRowGroup */;
      break;
    case "tr":
      display = "table-row" /* TableRow */;
      break;
    case "td":
    case "th":
      display = "table-cell" /* TableCell */;
      break;
    case "caption":
      display = "table-caption" /* TableCaption */;
      break;
    case "div":
    case "section":
    case "main":
    case "article":
    case "header":
    case "footer":
    case "nav":
    case "p":
    case "ul":
    case "ol":
    case "li":
    case "h1":
    case "h2":
    case "h3":
    case "h4":
    case "h5":
    case "h6":
      display = "block" /* Block */;
      break;
    default:
      display = "block" /* Block */;
      break;
  }
  log("style", "trace", "defaultDisplayForTag", { tag, display });
  return display;
}
var RELATIVE_FONT_SIZE_TAG_SCALE = {
  small: 0.8,
  big: 1.2
};
function computeStyleForElement(element, cssRules, parentStyle, units, rootFontSize) {
  const tagName19 = element.tagName.toLowerCase();
  const elementDefaults = ElementSpecificDefaults.getDefaultsForElement(tagName19);
  const baseDefaults = BrowserDefaults.createBaseDefaults();
  const mergedDefaults = BrowserDefaults.mergeElementDefaults(baseDefaults, elementDefaults);
  const inherited = StyleInheritanceResolver.resolveInheritedProperties(parentStyle, mergedDefaults);
  const styleInit = {};
  const aggregated = {};
  for (const rule of cssRules) {
    if (rule.match(element)) {
      log("style", "debug", "CSS rule matched", { selector: rule.selector, declarations: rule.declarations });
      if (rule.declarations.display) {
        log("style", "debug", "Display declaration found", { selector: rule.selector, display: rule.declarations.display });
      }
      const normalizedRuleDeclarations = {};
      for (const [prop2, value] of Object.entries(rule.declarations)) {
        if (prop2.startsWith("--")) {
          normalizedRuleDeclarations[prop2] = value;
        } else {
          normalizedRuleDeclarations[prop2.toLowerCase()] = value;
        }
      }
      Object.assign(aggregated, normalizedRuleDeclarations);
    }
  }
  const inlineStyle = parseInlineStyle(element.getAttribute("style") ?? "");
  if (Object.keys(inlineStyle).length > 0) {
    log("style", "debug", "inline style applied", { declarations: inlineStyle });
  }
  Object.assign(aggregated, inlineStyle);
  let customProperties = parentStyle.customProperties ? parentStyle.customProperties.clone() : new CustomPropertiesMap();
  const elementCustomProps = extractCustomProperties(aggregated);
  customProperties = elementCustomProps.inherit(customProperties);
  log("style", "debug", "custom properties", {
    count: customProperties.size,
    keys: customProperties.keys()
  });
  const resolvedDeclarations = resolveDeclarationsWithVariables(aggregated, customProperties);
  applyDeclarationsToStyle(resolvedDeclarations, styleInit, units, inherited.fontWeight ?? mergedDefaults.fontWeight);
  const defaultDisplay = mergedDefaults.display ?? defaultDisplayForTag(tagName19);
  let display = styleInit.display ?? defaultDisplay;
  log("style", "debug", "computeStyleForElement display", {
    tagName: tagName19,
    styleInitDisplay: styleInit.display,
    defaultDisplay,
    finalDisplay: display
  });
  if (tagName19 === "table") {
    if (display !== "table" /* Table */) {
      log("style", "debug", "Forcing table display", { tagName: tagName19, originalDisplay: display });
      display = "table" /* Table */;
    }
  } else if (tagName19 === "thead" || tagName19 === "tbody" || tagName19 === "tfoot") {
    if (display !== "table-row-group" /* TableRowGroup */) {
      log("style", "debug", "Forcing table-row-group display", { tagName: tagName19, originalDisplay: display });
      display = "table-row-group" /* TableRowGroup */;
    }
  } else if (tagName19 === "tr") {
    if (display !== "table-row" /* TableRow */) {
      log("style", "debug", "Forcing table-row display", { tagName: tagName19, originalDisplay: display });
      display = "table-row" /* TableRow */;
    }
  } else if (tagName19 === "td" || tagName19 === "th") {
    if (display !== "table-cell" /* TableCell */) {
      log("style", "debug", "Forcing table-cell display", { tagName: tagName19, originalDisplay: display });
      display = "table-cell" /* TableCell */;
    }
  }
  const floatValue = mapFloat(styleInit.float);
  const elementDefinesFontWeight = elementDefaults.fontWeight !== void 0;
  const elementDefinesFontStyle = elementDefaults.fontStyle !== void 0;
  const elementDefinesFontSize = mergedDefaults.fontSize !== baseDefaults.fontSize;
  const elementDefinesLineHeight = !lineHeightEquals(mergedDefaults.lineHeight, baseDefaults.lineHeight);
  const styleOptions = {
    customProperties,
    // Start with merged defaults
    ...mergedDefaults,
    // Override with inherited values
    color: inherited.color,
    fontSize: elementDefinesFontSize ? mergedDefaults.fontSize : inherited.fontSize,
    lineHeight: cloneLineHeight(
      elementDefinesLineHeight ? mergedDefaults.lineHeight : inherited.lineHeight
    ),
    fontFamily: inherited.fontFamily,
    fontStyle: elementDefinesFontStyle ? mergedDefaults.fontStyle : inherited.fontStyle,
    fontWeight: elementDefinesFontWeight ? mergedDefaults.fontWeight : normalizeFontWeight(inherited.fontWeight),
    overflowWrap: inherited.overflowWrap,
    textIndent: inherited.textIndent ?? mergedDefaults.textIndent ?? 0,
    textTransform: inherited.textTransform ?? "none",
    letterSpacing: inherited.letterSpacing ?? mergedDefaults.letterSpacing,
    listStyleType: inherited.listStyleType ?? mergedDefaults.listStyleType ?? "disc",
    // Apply computed values
    display,
    float: floatValue ?? "none" /* None */,
    borderModel: styleInit.borderModel ?? mergedDefaults.borderModel
  };
  const rootFontReference = rootFontSize ?? parentStyle.fontSize ?? mergedDefaults.fontSize;
  const baseFontSize = styleOptions.fontSize ?? inherited.fontSize ?? mergedDefaults.fontSize;
  let computedFontSize = baseFontSize;
  if (styleInit.fontSize !== void 0) {
    const resolvedFontSize = resolveNumberLike(styleInit.fontSize, inherited.fontSize, rootFontReference);
    if (resolvedFontSize !== void 0) {
      computedFontSize = resolvedFontSize;
    }
  } else {
    const resolvedFontSize = resolveNumberLike(mergedDefaults.fontSize, inherited.fontSize, rootFontReference);
    if (resolvedFontSize !== void 0) {
      computedFontSize = resolvedFontSize;
    }
    const relativeScale = RELATIVE_FONT_SIZE_TAG_SCALE[tagName19];
    if (relativeScale !== void 0) {
      computedFontSize = (inherited.fontSize ?? 16) * relativeScale;
    }
  }
  styleOptions.fontSize = computedFontSize;
  if (styleInit.lineHeight !== void 0) {
    styleOptions.lineHeight = resolveLineHeightInput(
      styleInit.lineHeight,
      computedFontSize,
      rootFontReference
    );
  }
  const unitResolver = new CssUnitResolver(computedFontSize, rootFontReference);
  const assignLength = (value, setter) => {
    unitResolver.createLengthAssigner(setter)(value);
  };
  const assignNumberLength = (value, setter) => {
    unitResolver.createNumberAssigner(setter)(value);
  };
  if (styleInit.position !== void 0) styleOptions.position = styleInit.position;
  if (styleInit.top !== void 0) assignLength(styleInit.top, (v) => styleOptions.top = v);
  if (styleInit.right !== void 0) assignLength(styleInit.right, (v) => styleOptions.right = v);
  if (styleInit.bottom !== void 0) assignLength(styleInit.bottom, (v) => styleOptions.bottom = v);
  if (styleInit.left !== void 0) assignLength(styleInit.left, (v) => styleOptions.left = v);
  if (styleInit.zIndex !== void 0) styleOptions.zIndex = styleInit.zIndex;
  if (styleInit.color !== void 0) styleOptions.color = styleInit.color;
  if (styleInit.backgroundLayers !== void 0) styleOptions.backgroundLayers = styleInit.backgroundLayers;
  if (styleInit.clipPath !== void 0) styleOptions.clipPath = styleInit.clipPath;
  if (styleInit.borderColor !== void 0) styleOptions.borderColor = styleInit.borderColor;
  if (styleInit.borderStyleTop !== void 0) styleOptions.borderStyleTop = styleInit.borderStyleTop;
  if (styleInit.borderStyleRight !== void 0) styleOptions.borderStyleRight = styleInit.borderStyleRight;
  if (styleInit.borderStyleBottom !== void 0) styleOptions.borderStyleBottom = styleInit.borderStyleBottom;
  if (styleInit.borderStyleLeft !== void 0) styleOptions.borderStyleLeft = styleInit.borderStyleLeft;
  if (styleInit.boxShadows !== void 0) {
    styleOptions.boxShadows = styleInit.boxShadows.map((shadow) => ({
      inset: shadow.inset,
      offsetX: unitResolver.resolveShadowLength(shadow.offsetX),
      offsetY: unitResolver.resolveShadowLength(shadow.offsetY),
      blurRadius: unitResolver.resolveShadowLength(shadow.blurRadius, true),
      spreadRadius: unitResolver.resolveShadowLength(shadow.spreadRadius),
      color: shadow.color
    }));
  }
  if (styleInit.textShadows !== void 0) {
    styleOptions.textShadows = styleInit.textShadows.map((shadow) => ({
      offsetX: unitResolver.resolveShadowLength(shadow.offsetX),
      offsetY: unitResolver.resolveShadowLength(shadow.offsetY),
      blurRadius: unitResolver.resolveShadowLength(shadow.blurRadius, true),
      color: shadow.color
    }));
  }
  if (styleInit.fontFamily !== void 0) styleOptions.fontFamily = styleInit.fontFamily;
  if (styleInit.fontStyle !== void 0) styleOptions.fontStyle = styleInit.fontStyle;
  if (styleInit.fontVariant !== void 0) styleOptions.fontVariant = styleInit.fontVariant;
  if (styleInit.fontWeight !== void 0) styleOptions.fontWeight = normalizeFontWeight(styleInit.fontWeight);
  if (styleInit.overflowWrap !== void 0) styleOptions.overflowWrap = styleInit.overflowWrap;
  if (styleInit.marginTop !== void 0) assignLength(styleInit.marginTop, (v) => styleOptions.marginTop = v);
  else styleOptions.marginTop = resolveNumberLike(mergedDefaults.marginTop, computedFontSize, rootFontReference);
  if (styleInit.marginRight !== void 0) assignLength(styleInit.marginRight, (v) => styleOptions.marginRight = v);
  else styleOptions.marginRight = resolveNumberLike(mergedDefaults.marginRight, computedFontSize, rootFontReference);
  if (styleInit.marginBottom !== void 0) assignLength(styleInit.marginBottom, (v) => styleOptions.marginBottom = v);
  else styleOptions.marginBottom = resolveNumberLike(mergedDefaults.marginBottom, computedFontSize, rootFontReference);
  if (styleInit.marginLeft !== void 0) assignLength(styleInit.marginLeft, (v) => styleOptions.marginLeft = v);
  else styleOptions.marginLeft = resolveNumberLike(mergedDefaults.marginLeft, computedFontSize, rootFontReference);
  if (styleInit.paddingTop !== void 0) assignLength(styleInit.paddingTop, (v) => styleOptions.paddingTop = v);
  if (styleInit.paddingRight !== void 0) assignLength(styleInit.paddingRight, (v) => styleOptions.paddingRight = v);
  if (styleInit.paddingBottom !== void 0) assignLength(styleInit.paddingBottom, (v) => styleOptions.paddingBottom = v);
  if (styleInit.paddingLeft !== void 0) assignLength(styleInit.paddingLeft, (v) => styleOptions.paddingLeft = v);
  if (styleInit.borderTop !== void 0) assignLength(styleInit.borderTop, (v) => styleOptions.borderTop = v);
  if (styleInit.borderRight !== void 0) assignLength(styleInit.borderRight, (v) => styleOptions.borderRight = v);
  if (styleInit.borderBottom !== void 0) assignLength(styleInit.borderBottom, (v) => styleOptions.borderBottom = v);
  if (styleInit.borderLeft !== void 0) assignLength(styleInit.borderLeft, (v) => styleOptions.borderLeft = v);
  if (styleInit.borderTopLeftRadiusX !== void 0)
    assignNumberLength(styleInit.borderTopLeftRadiusX, (v) => styleOptions.borderTopLeftRadiusX = v);
  if (styleInit.borderTopLeftRadiusY !== void 0)
    assignNumberLength(styleInit.borderTopLeftRadiusY, (v) => styleOptions.borderTopLeftRadiusY = v);
  if (styleInit.borderTopRightRadiusX !== void 0)
    assignNumberLength(styleInit.borderTopRightRadiusX, (v) => styleOptions.borderTopRightRadiusX = v);
  if (styleInit.borderTopRightRadiusY !== void 0)
    assignNumberLength(styleInit.borderTopRightRadiusY, (v) => styleOptions.borderTopRightRadiusY = v);
  if (styleInit.borderBottomRightRadiusX !== void 0)
    assignNumberLength(styleInit.borderBottomRightRadiusX, (v) => styleOptions.borderBottomRightRadiusX = v);
  if (styleInit.borderBottomRightRadiusY !== void 0)
    assignNumberLength(styleInit.borderBottomRightRadiusY, (v) => styleOptions.borderBottomRightRadiusY = v);
  if (styleInit.borderBottomLeftRadiusX !== void 0)
    assignNumberLength(styleInit.borderBottomLeftRadiusX, (v) => styleOptions.borderBottomLeftRadiusX = v);
  if (styleInit.borderBottomLeftRadiusY !== void 0)
    assignNumberLength(styleInit.borderBottomLeftRadiusY, (v) => styleOptions.borderBottomLeftRadiusY = v);
  if (styleInit.width !== void 0) assignLength(styleInit.width, (v) => styleOptions.width = v);
  if (styleInit.minWidth !== void 0) assignLength(styleInit.minWidth, (v) => styleOptions.minWidth = v);
  if (styleInit.maxWidth !== void 0) assignLength(styleInit.maxWidth, (v) => styleOptions.maxWidth = v);
  if (styleInit.height !== void 0) assignLength(styleInit.height, (v) => styleOptions.height = v);
  if (styleInit.minHeight !== void 0) assignLength(styleInit.minHeight, (v) => styleOptions.minHeight = v);
  if (styleInit.maxHeight !== void 0) assignLength(styleInit.maxHeight, (v) => styleOptions.maxHeight = v);
  if (styleInit.trackListColumns !== void 0) {
    const resolved = LayoutPropertyResolver.resolveTrackDefinitionsInput(styleInit.trackListColumns, computedFontSize, rootFontReference);
    if (resolved) {
      styleOptions.trackListColumns = resolved;
    }
  }
  if (styleInit.trackListRows !== void 0) {
    const resolved = LayoutPropertyResolver.resolveTrackDefinitionsInput(styleInit.trackListRows, computedFontSize, rootFontReference);
    if (resolved) {
      styleOptions.trackListRows = resolved;
    }
  }
  if (styleInit.autoFlow !== void 0) {
    styleOptions.autoFlow = styleInit.autoFlow;
  }
  if (styleInit.rowGap !== void 0) {
    assignNumberLength(styleInit.rowGap, (v) => styleOptions.rowGap = v);
  }
  if (styleInit.columnGap !== void 0) {
    assignNumberLength(styleInit.columnGap, (v) => styleOptions.columnGap = v);
  }
  if (styleInit.justifyContent !== void 0) styleOptions.justifyContent = styleInit.justifyContent;
  if (styleInit.alignItems !== void 0) styleOptions.alignItems = styleInit.alignItems;
  if (styleInit.alignContent !== void 0) styleOptions.alignContent = styleInit.alignContent;
  if (styleInit.alignSelf !== void 0) styleOptions.alignSelf = styleInit.alignSelf;
  if (styleInit.flexDirection !== void 0) styleOptions.flexDirection = styleInit.flexDirection;
  if (styleInit.flexWrap !== void 0) styleOptions.flexWrap = styleInit.flexWrap;
  if (styleInit.textAlign !== void 0) styleOptions.textAlign = styleInit.textAlign;
  if (styleInit.textIndent !== void 0) assignLength(styleInit.textIndent, (v) => styleOptions.textIndent = v);
  if (styleInit.textTransform !== void 0) styleOptions.textTransform = styleInit.textTransform;
  if (styleInit.letterSpacing !== void 0) assignNumberLength(styleInit.letterSpacing, (v) => styleOptions.letterSpacing = v);
  if (styleInit.listStyleType !== void 0) styleOptions.listStyleType = styleInit.listStyleType;
  if (styleInit.transform !== void 0) {
    styleOptions.transform = styleInit.transform;
  }
  if (styleInit.objectFit !== void 0) {
    styleOptions.objectFit = styleInit.objectFit;
  }
  if (styleInit.opacity !== void 0) {
    styleOptions.opacity = styleInit.opacity;
  }
  const defaultDecoration = mergedDefaults.textDecorationLine ?? "none";
  let decoration = inherited.textDecorationLine ?? defaultDecoration;
  if (elementDefaults.textDecorationLine !== void 0) {
    decoration = elementDefaults.textDecorationLine;
  }
  if (styleInit.textDecorationLine !== void 0) {
    decoration = styleInit.textDecorationLine;
  }
  styleOptions.textDecorationLine = decoration;
  let decorationColor = styleInit.textDecorationColor !== void 0 ? normalizeTextDecorationColor(styleInit.textDecorationColor) : void 0;
  if (decorationColor === void 0) {
    decorationColor = elementDefaults.textDecorationColor !== void 0 ? normalizeTextDecorationColor(elementDefaults.textDecorationColor) : void 0;
  }
  if (decorationColor === void 0 && inherited.textDecorationColor !== void 0) {
    decorationColor = inherited.textDecorationColor;
  }
  if (decorationColor !== void 0) {
    styleOptions.textDecorationColor = decorationColor;
  }
  const defaultDecorationStyle = mergedDefaults.textDecorationStyle ?? "solid";
  let decorationStyle = inherited.textDecorationStyle ?? defaultDecorationStyle;
  if (elementDefaults.textDecorationStyle !== void 0) {
    decorationStyle = elementDefaults.textDecorationStyle;
  }
  if (styleInit.textDecorationStyle !== void 0) {
    decorationStyle = styleInit.textDecorationStyle;
  }
  styleOptions.textDecorationStyle = decorationStyle;
  if (tagName19 === "em" || tagName19 === "strong") {
    const debugInfo = {
      tagName: tagName19,
      elementDefaultsFontStyle: elementDefaults.fontStyle,
      mergedFontStyle: mergedDefaults.fontStyle,
      finalFontStyle: styleOptions.fontStyle
    };
    log("style", "debug", "element fontStyle", debugInfo);
  }
  return new ComputedStyle(styleOptions);
}
function normalizeTextDecorationColor(value) {
  if (value === void 0) {
    return void 0;
  }
  const trimmed = value.trim();
  if (!trimmed) {
    return void 0;
  }
  const lower = trimmed.toLowerCase();
  if (lower === "inherit") {
    return void 0;
  }
  if (lower === "initial") {
    return "currentcolor";
  }
  if (lower === "unset" || lower === "revert" || lower === "revert-layer") {
    return void 0;
  }
  return lower === "currentcolor" ? "currentcolor" : trimmed;
}

// src/html/image-converter.ts
init_empty();

// src/image/base-decoder.ts
var BaseDecoder = class {
  static calculateDimensions(width, height, options) {
    let targetWidth = width;
    let targetHeight = height;
    if (options.scale && options.scale > 0) {
      targetWidth = Math.max(1, Math.round(width * options.scale));
      targetHeight = Math.max(1, Math.round(height * options.scale));
    } else if (options.maxWidth || options.maxHeight) {
      const scale = Math.min(
        options.maxWidth ? options.maxWidth / width : Infinity,
        options.maxHeight ? options.maxHeight / height : Infinity
      );
      if (scale > 0 && scale < 1) {
        targetWidth = Math.max(1, Math.round(width * scale));
        targetHeight = Math.max(1, Math.round(height * scale));
      }
    }
    return { targetWidth, targetHeight };
  }
  // Optimized nearest-neighbor resize
  static resizeNN(src, sw, sh, tw, th, channels) {
    if (sw === tw && sh === th) return src;
    const dst = new Uint8Array(tw * th * channels);
    const xRatio = sw / tw;
    const yRatio = sh / th;
    for (let y = 0; y < th; y++) {
      const sy = Math.min(sh - 1, Math.floor(y * yRatio));
      const srcRowOffset = sy * sw * channels;
      const dstRowOffset = y * tw * channels;
      for (let x = 0; x < tw; x++) {
        const sx = Math.min(sw - 1, Math.floor(x * xRatio));
        const si = srcRowOffset + sx * channels;
        const di = dstRowOffset + x * channels;
        for (let c = 0; c < channels; c++) {
          dst[di + c] = src[si + c];
        }
      }
    }
    return dst;
  }
};

// src/image/jpeg-decoder.ts
var JpegDecoder = class _JpegDecoder extends BaseDecoder {
  static {
    this.SOI_MARKER = 65496;
  }
  static {
    this.EOI_MARKER = 65497;
  }
  static {
    this.SOF0_MARKER = 65472;
  }
  async decode(buffer, options = {}) {
    const view = new DataView(buffer);
    if (view.getUint16(0, false) !== _JpegDecoder.SOI_MARKER) {
      throw new Error("Invalid JPEG: missing SOI marker");
    }
    let offset = 2;
    let width = 0;
    let height = 0;
    let channels = 3;
    let precision = 8;
    while (offset + 4 < buffer.byteLength) {
      const marker = view.getUint16(offset, false);
      offset += 2;
      if (marker === _JpegDecoder.EOI_MARKER) {
        break;
      }
      const length = view.getUint16(offset, false);
      if (marker === _JpegDecoder.SOF0_MARKER) {
        precision = view.getUint8(offset + 2);
        height = view.getUint16(offset + 3, false);
        width = view.getUint16(offset + 5, false);
        channels = view.getUint8(offset + 7);
        break;
      }
      offset += length;
    }
    if (width === 0 || height === 0) {
      throw new Error("Invalid JPEG: missing SOF0 marker");
    }
    const { targetWidth, targetHeight } = _JpegDecoder.calculateDimensions(
      width,
      height,
      options
    );
    const dataCopy = buffer.slice(0);
    return {
      width: targetWidth,
      height: targetHeight,
      format: "jpeg",
      channels,
      bitsPerChannel: precision,
      data: dataCopy
    };
  }
};

// src/image/png-decoder.ts
async function defaultInflateRaw(data) {
  if (typeof DecompressionStream !== "undefined") {
    const ds = new DecompressionStream("deflate-raw");
    const stream = new Blob([data]).stream().pipeThrough(ds);
    const out = await new Response(stream).arrayBuffer();
    return new Uint8Array(out);
  } else {
    const { inflateRawSync } = await Promise.resolve().then(() => (init_zlib_empty(), zlib_empty_exports));
    return inflateRawSync(data);
  }
}
async function defaultInflateZlib(data) {
  if (typeof DecompressionStream !== "undefined") {
    const ds = new DecompressionStream("deflate");
    const stream = new Blob([data]).stream().pipeThrough(ds);
    const out = await new Response(stream).arrayBuffer();
    return new Uint8Array(out);
  } else {
    const { inflateSync: inflateSync2 } = await Promise.resolve().then(() => (init_zlib_empty(), zlib_empty_exports));
    return inflateSync2(data);
  }
}
function extractSample(bytes, index, bitDepth) {
  const samplesPerByte = 8 / bitDepth;
  const byteIndex = Math.floor(index / samplesPerByte);
  const sampleOffset = index % samplesPerByte;
  const shift = 8 - bitDepth * (sampleOffset + 1);
  const mask = (1 << bitDepth) - 1;
  return bytes[byteIndex] >> shift & mask;
}
function scaleTo8bit(value, bitDepth) {
  const maxValue = (1 << bitDepth) - 1;
  return Math.round(value / maxValue * 255);
}
function paethPredictor(a, b, c) {
  const p = a + b - c;
  const pa = Math.abs(p - a);
  const pb = Math.abs(p - b);
  const pc = Math.abs(p - c);
  return pa <= pb && pa <= pc ? a : pb <= pc ? b : c;
}
var PngDecoder = class _PngDecoder extends BaseDecoder {
  static {
    this.PNG_SIGNATURE = [137, 80, 78, 71, 13, 10, 26, 10];
  }
  constructor(decompression = {}) {
    super();
    this.decompression = {
      inflateRaw: decompression.inflateRaw ?? defaultInflateRaw,
      inflateZlib: decompression.inflateZlib ?? defaultInflateZlib
    };
  }
  async decode(buffer, options = {}) {
    const view = new DataView(buffer);
    _PngDecoder.validateSignature(view);
    const { metadata, idatChunks } = _PngDecoder.parseChunks(buffer, view);
    _PngDecoder.validateMetadata(metadata);
    const decompressed = await this.decompressImageData(idatChunks);
    const pixelData = _PngDecoder.decodeScanlines(decompressed, metadata);
    const { targetWidth, targetHeight } = _PngDecoder.calculateDimensions(
      metadata.width,
      metadata.height,
      options
    );
    const finalData = _PngDecoder.resizeNN(
      pixelData,
      metadata.width,
      metadata.height,
      targetWidth,
      targetHeight,
      4
    );
    return {
      width: targetWidth,
      height: targetHeight,
      format: "png",
      channels: 4,
      bitsPerChannel: 8,
      data: finalData.buffer
    };
  }
  // --- Private Methods ---
  static validateSignature(view) {
    for (let i = 0; i < _PngDecoder.PNG_SIGNATURE.length; i++) {
      if (view.getUint8(i) !== _PngDecoder.PNG_SIGNATURE[i]) {
        throw new Error("Invalid PNG signature");
      }
    }
  }
  static parseChunks(buffer, view) {
    let offset = 8;
    const idatChunks = [];
    const metadata = {
      palette: null,
      transparency: null
    };
    let sawIDAT = false;
    let sawIEND = false;
    while (offset < buffer.byteLength) {
      if (offset + 8 > buffer.byteLength) {
        throw new Error("Incomplete chunk header");
      }
      const length = view.getUint32(offset, false);
      const type = String.fromCharCode(
        view.getUint8(offset + 4),
        view.getUint8(offset + 5),
        view.getUint8(offset + 6),
        view.getUint8(offset + 7)
      );
      const dataOffset = offset + 8;
      if (offset + 12 + length > buffer.byteLength) {
        throw new Error(`Chunk ${type} extends beyond file boundary`);
      }
      switch (type) {
        case "IHDR":
          _PngDecoder.parseIHDR(view, dataOffset, metadata);
          break;
        case "PLTE":
          if (sawIDAT) throw new Error("PLTE chunk must appear before IDAT");
          _PngDecoder.parsePLTE(buffer, dataOffset, length, metadata);
          break;
        case "tRNS":
          if (sawIDAT) throw new Error("tRNS chunk must appear before IDAT");
          _PngDecoder.parseTRNS(buffer, dataOffset, length, metadata);
          break;
        case "IDAT":
          sawIDAT = true;
          idatChunks.push(new Uint8Array(buffer, dataOffset, length));
          break;
        case "IEND":
          sawIEND = true;
          offset += 12 + length;
          break;
        default:
          break;
      }
      if (sawIEND) break;
      offset += 12 + length;
    }
    if (!sawIEND) throw new Error("Missing IEND chunk");
    if (!sawIDAT) throw new Error("Missing IDAT chunk");
    return { metadata, idatChunks };
  }
  static parseIHDR(view, offset, metadata) {
    metadata.width = view.getUint32(offset, false);
    metadata.height = view.getUint32(offset + 4, false);
    metadata.bitDepth = view.getUint8(offset + 8);
    metadata.colorType = view.getUint8(offset + 9);
    const compressionMethod = view.getUint8(offset + 10);
    const filterMethod = view.getUint8(offset + 11);
    metadata.interlaceMethod = view.getUint8(offset + 12);
    if (compressionMethod !== 0) throw new Error("Unsupported compression method");
    if (filterMethod !== 0) throw new Error("Unsupported filter method");
  }
  static parsePLTE(buffer, offset, length, metadata) {
    if (length % 3 !== 0) throw new Error("Invalid PLTE chunk length");
    if (length / 3 > 256) throw new Error("PLTE has too many entries");
    metadata.palette = new Uint8Array(buffer, offset, length);
  }
  static parseTRNS(buffer, offset, length, metadata) {
    metadata.transparency = new Uint8Array(buffer, offset, length);
  }
  static validateMetadata(metadata) {
    if (!metadata.width || !metadata.height) {
      throw new Error("Missing or invalid IHDR chunk");
    }
    if (metadata.colorType === 3 && !metadata.palette) {
      throw new Error("Indexed color PNG missing PLTE chunk");
    }
    if (metadata.interlaceMethod !== 0) {
      throw new Error("Interlaced PNGs are not supported");
    }
    const validBitDepths = {
      0: [1, 2, 4, 8, 16],
      2: [8, 16],
      3: [1, 2, 4, 8],
      4: [8, 16],
      6: [8, 16]
    };
    if (!validBitDepths[metadata.colorType]?.includes(metadata.bitDepth)) {
      throw new Error(
        `Invalid bit depth ${metadata.bitDepth} for color type ${metadata.colorType}`
      );
    }
  }
  async decompressImageData(chunks) {
    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
    const compressed = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      compressed.set(chunk, offset);
      offset += chunk.length;
    }
    const isZlib = (compressed[0] & 15) === 8;
    try {
      return isZlib ? await this.decompression.inflateZlib(compressed) : await this.decompression.inflateRaw(compressed.slice(2, -4));
    } catch (error) {
      throw new Error(`Decompression failed: ${error}`);
    }
  }
  static decodeScanlines(decompressed, metadata) {
    const { width, height, bitDepth, colorType } = metadata;
    const channels = _PngDecoder.getChannelCount(colorType);
    const bitsPerPixel = bitDepth * channels;
    const bytesPerRow = Math.ceil(bitsPerPixel * width / 8);
    const bytesPerPixel = Math.max(1, Math.ceil(bitsPerPixel / 8));
    const pixelData = new Uint8Array(width * height * 4);
    let prevRow = new Uint8Array(bytesPerRow);
    let offset = 0;
    for (let y = 0; y < height; y++) {
      const filterType = decompressed[offset++];
      const scanline = decompressed.subarray(offset, offset + bytesPerRow);
      offset += bytesPerRow;
      const currentRow = _PngDecoder.reconstructRow(
        scanline,
        prevRow,
        filterType,
        bytesPerPixel
      );
      _PngDecoder.convertRowToRGBA(
        currentRow,
        pixelData,
        y,
        width,
        metadata
      );
      prevRow = currentRow;
    }
    return pixelData;
  }
  static getChannelCount(colorType) {
    const channelMap = {
      0: 1,
      // Grayscale
      2: 3,
      // RGB
      3: 1,
      // Indexed
      4: 2,
      // Grayscale + Alpha
      6: 4
      // RGBA
    };
    return channelMap[colorType];
  }
  static reconstructRow(scanline, prevRow, filterType, bpp) {
    const row = new Uint8Array(scanline.length);
    for (let i = 0; i < scanline.length; i++) {
      const left = i >= bpp ? row[i - bpp] : 0;
      const up = prevRow[i];
      const upLeft = i >= bpp ? prevRow[i - bpp] : 0;
      let value;
      switch (filterType) {
        case 0:
          value = scanline[i];
          break;
        case 1:
          value = scanline[i] + left;
          break;
        case 2:
          value = scanline[i] + up;
          break;
        case 3:
          value = scanline[i] + (left + up >>> 1);
          break;
        case 4:
          value = scanline[i] + paethPredictor(left, up, upLeft);
          break;
        default:
          throw new Error(`Invalid filter type: ${filterType}`);
      }
      row[i] = value & 255;
    }
    return row;
  }
  static convertRowToRGBA(row, pixelData, y, width, metadata) {
    const { colorType, bitDepth, palette, transparency } = metadata;
    switch (colorType) {
      case 0:
        _PngDecoder.convertGrayscale(row, pixelData, y, width, bitDepth, transparency);
        break;
      case 2:
        _PngDecoder.convertRGB(row, pixelData, y, width, bitDepth, transparency);
        break;
      case 3:
        _PngDecoder.convertIndexed(row, pixelData, y, width, bitDepth, palette, transparency);
        break;
      case 4:
        _PngDecoder.convertGrayscaleAlpha(row, pixelData, y, width, bitDepth);
        break;
      case 6:
        _PngDecoder.convertRGBA(row, pixelData, y, width, bitDepth);
        break;
    }
  }
  static convertGrayscale(row, pixelData, y, width, bitDepth, transparency) {
    for (let x = 0; x < width; x++) {
      let gray;
      if (bitDepth === 8) {
        gray = row[x];
      } else if (bitDepth === 16) {
        gray = row[x * 2];
      } else {
        const sample = extractSample(row, x, bitDepth);
        gray = scaleTo8bit(sample, bitDepth);
      }
      const offset = (y * width + x) * 4;
      pixelData[offset] = gray;
      pixelData[offset + 1] = gray;
      pixelData[offset + 2] = gray;
      pixelData[offset + 3] = transparency && gray === transparency[1] ? 0 : 255;
    }
  }
  static convertRGB(row, pixelData, y, width, bitDepth, transparency) {
    const bytesPerPixel = bitDepth === 16 ? 6 : 3;
    const step = bitDepth === 16 ? 2 : 1;
    for (let x = 0; x < width; x++) {
      const srcOffset = x * bytesPerPixel;
      const dstOffset = (y * width + x) * 4;
      const r = row[srcOffset];
      const g = row[srcOffset + step];
      const b = row[srcOffset + step * 2];
      pixelData[dstOffset] = r;
      pixelData[dstOffset + 1] = g;
      pixelData[dstOffset + 2] = b;
      const isTransparent = transparency && r === transparency[1] && g === transparency[3] && b === transparency[5];
      pixelData[dstOffset + 3] = isTransparent ? 0 : 255;
    }
  }
  static convertIndexed(row, pixelData, y, width, bitDepth, palette, transparency) {
    for (let x = 0; x < width; x++) {
      const index = bitDepth === 8 ? row[x] : extractSample(row, x, bitDepth);
      const paletteOffset = index * 3;
      const pixelOffset = (y * width + x) * 4;
      pixelData[pixelOffset] = palette[paletteOffset];
      pixelData[pixelOffset + 1] = palette[paletteOffset + 1];
      pixelData[pixelOffset + 2] = palette[paletteOffset + 2];
      pixelData[pixelOffset + 3] = transparency && index < transparency.length ? transparency[index] : 255;
    }
  }
  static convertGrayscaleAlpha(row, pixelData, y, width, bitDepth) {
    const bytesPerPixel = bitDepth === 16 ? 4 : 2;
    const step = bitDepth === 16 ? 2 : 1;
    for (let x = 0; x < width; x++) {
      const srcOffset = x * bytesPerPixel;
      const dstOffset = (y * width + x) * 4;
      const gray = row[srcOffset];
      const alpha = row[srcOffset + step];
      pixelData[dstOffset] = gray;
      pixelData[dstOffset + 1] = gray;
      pixelData[dstOffset + 2] = gray;
      pixelData[dstOffset + 3] = alpha;
    }
  }
  static convertRGBA(row, pixelData, y, width, bitDepth) {
    const bytesPerPixel = bitDepth === 16 ? 8 : 4;
    const step = bitDepth === 16 ? 2 : 1;
    for (let x = 0; x < width; x++) {
      const srcOffset = x * bytesPerPixel;
      const dstOffset = (y * width + x) * 4;
      pixelData[dstOffset] = row[srcOffset];
      pixelData[dstOffset + 1] = row[srcOffset + step];
      pixelData[dstOffset + 2] = row[srcOffset + step * 2];
      pixelData[dstOffset + 3] = row[srcOffset + step * 3];
    }
  }
};

// src/image/webp-riff-parser.ts
var WebpRiffParser = class {
  /**
   * Validate RIFF header signature
   */
  validateHeader(reader) {
    const riff = reader.getString(4);
    if (riff !== "RIFF") {
      throw new Error("Invalid WebP: Missing RIFF header");
    }
    reader.getUint32(true);
    const webp = reader.getString(4);
    if (webp !== "WEBP") {
      throw new Error("Invalid WebP: Missing WEBP signature");
    }
  }
  /**
   * Parse all chunks from the RIFF container
   */
  parseChunks(reader) {
    const chunks = [];
    while (reader.hasMore()) {
      const fourCC = reader.getString(4);
      const size = reader.getUint32(true);
      const data = reader.getView(size);
      chunks.push({ fourCC, size, data });
      if (size % 2 === 1 && reader.hasMore()) {
        reader.seek(reader.tell() + 1);
      }
    }
    return chunks;
  }
};

// src/image/webp-huffman.ts
var CODE_LENGTH_ORDER = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
var HUFFMAN_GROUPS = 5;
var WebpHuffmanDecoder = class {
  /**
   * Read all Huffman code groups (5 groups for VP8L)
   */
  readHuffmanCodes(br) {
    const huffmanCodes = [];
    for (let i = 0; i < HUFFMAN_GROUPS; i++) {
      const alphabetSize = i === 4 ? 40 : 280;
      huffmanCodes[i] = this.readHuffmanCode(br, alphabetSize);
    }
    return huffmanCodes;
  }
  /**
   * Read a single Huffman code
   */
  readHuffmanCode(br, alphabetSize) {
    const simple = br.readBits(1);
    if (simple) {
      return this.readSimpleHuffmanCode(br);
    }
    const codeLengthCodeLengths = new Array(19).fill(0);
    const numCodeLengthCodes = 4 + br.readBits(4);
    for (let i = 0; i < numCodeLengthCodes; i++) {
      codeLengthCodeLengths[CODE_LENGTH_ORDER[i]] = br.readBits(3);
    }
    const codeLengthTree = this.buildHuffmanTree(codeLengthCodeLengths);
    const codeLengths = this.readCodeLengths(br, codeLengthTree, alphabetSize);
    return this.buildHuffmanTree(codeLengths);
  }
  /**
   * Read simple Huffman code (1 or 2 symbols)
   */
  readSimpleHuffmanCode(br) {
    const numSymbols = br.readBits(1) + 1;
    const symbols = [];
    const is8Bits = br.readBits(1);
    const bitCount = is8Bits ? 8 : 1;
    symbols.push(br.readBits(bitCount));
    if (numSymbols === 2) {
      symbols.push(br.readBits(bitCount));
    }
    return this.buildSimpleHuffman(symbols);
  }
  /**
   * Read code lengths for symbols
   */
  readCodeLengths(br, codeLengthTree, alphabetSize) {
    const codeLengths = new Array(alphabetSize).fill(0);
    let i = 0;
    while (i < alphabetSize) {
      const code = this.readSymbol(br, codeLengthTree);
      if (code < 16) {
        codeLengths[i++] = code;
      } else {
        let repeatCount = 0;
        let repeatValue = 0;
        if (code === 16) {
          repeatCount = 3 + br.readBits(2);
          repeatValue = codeLengths[i - 1];
        } else if (code === 17) {
          repeatCount = 3 + br.readBits(3);
        } else if (code === 18) {
          repeatCount = 11 + br.readBits(7);
        }
        for (let j = 0; j < repeatCount && i < alphabetSize; j++) {
          codeLengths[i++] = repeatValue;
        }
      }
    }
    return codeLengths;
  }
  /**
   * Build simple Huffman tree from 1-2 symbols
   */
  buildSimpleHuffman(symbols) {
    if (symbols.length === 1) {
      return { codes: [{ symbol: symbols[0], length: 0, code: 0 }], maxLength: 0 };
    }
    return {
      codes: [
        { symbol: symbols[0], length: 1, code: 0 },
        { symbol: symbols[1], length: 1, code: 1 }
      ],
      maxLength: 1
    };
  }
  /**
   * Build Huffman tree from code lengths using canonical Huffman code algorithm
   */
  buildHuffmanTree(codeLengths) {
    const validLengths = codeLengths.filter((len) => len > 0 && Number.isFinite(len));
    const maxLength = validLengths.length > 0 ? Math.max(...validLengths) : 0;
    const codes = [];
    if (maxLength === 0) {
      return { codes: [], maxLength: 0, lookupTable: /* @__PURE__ */ new Map() };
    }
    const bl_count = new Array(maxLength + 1).fill(0);
    const next_code = new Array(maxLength + 1).fill(0);
    for (const len of codeLengths) {
      if (len > 0 && Number.isFinite(len)) bl_count[len]++;
    }
    next_code[1] = 0;
    for (let bits = 2; bits <= maxLength; bits++) {
      next_code[bits] = next_code[bits - 1] + bl_count[bits - 1] << 1;
    }
    const lookupTable = /* @__PURE__ */ new Map();
    for (let n = 0; n < codeLengths.length; n++) {
      const len = codeLengths[n];
      if (len > 0 && Number.isFinite(len)) {
        const codeValue = next_code[len];
        codes.push({ symbol: n, length: len, code: codeValue });
        const key2 = codeValue << 4 | len;
        lookupTable.set(key2, n);
        next_code[len]++;
      }
    }
    return { codes, maxLength, lookupTable };
  }
  /**
   * Read a symbol from the bitstream using the Huffman tree
   */
  readSymbol(br, tree) {
    if (tree.maxLength === 0) {
      return tree.codes[0].symbol;
    }
    if (tree.lookupTable) {
      let code = 0;
      for (let i = 0; i < tree.maxLength; i++) {
        code = code << 1 | br.readBits(1);
        const key2 = code << 4 | i + 1;
        const symbol = tree.lookupTable.get(key2);
        if (symbol !== void 0) {
          return symbol;
        }
      }
    }
    for (const codeInfo of tree.codes) {
      let code = 0;
      for (let i = 0; i < codeInfo.length; i++) {
        code = code << 1 | br.readBits(1);
      }
      if (code === codeInfo.code) {
        return codeInfo.symbol;
      }
    }
    return 0;
  }
};

// src/image/webp-vp8l-decoder.ts
var VP8L_SIGNATURE = 47;
var Vp8lDecoder = class {
  constructor() {
    this.huffmanDecoder = new WebpHuffmanDecoder();
  }
  /**
   * Decode a VP8L chunk into image data
   */
  decodeVp8l(chunk, options, calculateDimensions, resizeNN) {
    const br = new BitReader2(chunk.data);
    const signature = br.readBits(8);
    if (signature !== VP8L_SIGNATURE) {
      throw new Error("Invalid VP8L signature");
    }
    const width = br.readBits(14) + 1;
    const height = br.readBits(14) + 1;
    const version = br.readBits(3);
    if (version !== 0) {
      throw new Error(`Unsupported VP8L version: ${version}`);
    }
    let transformsPresent = br.readBits(1);
    while (transformsPresent) {
      const transformType = br.readBits(2);
      if (transformType === 0 || transformType === 1) {
        const sizeBits = br.readBits(3) + 2;
        const blockWidth = this.subSampleSize(width, sizeBits);
        const blockHeight = this.subSampleSize(height, sizeBits);
        this.skipTransformImage(br, blockWidth, blockHeight);
      } else if (transformType === 3) {
      }
      transformsPresent = br.readBits(1);
    }
    const huffmanCodes = this.huffmanDecoder.readHuffmanCodes(br);
    const pixels = this.decodePixelData(br, width, height, huffmanCodes);
    const { targetWidth, targetHeight } = calculateDimensions(width, height, options);
    const finalPixels = resizeNN(pixels, width, height, targetWidth, targetHeight, 4);
    return {
      width: targetWidth,
      height: targetHeight,
      format: "webp",
      channels: 4,
      bitsPerChannel: 8,
      data: finalPixels.buffer
    };
  }
  /**
   * Decode pixel data from VP8L bitstream
   */
  decodePixelData(br, width, height, huffmanCodes) {
    const pixels = new Uint8Array(width * height * 4);
    let pixelIndex = 0;
    const totalPixels = width * height;
    for (let i = 0; i < totalPixels; i++) {
      const green = this.huffmanDecoder.readSymbol(br, huffmanCodes[0]);
      if (green < 256) {
        const red = this.huffmanDecoder.readSymbol(br, huffmanCodes[1]);
        const blue = this.huffmanDecoder.readSymbol(br, huffmanCodes[2]);
        const alpha = this.huffmanDecoder.readSymbol(br, huffmanCodes[3]);
        pixels[pixelIndex++] = red;
        pixels[pixelIndex++] = green;
        pixels[pixelIndex++] = blue;
        pixels[pixelIndex++] = alpha;
      } else {
        const lengthSymbol = green - 256;
        const length = this.getLengthFromSymbol(lengthSymbol, br);
        const distSymbol = this.huffmanDecoder.readSymbol(br, huffmanCodes[4]);
        const distance = this.getDistanceFromSymbol(distSymbol, br);
        for (let j = 0; j < length && i + j < totalPixels; j++) {
          const srcIdx = pixelIndex - distance * 4;
          if (srcIdx >= 0) {
            pixels[pixelIndex++] = pixels[srcIdx];
            pixels[pixelIndex++] = pixels[srcIdx + 1];
            pixels[pixelIndex++] = pixels[srcIdx + 2];
            pixels[pixelIndex++] = pixels[srcIdx + 3];
          }
        }
        i += length - 1;
      }
    }
    return pixels;
  }
  /**
   * Calculate subsampled size
   */
  subSampleSize(size, samplingBits) {
    return size + (1 << samplingBits) - 1 >> samplingBits;
  }
  /**
   * Skip transform image data (simplified skip logic)
   */
  skipTransformImage(br, width, height) {
    try {
      this.huffmanDecoder.readHuffmanCodes(br);
    } catch {
      const maxBitsToSkip = Math.min(width * height * 4, 1e4);
      for (let i = 0; i < maxBitsToSkip && br.hasMore(); i++) {
        br.readBits(1);
      }
      return;
    }
    const totalPixels = width * height;
    for (let i = 0; i < Math.min(totalPixels * 4, 1e4); i++) {
      if (!br.hasMore()) break;
      br.readBits(1);
    }
  }
  /**
   * Get length from LZ77 symbol
   */
  getLengthFromSymbol(symbol, br) {
    if (symbol < 4) return symbol + 1;
    const extraBits = symbol - 2 >> 1;
    const offset = 2 + (symbol & 1) << extraBits;
    return offset + br.readBits(extraBits) + 1;
  }
  /**
   * Get distance from LZ77 symbol
   */
  getDistanceFromSymbol(symbol, br) {
    if (symbol < 4) return symbol + 1;
    const extraBits = symbol - 2 >> 1;
    const offset = 2 + (symbol & 1) << extraBits;
    return offset + br.readBits(extraBits) + 1;
  }
  /**
   * Decode VP8X extended format
   */
  decodeVp8x(chunk, chunks, options, calculateDimensions, resizeNN) {
    const data = new Uint8Array(chunk.data.buffer, chunk.data.byteOffset, chunk.data.byteLength);
    const flags = data[0];
    const hasAnimation = (flags & 2) !== 0;
    if (hasAnimation) {
      throw new Error("Animated WebP is not supported");
    }
    const vp8lChunk = chunks.find((c) => c.fourCC === "VP8L");
    if (vp8lChunk) {
      return this.decodeVp8l(vp8lChunk, options, calculateDimensions, resizeNN);
    }
    const vp8Chunk = chunks.find((c) => c.fourCC === "VP8 ");
    if (vp8Chunk) {
      throw new Error("VP8 (lossy) WebP format is not yet supported");
    }
    throw new Error("No image data found in VP8X container");
  }
};

// src/image/webp-decoder.ts
var TEXT_DECODER = new TextDecoder("ascii");
var DataReader2 = class {
  constructor(buffer) {
    this.offset = 0;
    this.view = new DataView(buffer);
  }
  seek(offset) {
    if (offset < 0 || offset > this.view.byteLength) {
      throw new RangeError(`Seek offset ${offset} out of bounds [0, ${this.view.byteLength}]`);
    }
    this.offset = offset;
  }
  tell() {
    return this.offset;
  }
  hasMore() {
    return this.offset < this.view.byteLength;
  }
  getUint8() {
    this.checkBounds(1);
    const value = this.view.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  getUint16(littleEndian = false) {
    this.checkBounds(2);
    const value = this.view.getUint16(this.offset, littleEndian);
    this.offset += 2;
    return value;
  }
  getUint32(littleEndian = false) {
    this.checkBounds(4);
    const value = this.view.getUint32(this.offset, littleEndian);
    this.offset += 4;
    return value;
  }
  getString(length) {
    this.checkBounds(length);
    const bytes = new Uint8Array(this.view.buffer, this.view.byteOffset + this.offset, length);
    this.offset += length;
    return TEXT_DECODER.decode(bytes);
  }
  getView(length) {
    this.checkBounds(length);
    const view = new DataView(this.view.buffer, this.view.byteOffset + this.offset, length);
    this.offset += length;
    return view;
  }
  checkBounds(length) {
    if (this.offset + length > this.view.byteLength) {
      throw new RangeError(`Read beyond buffer bounds: ${this.offset + length} > ${this.view.byteLength}`);
    }
  }
};
var BitReader2 = class {
  constructor(view) {
    this.bytePos = 0;
    this.bitPos = 0;
    this.view = view;
  }
  readBits(n) {
    if (n > 32) {
      throw new Error("Cannot read more than 32 bits at once");
    }
    let value = 0;
    for (let i = 0; i < n; i++) {
      if (this.bytePos >= this.view.byteLength) {
        return value;
      }
      const byte = this.view.getUint8(this.bytePos);
      const bit = byte >> this.bitPos & 1;
      value |= bit << i;
      this.bitPos++;
      if (this.bitPos === 8) {
        this.bitPos = 0;
        this.bytePos++;
      }
    }
    return value;
  }
  hasMore() {
    return this.bytePos < this.view.byteLength;
  }
  // For debugging - peek at next bits without consuming them
  peekBits(n) {
    const oldBytePos = this.bytePos;
    const oldBitPos = this.bitPos;
    const value = this.readBits(n);
    this.bytePos = oldBytePos;
    this.bitPos = oldBitPos;
    return value;
  }
};
var BaseDecoder2 = class {
  static calculateDimensions(width, height, options) {
    let targetWidth = width;
    let targetHeight = height;
    if (options.scale && options.scale > 0) {
      targetWidth = Math.max(1, Math.round(width * options.scale));
      targetHeight = Math.max(1, Math.round(height * options.scale));
    } else if (options.maxWidth || options.maxHeight) {
      const scale = Math.min(
        options.maxWidth ? options.maxWidth / width : Infinity,
        options.maxHeight ? options.maxHeight / height : Infinity
      );
      if (scale > 0 && scale < 1) {
        targetWidth = Math.max(1, Math.round(width * scale));
        targetHeight = Math.max(1, Math.round(height * scale));
      }
    }
    return { targetWidth, targetHeight };
  }
  static resizeNN(src, sw, sh, tw, th, channels) {
    if (sw === tw && sh === th) return src;
    const dst = new Uint8Array(tw * th * channels);
    const xRatio = sw / tw;
    const yRatio = sh / th;
    for (let y = 0; y < th; y++) {
      const sy = Math.min(sh - 1, Math.floor(y * yRatio));
      const srcRowOffset = sy * sw * channels;
      const dstRowOffset = y * tw * channels;
      for (let x = 0; x < tw; x++) {
        const sx = Math.min(sw - 1, Math.floor(x * xRatio));
        const si = srcRowOffset + sx * channels;
        const di = dstRowOffset + x * channels;
        for (let c = 0; c < channels; c++) {
          dst[di + c] = src[si + c];
        }
      }
    }
    return dst;
  }
};
var WebpDecoder = class _WebpDecoder extends BaseDecoder2 {
  constructor() {
    super(...arguments);
    this.riffParser = new WebpRiffParser();
    this.vp8lDecoder = new Vp8lDecoder();
  }
  async decode(buffer, options = {}) {
    const reader = new DataReader2(buffer);
    this.riffParser.validateHeader(reader);
    const chunks = this.riffParser.parseChunks(reader);
    const vp8xChunk = chunks.find((c) => c.fourCC === "VP8X");
    if (vp8xChunk) {
      return this.vp8lDecoder.decodeVp8x(vp8xChunk, chunks, options, _WebpDecoder.calculateDimensions, _WebpDecoder.resizeNN);
    }
    const vp8lChunk = chunks.find((c) => c.fourCC === "VP8L");
    if (vp8lChunk) {
      return this.vp8lDecoder.decodeVp8l(vp8lChunk, options, _WebpDecoder.calculateDimensions, _WebpDecoder.resizeNN);
    }
    const vp8Chunk = chunks.find((c) => c.fourCC === "VP8 ");
    if (vp8Chunk) {
      throw new Error("VP8 (lossy) WebP format is not yet supported");
    }
    throw new Error("Unsupported WebP format: No recognized image chunk found");
  }
};

// src/environment/node-environment.browser.ts
var NoopLoader = class {
  async load(_source) {
    throw new Error("NodeEnvironment is not available in browser builds");
  }
};
var NoopCompression = class {
  async inflateRaw(_data) {
    throw new Error("NodeEnvironment compression is not available in browser builds");
  }
};
var NodeEnvironment = class {
  constructor() {
    this.loader = new NoopLoader();
    this.compression = new NoopCompression();
  }
  resolveLocal() {
    throw new Error("NodeEnvironment resolveLocal is not available in browser builds");
  }
  now() {
    return typeof performance !== "undefined" ? performance.now() : Date.now();
  }
  getEnv(_name) {
    return void 0;
  }
};

// src/image/image-service.ts
var ImageService = class _ImageService {
  constructor(env) {
    this.imageCache = /* @__PURE__ */ new Map();
    this.jpegDecoder = new JpegDecoder();
    this.pngDecoder = new PngDecoder();
    this.webpDecoder = new WebpDecoder();
    this.env = env ?? globalEnvironmentFallback();
  }
  /**
   * Singleton pattern implementation
   */
  static getInstance(env) {
    if (!_ImageService.instance) {
      _ImageService.instance = new _ImageService(env);
    }
    return _ImageService.instance;
  }
  /**
   * Loads an image from file path
   */
  async loadImage(path, options) {
    const normalizedPath = this.normalizeSource(path);
    const cacheKey = this.generateCacheKey(normalizedPath, options);
    if (this.imageCache.has(cacheKey)) {
      return this.imageCache.get(cacheKey);
    }
    try {
      const arrayBuffer = await this.env.loader.load(normalizedPath);
      const imageInfo = await this.decodeImage(arrayBuffer, options);
      this.imageCache.set(cacheKey, imageInfo);
      return imageInfo;
    } catch (error) {
      throw new Error(`Failed to load image from ${normalizedPath}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Decodes image data from buffer
   */
  async decodeImage(buffer, options) {
    const format = this.detectImageFormat(buffer);
    switch (format) {
      case "jpeg":
        return this.jpegDecoder.decode(buffer, options);
      case "png":
        return this.pngDecoder.decode(buffer, options);
      case "gif":
        return this.decodeGif(buffer, options);
      case "webp":
        return this.decodeWebp(buffer, options);
      default:
        throw new Error(`Unsupported image format: ${format}`);
    }
  }
  /**
   * Detects image format by magic numbers
   */
  detectImageFormat(buffer) {
    const view = new DataView(buffer);
    if (buffer.byteLength >= 3 && view.getUint8(0) === 255 && view.getUint8(1) === 216 && view.getUint8(2) === 255) {
      return "jpeg";
    }
    if (buffer.byteLength >= 8 && view.getUint8(0) === 137 && view.getUint8(1) === 80 && view.getUint8(2) === 78 && view.getUint8(3) === 71 && view.getUint8(4) === 13 && view.getUint8(5) === 10 && view.getUint8(6) === 26 && view.getUint8(7) === 10) {
      return "png";
    }
    if (buffer.byteLength >= 6) {
      const gifSignature = new TextDecoder().decode(buffer.slice(0, 6));
      if (gifSignature.startsWith("GIF")) {
        return "gif";
      }
    }
    if (buffer.byteLength >= 12 && view.getUint32(0, false) === 1380533830 && // "RIFF"
    view.getUint32(8, false) === 1464156752) {
      return "webp";
    }
    throw new Error("Unknown image format");
  }
  /**
   * Placeholder GIF decoder
   */
  decodeGif(_buffer, options) {
    const width = options?.maxWidth || 100;
    const height = options?.maxHeight || 100;
    const pixelCount = width * height;
    const imageData = new ArrayBuffer(pixelCount * 4);
    return {
      width,
      height,
      format: "gif",
      channels: 4,
      bitsPerChannel: 8,
      data: imageData
    };
  }
  /**
   * WebP decoder
   */
  async decodeWebp(buffer, options) {
    return this.webpDecoder.decode(buffer, options);
  }
  /**
   * Generates a cache key for image options
   */
  generateCacheKey(path, options) {
    const optionsStr = options ? `_${options.maxWidth || 0}_${options.maxHeight || 0}_${options.scale || 1}` : "_default";
    return `${path}${optionsStr}`;
  }
  /**
   * Clears the image cache
   */
  clearCache() {
    this.imageCache.clear();
  }
  normalizeSource(source) {
    return source;
  }
};
function globalEnvironmentFallback() {
  const maybeEnv = getGlobalEnvironment();
  if (maybeEnv) return maybeEnv;
  const hasProcess = typeof process !== "undefined" && !!process.versions?.node;
  if (hasProcess) {
    return new NodeEnvironment();
  }
  throw new Error("Environment not provided to ImageService and no global __PAGYRA_ENV__ set");
}

// src/utils/base64.ts
function decodeBase64ToUint8Array(base64) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const clean = base64.replace(/[^A-Za-z0-9+/=]/g, "");
  const output = [];
  let buffer = 0;
  let bits = 0;
  for (const c of clean) {
    if (c === "=") break;
    const value = chars.indexOf(c);
    if (value === -1) continue;
    buffer = buffer << 6 | value;
    bits += 6;
    if (bits >= 8) {
      bits -= 8;
      output.push(buffer >> bits & 255);
    }
  }
  return new Uint8Array(output);
}

// src/html/image-converter.ts
function resolveImageSource(src, context) {
  const trimmed = src.trim();
  if (!trimmed) {
    return trimmed;
  }
  if (/^data:/i.test(trimmed)) {
    return trimmed;
  }
  try {
    const url = new URL(trimmed);
    if (url.protocol === "file:") {
      return url.href;
    }
    return url.href;
  } catch {
  }
  if (context.environment?.resolveLocal) {
    return context.environment.resolveLocal(trimmed, context.resourceBaseDir || context.assetRootDir || void 0);
  }
  if (trimmed.startsWith("/")) {
    const resolved = context.assetRootDir ? empty_default.resolve(context.assetRootDir, `.${trimmed}`) : trimmed;
    log("image-converter", "debug", "resolveImageSource - resolving absolute path:", { src, trimmed, assetRootDir: context.assetRootDir, resolved });
    return resolved;
  }
  if (empty_default.isAbsolute(trimmed)) {
    return trimmed;
  }
  return context.resourceBaseDir ? empty_default.resolve(context.resourceBaseDir, trimmed) : trimmed;
}
function isHttpUrl(value) {
  return /^https?:\/\//i.test(value);
}
async function convertImageElement(element, cssRules, parentStyle, context) {
  const style = computeStyleForElement(element, cssRules, parentStyle, context.units, context.rootFontSize);
  const rawSrc = element.getAttribute("href") ?? element.getAttribute("xlink:href") ?? element.getAttribute("src") ?? "";
  const srcAttr = rawSrc?.trim() ?? "";
  const widthAttr = element.getAttribute("width");
  const heightAttr = element.getAttribute("height");
  const width = widthAttr ? Number.parseFloat(widthAttr) || void 0 : void 0;
  const height = heightAttr ? Number.parseFloat(heightAttr) || void 0 : void 0;
  if (!srcAttr) {
    const placeholder = new LayoutNode(style, [], { tagName: "img" });
    placeholder.intrinsicInlineSize = width ?? 100;
    placeholder.intrinsicBlockSize = height ?? 100;
    return placeholder;
  }
  const resolvedSrc = resolveImageSource(srcAttr, context);
  let imageInfo;
  try {
    const imageService = ImageService.getInstance(context.environment);
    if (isHttpUrl(resolvedSrc)) {
      throw new Error(`Remote images are not supported (${resolvedSrc})`);
    }
    if (resolvedSrc.startsWith("data:")) {
      const match = resolvedSrc.match(/^data:image\/(.+);base64,(.+)$/);
      if (!match) {
        throw new Error("Invalid data URI");
      }
      const bytes = decodeBase64ToUint8Array(match[2]);
      const copy = bytes.slice();
      imageInfo = await imageService.decodeImage(copy.buffer, {
        maxWidth: width,
        maxHeight: height
      });
    } else {
      imageInfo = await imageService.loadImage(resolvedSrc, {
        maxWidth: width,
        maxHeight: height
      });
    }
    log("render-tree", "debug", "Image loaded successfully", {
      src: srcAttr,
      resolvedSrc,
      width: imageInfo.width,
      height: imageInfo.height,
      format: imageInfo.format
    });
  } catch (error) {
    log("render-tree", "warn", `Failed to load image: ${srcAttr}. Using placeholder.`, {
      resolvedSrc,
      error: error instanceof Error ? error.message : String(error)
    });
    const placeholder = new LayoutNode(style, [], { tagName: "img" });
    placeholder.intrinsicInlineSize = width ?? 100;
    placeholder.intrinsicBlockSize = height ?? 100;
    return placeholder;
  }
  const layoutNode = new LayoutNode(style, [], {
    tagName: "img",
    customData: {
      image: {
        originalSrc: srcAttr,
        resolvedSrc,
        info: imageInfo
      }
    }
  });
  layoutNode.intrinsicInlineSize = imageInfo.width;
  layoutNode.intrinsicBlockSize = imageInfo.height;
  ImageStrategy.processImage(layoutNode, imageInfo);
  if (width && height) {
    layoutNode.intrinsicInlineSize = width;
    layoutNode.intrinsicBlockSize = height;
  } else if (width) {
    layoutNode.intrinsicInlineSize = width;
    layoutNode.intrinsicBlockSize = Math.round(imageInfo.height / imageInfo.width * width);
  } else if (height) {
    layoutNode.intrinsicBlockSize = height;
    layoutNode.intrinsicInlineSize = Math.round(imageInfo.width / imageInfo.height * height);
  }
  return layoutNode;
}

// src/svg/parser-registry.ts
var ParserRegistry = class {
  constructor() {
    this.parsers = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a parser for a specific SVG element tag.
   * 
   * @param tagName - The element tag name (lowercase)
   * @param parser - The parser function to handle this element
   */
  register(tagName19, parser) {
    this.parsers.set(tagName19.toLowerCase(), parser);
  }
  /**
   * Parses an element using the registered parser for its tag.
   * 
   * @param element - The DOM element to parse
   * @param context - Parsing context
   * @returns Parsed SVG node or null if no parser is registered or parsing fails
   */
  parse(element, context) {
    const tag = element.tagName.toLowerCase();
    const parser = this.parsers.get(tag);
    if (!parser) {
      context.warn(`Unsupported <${tag}> element ignored.`);
      return null;
    }
    return parser(element, context);
  }
  /**
   * Checks if a parser is registered for the given tag.
   * 
   * @param tagName - The element tag name to check
   * @returns true if a parser is registered
   */
  has(tagName19) {
    return this.parsers.has(tagName19.toLowerCase());
  }
};

// src/svg/parser.ts
function parseSvg(element, options = {}) {
  const warn = options.warn ?? (() => {
  });
  if (element.tagName.toLowerCase() !== "svg") {
    warn("Expected <svg> root element.");
    return null;
  }
  const context = { warn };
  const registry = options.registry ?? defaultParserRegistry;
  const parsed = registry.parse(element, context);
  if (!parsed || parsed.type !== "svg") {
    warn("Unable to parse <svg> element.");
    return null;
  }
  return parsed;
}
function parseElement(element, context, registry) {
  const reg = registry ?? defaultParserRegistry;
  return reg.parse(element, context);
}
function parseSvgRoot(element, context) {
  const base = createContainerBase(element, "svg", context);
  if (!base) {
    return null;
  }
  const viewBox = parseViewBox(element.getAttribute("viewBox"));
  const width = parseLength4(element.getAttribute("width"));
  const height = parseLength4(element.getAttribute("height"));
  return {
    ...base,
    type: "svg",
    width,
    height,
    viewBox
  };
}
function parseGroup(element, context) {
  const base = createContainerBase(element, "g", context);
  if (!base) {
    return null;
  }
  return {
    ...base,
    type: "g"
  };
}
function parseDefs(element, context) {
  const base = createContainerBase(element, "defs", context);
  if (!base) {
    return null;
  }
  return {
    ...base,
    type: "defs"
  };
}
function parseRect(element) {
  const common = collectCommon(element, "rect");
  return {
    ...common,
    type: "rect",
    x: parseLength4(element.getAttribute("x")),
    y: parseLength4(element.getAttribute("y")),
    width: parseLength4(element.getAttribute("width")),
    height: parseLength4(element.getAttribute("height")),
    rx: parseLength4(element.getAttribute("rx")),
    ry: parseLength4(element.getAttribute("ry"))
  };
}
function parseCircle(element) {
  const common = collectCommon(element, "circle");
  return {
    ...common,
    type: "circle",
    cx: parseLength4(element.getAttribute("cx")),
    cy: parseLength4(element.getAttribute("cy")),
    r: parseLength4(element.getAttribute("r"))
  };
}
function parseEllipse(element) {
  const common = collectCommon(element, "ellipse");
  return {
    ...common,
    type: "ellipse",
    cx: parseLength4(element.getAttribute("cx")),
    cy: parseLength4(element.getAttribute("cy")),
    rx: parseLength4(element.getAttribute("rx")),
    ry: parseLength4(element.getAttribute("ry"))
  };
}
function parseLine(element) {
  const common = collectCommon(element, "line");
  return {
    ...common,
    type: "line",
    x1: parseLength4(element.getAttribute("x1")),
    y1: parseLength4(element.getAttribute("y1")),
    x2: parseLength4(element.getAttribute("x2")),
    y2: parseLength4(element.getAttribute("y2"))
  };
}
function parsePath(element) {
  const common = collectCommon(element, "path");
  return {
    ...common,
    type: "path",
    d: element.getAttribute("d") ?? void 0
  };
}
function parsePolyline(element) {
  const common = collectCommon(element, "polyline");
  return {
    ...common,
    type: "polyline",
    points: parsePointList(element.getAttribute("points"))
  };
}
function parsePolygon2(element) {
  const common = collectCommon(element, "polygon");
  return {
    ...common,
    type: "polygon",
    points: parsePointList(element.getAttribute("points"))
  };
}
function parseText(element) {
  const common = collectCommon(element, "text");
  const raw = element.textContent ?? "";
  const text = raw.replace(/\s+/g, " ").trim();
  if (!text) {
    return null;
  }
  return {
    ...common,
    type: "text",
    text,
    x: parseLength4(element.getAttribute("x")),
    y: parseLength4(element.getAttribute("y")),
    fontSize: parseLength4(element.getAttribute("font-size")),
    fontFamily: element.getAttribute("font-family") ?? void 0,
    textAnchor: normalizeTextAnchor(element.getAttribute("text-anchor"))
  };
}
function normalizeTextAnchor(anchor) {
  if (!anchor) {
    return void 0;
  }
  const lower = anchor.trim().toLowerCase();
  if (lower === "start" || lower === "middle" || lower === "end") {
    return lower;
  }
  return void 0;
}
function createContainerBase(element, type, context) {
  const common = collectCommon(element, type);
  const children = [];
  for (const child of Array.from(element.children)) {
    const parsed = parseElement(child, context);
    if (parsed) {
      children.push(parsed);
    }
  }
  return {
    ...common,
    type,
    children
  };
}
function collectCommon(element, type) {
  const attributes2 = {};
  if (typeof element.getAttributeNames === "function") {
    for (const name of element.getAttributeNames()) {
      const value = element.getAttribute(name);
      if (value !== null) {
        attributes2[name] = value;
      }
    }
  } else {
    const rawAttrs = element.attributes ?? [];
    for (const attr of Array.from(rawAttrs)) {
      const value = attr.value;
      if (value !== null) {
        attributes2[attr.name] = value;
      }
    }
  }
  const classAttr = element.getAttribute("class");
  const classes = classAttr ? classAttr.split(/\s+/).filter(Boolean) : [];
  const transform = element.getAttribute("transform") ?? void 0;
  const transformMatrix = transform ? parseTransform(transform) || void 0 : void 0;
  return {
    type,
    id: element.getAttribute("id") ?? void 0,
    classes,
    attributes: attributes2,
    transform,
    transformMatrix
  };
}
function parseLength4(raw) {
  if (!raw) {
    return void 0;
  }
  const trimmed = raw.trim();
  if (trimmed.length === 0) {
    return void 0;
  }
  const match = trimmed.match(/^(-?\d+(\.\d+)?)([a-z%]*)$/i);
  if (!match) {
    return void 0;
  }
  const value = Number.parseFloat(match[1]);
  if (!Number.isFinite(value)) {
    return void 0;
  }
  const unit = match[3] ?? "";
  if (unit && unit !== "px") {
    return void 0;
  }
  return value;
}
function parseViewBox(raw) {
  if (!raw) {
    return void 0;
  }
  const tokens = raw.trim().split(/[\s,]+/).map((chunk) => Number.parseFloat(chunk));
  if (tokens.length !== 4 || tokens.some((value) => !Number.isFinite(value))) {
    return void 0;
  }
  return {
    minX: tokens[0],
    minY: tokens[1],
    width: tokens[2],
    height: tokens[3]
  };
}
function parseImage(element) {
  const common = collectCommon(element, "image");
  return {
    ...common,
    type: "image",
    x: parseLength4(element.getAttribute("x")),
    y: parseLength4(element.getAttribute("y")),
    width: parseLength4(element.getAttribute("width")),
    height: parseLength4(element.getAttribute("height")),
    href: element.getAttribute("href") || element.getAttribute("xlink:href") || void 0,
    preserveAspectRatio: element.getAttribute("preserveAspectRatio") || void 0
  };
}
function parseUse(element) {
  const common = collectCommon(element, "use");
  return {
    ...common,
    type: "use",
    x: parseLength4(element.getAttribute("x")),
    y: parseLength4(element.getAttribute("y")),
    width: parseLength4(element.getAttribute("width")),
    height: parseLength4(element.getAttribute("height")),
    href: element.getAttribute("href") || element.getAttribute("xlink:href") || void 0
  };
}
function parseClipPath2(element, context) {
  const base = createContainerBase(element, "clippath", context);
  if (!base) {
    return null;
  }
  const clipPathUnits = element.getAttribute("clipPathUnits");
  return {
    ...base,
    type: "clippath",
    clipPathUnits: clipPathUnits === "objectBoundingBox" ? "objectBoundingBox" : "userSpaceOnUse"
  };
}
function parseLinearGradient2(element, context) {
  const common = collectCommon(element, "lineargradient");
  const stops = parseGradientStops(element, context);
  return {
    ...common,
    type: "lineargradient",
    x1: parseLength4(element.getAttribute("x1")) ?? 0,
    y1: parseLength4(element.getAttribute("y1")) ?? 0,
    x2: parseLength4(element.getAttribute("x2")) ?? 1,
    y2: parseLength4(element.getAttribute("y2")) ?? 0,
    gradientUnits: element.getAttribute("gradientUnits") === "userSpaceOnUse" ? "userSpaceOnUse" : "objectBoundingBox",
    spreadMethod: normalizeSpreadMethod(element.getAttribute("spreadMethod")),
    stops
  };
}
function parseRadialGradient2(element, context) {
  const common = collectCommon(element, "radialgradient");
  const stops = parseGradientStops(element, context);
  return {
    ...common,
    type: "radialgradient",
    cx: parseLength4(element.getAttribute("cx")) ?? 0.5,
    cy: parseLength4(element.getAttribute("cy")) ?? 0.5,
    r: parseLength4(element.getAttribute("r")) ?? 0.5,
    fx: parseLength4(element.getAttribute("fx")),
    fy: parseLength4(element.getAttribute("fy")),
    gradientUnits: element.getAttribute("gradientUnits") === "userSpaceOnUse" ? "userSpaceOnUse" : "objectBoundingBox",
    spreadMethod: normalizeSpreadMethod(element.getAttribute("spreadMethod")),
    stops
  };
}
function parseGradientStops(element, _context) {
  const stops = [];
  for (const child of Array.from(element.children)) {
    if (child.tagName.toLowerCase() === "stop") {
      const offset = parseGradientOffset(child.getAttribute("offset"));
      const color = child.getAttribute("stop-color") || "#000000";
      const opacity = parseOpacity2(child.getAttribute("stop-opacity"));
      if (offset !== void 0) {
        stops.push({ offset, color, opacity });
      }
    }
  }
  return stops;
}
function parseGradientOffset(raw) {
  if (!raw) {
    return void 0;
  }
  const trimmed = raw.trim();
  if (trimmed.endsWith("%")) {
    const value2 = Number.parseFloat(trimmed.slice(0, -1));
    return Number.isFinite(value2) ? value2 / 100 : void 0;
  }
  const value = Number.parseFloat(trimmed);
  return Number.isFinite(value) ? value : void 0;
}
function parseOpacity2(raw) {
  if (!raw) {
    return void 0;
  }
  const value = Number.parseFloat(raw.trim());
  return Number.isFinite(value) && value >= 0 && value <= 1 ? value : void 0;
}
function normalizeSpreadMethod(method) {
  if (!method) {
    return void 0;
  }
  const lower = method.trim().toLowerCase();
  if (lower === "pad" || lower === "reflect" || lower === "repeat") {
    return lower;
  }
  return void 0;
}
function parsePointList(raw) {
  if (!raw) {
    return void 0;
  }
  const trimmed = raw.trim();
  if (!trimmed) {
    return void 0;
  }
  const numbers = [];
  for (const token of trimmed.split(/[\s,]+/)) {
    if (!token) {
      continue;
    }
    const value = Number.parseFloat(token);
    if (!Number.isFinite(value)) {
      return void 0;
    }
    numbers.push(value);
  }
  if (numbers.length % 2 !== 0) {
    return void 0;
  }
  const points = [];
  for (let i = 0; i < numbers.length; i += 2) {
    points.push({ x: numbers[i], y: numbers[i + 1] });
  }
  return points;
}
var defaultParserRegistry = new ParserRegistry();
defaultParserRegistry.register("svg", parseSvgRoot);
defaultParserRegistry.register("g", parseGroup);
defaultParserRegistry.register("defs", parseDefs);
defaultParserRegistry.register("rect", parseRect);
defaultParserRegistry.register("circle", parseCircle);
defaultParserRegistry.register("ellipse", parseEllipse);
defaultParserRegistry.register("line", parseLine);
defaultParserRegistry.register("path", parsePath);
defaultParserRegistry.register("polyline", parsePolyline);
defaultParserRegistry.register("polygon", parsePolygon2);
defaultParserRegistry.register("text", parseText);
defaultParserRegistry.register("image", parseImage);
defaultParserRegistry.register("use", parseUse);
defaultParserRegistry.register("clippath", parseClipPath2);
defaultParserRegistry.register("lineargradient", parseLinearGradient2);
defaultParserRegistry.register("radialgradient", parseRadialGradient2);

// src/html/dom-converter.ts
function findMeaningfulSibling(start, direction) {
  let current2 = start;
  const getNext = direction === "previous" ? (node) => node.previousSibling : (node) => node.nextSibling;
  while (current2) {
    if (current2.nodeType === current2.TEXT_NODE) {
      const content = current2.textContent ?? "";
      if (content.replace(/\s+/g, "").length > 0) {
        return current2;
      }
    } else if (current2.nodeType === current2.ELEMENT_NODE) {
      const tagName19 = current2.tagName.toLowerCase();
      if (!["script", "style", "meta", "link"].includes(tagName19)) {
        return current2;
      }
    }
    current2 = getNext(current2);
  }
  return null;
}
function hasMeaningfulPreviousSibling(node) {
  return findMeaningfulSibling(node.previousSibling, "previous") !== null;
}
function hasMeaningfulNextSibling(node) {
  return findMeaningfulSibling(node.nextSibling, "next") !== null;
}
function isInlineDisplay5(display) {
  return display === "inline" /* Inline */ || display === "inline-block" /* InlineBlock */ || display === "inline-flex" /* InlineFlex */ || display === "inline-grid" /* InlineGrid */ || display === "inline-table" /* InlineTable */;
}
function shouldPreserveCollapsedWhitespace(children, style) {
  if (style.whiteSpace === "pre" /* Pre */ || style.whiteSpace === "pre-wrap" /* PreWrap */) {
    return true;
  }
  const lastChild = children.length > 0 ? children[children.length - 1] : null;
  return !!lastChild && isInlineDisplay5(lastChild.style.display);
}
function extractCssUrl(raw) {
  const trimmed = raw.trim();
  if (!trimmed) {
    return "";
  }
  if (trimmed.startsWith("url(") && trimmed.endsWith(")")) {
    let inner = trimmed.slice(4, -1).trim();
    if (inner.startsWith("'") && inner.endsWith("'") || inner.startsWith('"') && inner.endsWith('"')) {
      inner = inner.slice(1, -1);
    }
    return inner;
  }
  if (trimmed.startsWith("'") && trimmed.endsWith("'") || trimmed.startsWith('"') && trimmed.endsWith('"')) {
    return trimmed.slice(1, -1);
  }
  return trimmed;
}
function isDataUri(value) {
  return /^data:/i.test(value);
}
function isHttpUrl2(value) {
  return /^https?:\/\//i.test(value);
}
function parseSpan(raw) {
  if (!raw) return void 0;
  const parsed = Number.parseInt(raw, 10);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : void 0;
}
async function loadBackgroundImage(cssUrl, context) {
  const imageService = ImageService.getInstance(context.environment);
  const resolvedSrc = resolveImageSource(cssUrl, context);
  if (isHttpUrl2(resolvedSrc)) {
    log("dom-converter", "warn", `Skipping remote background image (${resolvedSrc}); remote assets are not supported.`);
    return null;
  }
  try {
    let imageInfo;
    if (isDataUri(resolvedSrc)) {
      const match = resolvedSrc.match(/^data:image\/(.+);base64,(.+)$/);
      if (!match) {
        log("dom-converter", "warn", `Unsupported data URI format for background image: ${cssUrl}`);
        return null;
      }
      const bytes = decodeBase64ToUint8Array(match[2]);
      const copy = bytes.slice();
      imageInfo = await imageService.decodeImage(copy.buffer);
    } else {
      imageInfo = await imageService.loadImage(resolvedSrc);
    }
    return { info: imageInfo, resolvedSrc };
  } catch (error) {
    log("dom-converter", "warn", `Failed to load background image ${cssUrl}:`, error instanceof Error ? error.message : String(error));
    return null;
  }
}
async function hydrateBackgroundImages(style, context) {
  if (!style.backgroundLayers || style.backgroundLayers.length === 0) {
    return;
  }
  for (const layer of style.backgroundLayers) {
    if (layer.kind !== "image") {
      continue;
    }
    if (layer.imageInfo) {
      continue;
    }
    const cssUrl = extractCssUrl(layer.url);
    if (!cssUrl) {
      continue;
    }
    const loaded = await loadBackgroundImage(cssUrl, context);
    if (!loaded) {
      continue;
    }
    layer.originalUrl = cssUrl;
    layer.resolvedUrl = loaded.resolvedSrc;
    layer.imageInfo = loaded.info;
  }
}
async function convertDomNode(node, cssRules, parentStyle, context) {
  log("dom-converter", "debug", `convertDomNode - entering function for node type: ${node.nodeType}, tagName: ${node.tagName || "text node"}`);
  if (node.nodeType === node.TEXT_NODE) {
    const raw = node.textContent ?? "";
    const collapsed = raw.replace(/\s+/g, " ").normalize("NFC");
    const trimmed = collapsed.trim();
    const hasPrev = hasMeaningfulPreviousSibling(node);
    const hasNext = hasMeaningfulNextSibling(node);
    if (trimmed.length === 0) {
      const keepSpace = hasPrev && hasNext;
      if (!keepSpace) {
        return null;
      }
      log("dom-converter", "debug", "convertDomNode - processing text node: (single space)");
      const textStyle2 = new ComputedStyle({
        display: "inline" /* Inline */,
        color: parentStyle.color,
        fontSize: parentStyle.fontSize,
        lineHeight: cloneLineHeight(parentStyle.lineHeight),
        fontFamily: parentStyle.fontFamily,
        fontWeight: parentStyle.fontWeight,
        fontStyle: parentStyle.fontStyle,
        letterSpacing: parentStyle.letterSpacing,
        wordSpacing: parentStyle.wordSpacing,
        textDecorationLine: parentStyle.textDecorationLine,
        textDecorationColor: parentStyle.textDecorationColor,
        textDecorationStyle: parentStyle.textDecorationStyle,
        textTransform: parentStyle.textTransform,
        transform: parentStyle.transform,
        textShadows: parentStyle.textShadows
      });
      return new LayoutNode(textStyle2, [], {
        textContent: " ",
        customData: {
          preserveLeadingSpace: true,
          preserveTrailingSpace: true
        }
      });
    }
    let text = trimmed;
    const preserveLeading = collapsed.startsWith(" ") && hasPrev;
    const preserveTrailing = collapsed.endsWith(" ") && hasNext;
    if (preserveLeading) {
      text = " " + text;
    }
    if (preserveTrailing) {
      text = text + " ";
    }
    log("dom-converter", "debug", "convertDomNode - processing text node:", text.substring(0, 50) + (text.length > 50 ? "..." : ""));
    const textStyle = new ComputedStyle({
      display: "inline" /* Inline */,
      color: parentStyle.color,
      fontSize: parentStyle.fontSize,
      lineHeight: cloneLineHeight(parentStyle.lineHeight),
      fontFamily: parentStyle.fontFamily,
      fontWeight: parentStyle.fontWeight,
      fontStyle: parentStyle.fontStyle,
      letterSpacing: parentStyle.letterSpacing,
      wordSpacing: parentStyle.wordSpacing,
      textDecorationLine: parentStyle.textDecorationLine,
      textDecorationColor: parentStyle.textDecorationColor,
      textDecorationStyle: parentStyle.textDecorationStyle,
      textTransform: parentStyle.textTransform,
      transform: parentStyle.transform,
      textShadows: parentStyle.textShadows
    });
    return new LayoutNode(textStyle, [], {
      textContent: text,
      customData: {
        preserveLeadingSpace: preserveLeading,
        preserveTrailingSpace: preserveTrailing
      }
    });
  }
  if (node.nodeType !== node.ELEMENT_NODE) return null;
  const element = node;
  const tagName19 = element.tagName.toLowerCase();
  log("dom-converter", "debug", `convertDomNode - processing element: ${tagName19}, with style attr: ${element.getAttribute("style")}`);
  if (tagName19 === "script" || tagName19 === "style") return null;
  if (tagName19 === "img") {
    return await convertImageElement(element, cssRules, parentStyle, context);
  }
  if (tagName19 === "svg") {
    const ownStyle2 = computeStyleForElement(element, cssRules, parentStyle, context.units, context.rootFontSize);
    log("dom-converter", "debug", "convertDomNode - computed style backgroundLayers:", ownStyle2.backgroundLayers);
    const svgRoot = parseSvg(element, { warn: (message) => log("svg-parser", "warn", message) });
    if (!svgRoot) {
      return new LayoutNode(ownStyle2, [], { tagName: tagName19 });
    }
    const intrinsic = resolveSvgIntrinsicSize(svgRoot, element);
    return new LayoutNode(ownStyle2, [], {
      tagName: tagName19,
      intrinsicInlineSize: intrinsic.width,
      intrinsicBlockSize: intrinsic.height,
      customData: {
        svg: {
          root: svgRoot,
          intrinsicWidth: intrinsic.width,
          intrinsicHeight: intrinsic.height,
          // Propagate resource roots so SVG rendering can resolve image hrefs
          resourceBaseDir: context && context.resourceBaseDir,
          assetRootDir: context && context.assetRootDir
        }
      }
    });
  }
  if (tagName19 === "br") {
    const textStyle = new ComputedStyle({
      display: "inline" /* Inline */,
      color: parentStyle.color,
      fontSize: parentStyle.fontSize,
      lineHeight: cloneLineHeight(parentStyle.lineHeight),
      fontFamily: parentStyle.fontFamily,
      fontWeight: parentStyle.fontWeight,
      fontStyle: parentStyle.fontStyle,
      textTransform: parentStyle.textTransform
    });
    return new LayoutNode(textStyle, [], { textContent: "\n" });
  }
  const ownStyle = computeStyleForElement(element, cssRules, parentStyle, context.units, context.rootFontSize);
  await hydrateBackgroundImages(ownStyle, context);
  log("dom-converter", "debug", "convertDomNode - computed style backgroundLayers:", ownStyle.backgroundLayers);
  if (element.tagName.toLowerCase() === "div" && element.getAttribute("style")?.includes("linear-gradient")) {
    log("dom-converter", "debug", "Found div with gradient style!");
  }
  const layoutChildren = [];
  let textBuf = "";
  for (const child of Array.from(element.childNodes)) {
    if (child.nodeType === child.TEXT_NODE) {
      textBuf += child.textContent ?? "";
      continue;
    }
    if (textBuf) {
      let normalized = textBuf.replace(/\s+/g, " ").normalize("NFC");
      if (normalized.trim().length === 0) {
        normalized = shouldPreserveCollapsedWhitespace(layoutChildren, ownStyle) ? " " : "";
      }
      if (normalized) {
        const preserveLeading = normalized.startsWith(" ");
        const preserveTrailing = normalized.endsWith(" ");
        layoutChildren.push(new LayoutNode(new ComputedStyle({
          display: "inline" /* Inline */,
          color: ownStyle.color,
          fontSize: ownStyle.fontSize,
          lineHeight: cloneLineHeight(ownStyle.lineHeight),
          fontFamily: ownStyle.fontFamily,
          fontWeight: ownStyle.fontWeight,
          fontStyle: ownStyle.fontStyle,
          letterSpacing: ownStyle.letterSpacing,
          wordSpacing: ownStyle.wordSpacing,
          overflowWrap: ownStyle.overflowWrap,
          whiteSpace: ownStyle.whiteSpace,
          textDecorationLine: ownStyle.textDecorationLine,
          textDecorationColor: ownStyle.textDecorationColor,
          textDecorationStyle: ownStyle.textDecorationStyle,
          textTransform: ownStyle.textTransform,
          transform: ownStyle.transform,
          textShadows: ownStyle.textShadows
        }), [], {
          textContent: normalized,
          customData: {
            preserveLeadingSpace: preserveLeading,
            preserveTrailingSpace: preserveTrailing
          }
        }));
      }
      textBuf = "";
    }
    const sub = await convertDomNode(child, cssRules, ownStyle, context);
    if (sub) layoutChildren.push(sub);
  }
  if (textBuf) {
    let normalized = textBuf.replace(/\s+/g, " ").normalize("NFC");
    if (normalized.trim().length === 0) {
      normalized = shouldPreserveCollapsedWhitespace(layoutChildren, ownStyle) ? " " : "";
    }
    if (normalized) {
      const preserveLeading = normalized.startsWith(" ");
      const preserveTrailing = normalized.endsWith(" ");
      layoutChildren.push(new LayoutNode(new ComputedStyle({
        display: "inline" /* Inline */,
        color: ownStyle.color,
        fontSize: ownStyle.fontSize,
        lineHeight: cloneLineHeight(ownStyle.lineHeight),
        fontFamily: ownStyle.fontFamily,
        fontWeight: ownStyle.fontWeight,
        fontStyle: ownStyle.fontStyle,
        letterSpacing: ownStyle.letterSpacing,
        wordSpacing: ownStyle.wordSpacing,
        overflowWrap: ownStyle.overflowWrap,
        whiteSpace: ownStyle.whiteSpace,
        textDecorationLine: ownStyle.textDecorationLine,
        textDecorationColor: ownStyle.textDecorationColor,
        textDecorationStyle: ownStyle.textDecorationStyle,
        textTransform: ownStyle.textTransform,
        transform: ownStyle.transform,
        textShadows: ownStyle.textShadows
      }), [], {
        textContent: normalized,
        customData: {
          preserveLeadingSpace: preserveLeading,
          preserveTrailingSpace: preserveTrailing
        }
      }));
    }
  }
  const id = element.getAttribute("id");
  const options = { tagName: tagName19 };
  if (tagName19 === "td" || tagName19 === "th") {
    options.tableColSpan = parseSpan(element.getAttribute("colspan")) ?? 1;
    options.tableRowSpan = parseSpan(element.getAttribute("rowspan")) ?? 1;
  }
  if (id) {
    options.customData = { ...options.customData, id };
  }
  return new LayoutNode(ownStyle, layoutChildren, options);
}
function resolveSvgIntrinsicSize(svg, element) {
  let width = svg.width;
  let height = svg.height;
  if (svg.viewBox) {
    if (!width || width <= 0) {
      width = svg.viewBox.width;
    }
    if (!height || height <= 0) {
      height = svg.viewBox.height;
    }
  }
  if (!width || width <= 0) {
    width = attributeToNumber(element.getAttribute("width")) ?? 100;
  }
  if (!height || height <= 0) {
    height = attributeToNumber(element.getAttribute("height")) ?? width;
  }
  return {
    width: Number.isFinite(width) && width > 0 ? width : 100,
    height: Number.isFinite(height) && height > 0 ? height : 100
  };
}
function attributeToNumber(raw) {
  if (!raw) {
    return void 0;
  }
  const value = Number.parseFloat(raw);
  return Number.isFinite(value) ? value : void 0;
}

// src/render/offset.ts
function offsetRect(rect, dx, dy) {
  if (!rect) return;
  rect.x += dx;
  rect.y += dy;
}
function offsetBackground(background, dx, dy) {
  if (!background) {
    return;
  }
  if (background.image) {
    offsetRect(background.image.rect, dx, dy);
    offsetRect(background.image.originRect, dx, dy);
  }
  if (background.gradient) {
    offsetRect(background.gradient.rect, dx, dy);
    offsetRect(background.gradient.originRect, dx, dy);
  }
}
function offsetRenderTree(root, dx, dy, _debug) {
  const stack = [root];
  while (stack.length > 0) {
    const box = stack.pop();
    log("layout", "trace", "offset render tree box", {
      tagName: box.tagName,
      textContent: box.textContent,
      x: box.contentBox.x,
      y: box.contentBox.y,
      width: box.contentBox.width,
      height: box.contentBox.height
    });
    offsetRect(box.contentBox, dx, dy);
    offsetRect(box.paddingBox, dx, dy);
    offsetRect(box.borderBox, dx, dy);
    offsetRect(box.visualOverflow, dx, dy);
    if (box.clipPath && box.clipPath.points) {
      for (const point of box.clipPath.points) {
        point.x += dx;
        point.y += dy;
      }
    }
    if (box.markerRect) {
      offsetRect(box.markerRect, dx, dy);
    }
    offsetBackground(box.background, dx, dy);
    for (const link of box.links) {
      offsetRect(link.rect, dx, dy);
    }
    for (const run of box.textRuns) {
      if (run.lineMatrix) {
        run.lineMatrix.e += dx;
        run.lineMatrix.f += dy;
      }
    }
    for (const child of box.children) {
      stack.push(child);
    }
  }
}
function applyPageVerticalMarginsWithHf(root, options) {
  const { pageHeight, margins, headerHeightPx = 0, footerHeightPx = 0 } = options;
  const safePageHeight = Number.isFinite(pageHeight) && pageHeight > 0 ? pageHeight : 1;
  const marginTop = Number.isFinite(margins.top) && margins.top > 0 ? margins.top : 0;
  const marginBottom = Number.isFinite(margins.bottom) && margins.bottom > 0 ? margins.bottom : 0;
  const effectiveTop = marginTop + headerHeightPx;
  const effectiveBottom = marginBottom + footerHeightPx;
  const totalReserved = effectiveTop + effectiveBottom;
  const usableHeight = safePageHeight - totalReserved > 0 ? safePageHeight - totalReserved : safePageHeight;
  const mapY = (value) => {
    if (!Number.isFinite(value)) {
      return value;
    }
    if (value <= 0) {
      return value + effectiveTop;
    }
    const pageIndex = Math.floor(value / usableHeight);
    const remainder = value - pageIndex * usableHeight;
    return pageIndex * safePageHeight + effectiveTop + remainder;
  };
  const adjustRect = (rect) => {
    if (!rect) {
      return;
    }
    rect.y = mapY(rect.y);
  };
  const adjustBackground = (background) => {
    if (!background) {
      return;
    }
    if (background.image) {
      adjustRect(background.image.rect);
      adjustRect(background.image.originRect);
    }
    if (background.gradient) {
      adjustRect(background.gradient.rect);
      adjustRect(background.gradient.originRect);
    }
  };
  const stack = [root];
  while (stack.length > 0) {
    const box = stack.pop();
    adjustRect(box.contentBox);
    adjustRect(box.paddingBox);
    adjustRect(box.borderBox);
    adjustRect(box.visualOverflow);
    if (box.clipPath && box.clipPath.points) {
      for (const point of box.clipPath.points) {
        point.y = mapY(point.y);
      }
    }
    if (box.markerRect) {
      adjustRect(box.markerRect);
    }
    adjustBackground(box.background);
    for (const link of box.links) {
      adjustRect(link.rect);
    }
    for (const run of box.textRuns) {
      if (run.lineMatrix) {
        run.lineMatrix.f = mapY(run.lineMatrix.f);
      }
    }
    for (const child of box.children) {
      stack.push(child);
    }
  }
}

// src/fonts/font-registry-resolver.ts
var FontRegistryResolver = class {
  constructor(fontRegistry) {
    this.fontRegistry = fontRegistry;
    this.rawTableAccessors = /* @__PURE__ */ new WeakMap();
  }
  async resolve(family, weight, style) {
    const fontResource = await this.fontRegistry.ensureFontResource(family, weight, style);
    return this.toUnifiedFont(fontResource, family, weight, style) ?? this.createFallbackFont(family, weight, style);
  }
  resolveSync(family, weight, style) {
    const fontResource = this.fontRegistry.ensureFontResourceSync(family, weight, style);
    return this.toUnifiedFont(fontResource, family, weight, style);
  }
  createFallbackFont(family, weight, style) {
    return {
      metrics: {
        metrics: {
          unitsPerEm: 1e3,
          ascender: 800,
          descender: -200,
          lineGap: 0,
          capHeight: 700,
          xHeight: 500
        },
        glyphMetrics: /* @__PURE__ */ new Map([
          [0, { advanceWidth: 500, leftSideBearing: 0 }]
        ]),
        cmap: {
          getGlyphId: () => 0,
          hasCodePoint: () => false,
          unicodeMap: /* @__PURE__ */ new Map()
        }
      },
      program: {
        sourceFormat: "ttf",
        unitsPerEm: 1e3,
        glyphCount: 1
      },
      css: {
        family,
        weight: weight ?? 400,
        style: style ?? "normal"
      }
    };
  }
  toUnifiedFont(fontResource, family, weight, style) {
    const metrics = fontResource.metrics;
    if (!metrics) return void 0;
    const getRawTableData = this.lookupRawTableAccessor(fontResource);
    return {
      metrics: {
        metrics: metrics.metrics,
        glyphMetrics: metrics.glyphMetrics,
        cmap: metrics.cmap,
        headBBox: metrics.headBBox,
        kerning: metrics.kerning
      },
      program: {
        sourceFormat: "ttf",
        unitsPerEm: metrics.metrics.unitsPerEm,
        glyphCount: metrics.glyphMetrics.size,
        getGlyphOutline: metrics.getGlyphOutline,
        getRawTableData
      },
      css: {
        family,
        weight: weight ?? 400,
        style: style ?? "normal"
      }
    };
  }
  lookupRawTableAccessor(fontResource) {
    const rawBytes = fontResource.embedded?.subset;
    if (!rawBytes || rawBytes.byteLength < 12) {
      return void 0;
    }
    const cached = this.rawTableAccessors.get(fontResource);
    if (cached) return cached;
    const accessor = createRawTableAccessor(rawBytes);
    this.rawTableAccessors.set(fontResource, accessor);
    return accessor;
  }
};
function createRawTableAccessor(ttfBytes) {
  const directory = parseTtfTableDirectory(ttfBytes);
  return (tag) => directory.get(tag) ?? null;
}
function parseTtfTableDirectory(ttfBytes) {
  const tables = /* @__PURE__ */ new Map();
  if (ttfBytes.byteLength < 12) return tables;
  const view = new DataView(ttfBytes.buffer, ttfBytes.byteOffset, ttfBytes.byteLength);
  const numTables = view.getUint16(4, false);
  for (let i = 0; i < numTables; i++) {
    const entryOffset = 12 + i * 16;
    if (entryOffset + 16 > ttfBytes.byteLength) break;
    const tag = String.fromCharCode(
      ttfBytes[entryOffset],
      ttfBytes[entryOffset + 1],
      ttfBytes[entryOffset + 2],
      ttfBytes[entryOffset + 3]
    );
    const offset = view.getUint32(entryOffset + 8, false);
    const length = view.getUint32(entryOffset + 12, false);
    if (offset + length > ttfBytes.byteLength) continue;
    tables.set(tag, ttfBytes.subarray(offset, offset + length));
  }
  return tables;
}

// src/pdf/utils/drop-shadow-raster.ts
function clampUnit2(value) {
  if (!Number.isFinite(value)) return 0;
  if (value <= 0) return 0;
  if (value >= 1) return 1;
  return value;
}
function ceilPositive(value) {
  if (!Number.isFinite(value) || value <= 0) return 0;
  return Math.ceil(value);
}
function inflateRect(rect, amount) {
  const width = rect.width + amount * 2;
  const height = rect.height + amount * 2;
  if (width <= 0 || height <= 0) {
    return { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2, width: 0, height: 0 };
  }
  return { x: rect.x - amount, y: rect.y - amount, width, height };
}
function max2(a, b) {
  return a > b ? a : b;
}
function pointInRoundedRect(px, py, rect, radius) {
  if (px < rect.x || py < rect.y || px > rect.x + rect.width || py > rect.y + rect.height) {
    return false;
  }
  const leftMargin = max2(radius.topLeft.x, radius.bottomLeft.x);
  const rightMargin = max2(radius.topRight.x, radius.bottomRight.x);
  const topMargin = max2(radius.topLeft.y, radius.topRight.y);
  const bottomMargin = max2(radius.bottomLeft.y, radius.bottomRight.y);
  if (px >= rect.x + leftMargin && px <= rect.x + rect.width - rightMargin) return true;
  if (py >= rect.y + topMargin && py <= rect.y + rect.height - bottomMargin) return true;
  if (px < rect.x + radius.topLeft.x && py < rect.y + radius.topLeft.y && radius.topLeft.x > 0 && radius.topLeft.y > 0) {
    const cx = rect.x + radius.topLeft.x;
    const cy = rect.y + radius.topLeft.y;
    const dx = (px - cx) / radius.topLeft.x;
    const dy = (py - cy) / radius.topLeft.y;
    return dx * dx + dy * dy <= 1;
  }
  if (px > rect.x + rect.width - radius.topRight.x && py < rect.y + radius.topRight.y && radius.topRight.x > 0 && radius.topRight.y > 0) {
    const cx = rect.x + rect.width - radius.topRight.x;
    const cy = rect.y + radius.topRight.y;
    const dx = (px - cx) / radius.topRight.x;
    const dy = (py - cy) / radius.topRight.y;
    return dx * dx + dy * dy <= 1;
  }
  if (px > rect.x + rect.width - radius.bottomRight.x && py > rect.y + rect.height - radius.bottomRight.y && radius.bottomRight.x > 0 && radius.bottomRight.y > 0) {
    const cx = rect.x + rect.width - radius.bottomRight.x;
    const cy = rect.y + rect.height - radius.bottomRight.y;
    const dx = (px - cx) / radius.bottomRight.x;
    const dy = (py - cy) / radius.bottomRight.y;
    return dx * dx + dy * dy <= 1;
  }
  if (px < rect.x + radius.bottomLeft.x && py > rect.y + rect.height - radius.bottomLeft.y && radius.bottomLeft.x > 0 && radius.bottomLeft.y > 0) {
    const cx = rect.x + radius.bottomLeft.x;
    const cy = rect.y + rect.height - radius.bottomLeft.y;
    const dx = (px - cx) / radius.bottomLeft.x;
    const dy = (py - cy) / radius.bottomLeft.y;
    return dx * dx + dy * dy <= 1;
  }
  return false;
}
function buildGaussianKernel(sigma) {
  const s = sigma > 0 ? sigma : 1e-4;
  const radius = Math.max(1, Math.ceil(s * 3));
  const size = radius * 2 + 1;
  const kernel = new Float32Array(size);
  const coeff = 1 / (Math.sqrt(2 * Math.PI) * s);
  const twoSigmaSq = 2 * s * s;
  let sum = 0;
  for (let i = -radius; i <= radius; i++) {
    const w = coeff * Math.exp(-(i * i) / twoSigmaSq);
    kernel[i + radius] = w;
    sum += w;
  }
  return { kernel, radius, sum };
}
function blurAlpha(alpha, width, height, sigma) {
  if (sigma <= 0) return alpha;
  const { kernel, radius, sum } = buildGaussianKernel(sigma);
  const tmp = new Float32Array(width * height);
  for (let y = 0; y < height; y++) {
    const rowOffset = y * width;
    for (let x = 0; x < width; x++) {
      let acc = 0;
      let wsum = 0;
      for (let k = -radius; k <= radius; k++) {
        const xi = Math.min(width - 1, Math.max(0, x + k));
        const w = kernel[k + radius];
        acc += alpha[rowOffset + xi] * w;
        wsum += w;
      }
      tmp[rowOffset + x] = acc / (wsum || sum);
    }
  }
  const out = new Uint8Array(width * height);
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let acc = 0;
      let wsum = 0;
      for (let k = -radius; k <= radius; k++) {
        const yi = Math.min(height - 1, Math.max(0, y + k));
        const w = kernel[k + radius];
        acc += tmp[yi * width + x] * w;
        wsum += w;
      }
      const v = acc / (wsum || sum);
      out[y * width + x] = v < 0 ? 0 : v > 255 ? 255 : v;
    }
  }
  return out;
}
function rasterizeDropShadowForRect(baseRect, baseRadius, color, blur, spread) {
  const blurPx = Math.max(0, blur);
  const shapeRect = inflateRect(baseRect, spread);
  const shapeRadius = adjustRadius(baseRadius, spread);
  const outRect = inflateRect(shapeRect, blurPx);
  const width = ceilPositive(outRect.width);
  const height = ceilPositive(outRect.height);
  if (width === 0 || height === 0) {
    return null;
  }
  const alpha = new Uint8Array(width * height);
  const shapeLocal = { x: shapeRect.x - outRect.x, y: shapeRect.y - outRect.y, width: shapeRect.width, height: shapeRect.height };
  for (let y = 0; y < height; y++) {
    const py = y + 0.5;
    for (let x = 0; x < width; x++) {
      const px = x + 0.5;
      const inside = pointInRoundedRect(px, py, shapeLocal, shapeRadius);
      alpha[y * width + x] = inside ? 255 : 0;
    }
  }
  const sigma = blurPx > 0 ? Math.max(0.5, blurPx / 2) : 0;
  const blurred = blurAlpha(alpha, width, height, sigma);
  const [r, g, b] = compensateSrgbColor(color.r, color.g, color.b);
  const aMul = clampUnit2(color.a ?? 1);
  const data = new Uint8Array(width * height * 4);
  let di = 0;
  for (let i = 0; i < blurred.length; i++) {
    data[di++] = r;
    data[di++] = g;
    data[di++] = b;
    const a = Math.round(blurred[i] * aMul);
    data[di++] = a < 0 ? 0 : a > 255 ? 255 : a;
  }
  const image = {
    src: `internal:shadow:${Math.random().toString(36).slice(2)}`,
    width,
    height,
    format: "png",
    channels: 4,
    bitsPerComponent: 8,
    data: data.buffer
  };
  return { image, drawRect: outRect };
}
function adjustRadius(radius, delta) {
  const clampNN = (v) => Number.isFinite(v) && v > 0 ? v : 0;
  return {
    topLeft: { x: clampNN(radius.topLeft.x + delta), y: clampNN(radius.topLeft.y + delta) },
    topRight: { x: clampNN(radius.topRight.x + delta), y: clampNN(radius.topRight.y + delta) },
    bottomRight: { x: clampNN(radius.bottomRight.x + delta), y: clampNN(radius.bottomRight.y + delta) },
    bottomLeft: { x: clampNN(radius.bottomLeft.x + delta), y: clampNN(radius.bottomLeft.y + delta) }
  };
}
function srgbToLinearByte(c) {
  const cs = Math.min(1, Math.max(0, c > 1 ? c / 255 : c));
  const lin = cs <= 0.04045 ? cs / 12.92 : Math.pow((cs + 0.055) / 1.055, 2.4);
  return lin * 255;
}
function linearToSrgbByte(c) {
  const cl = Math.min(1, Math.max(0, c > 1 ? c / 255 : c));
  const srgb = cl <= 31308e-7 ? 12.92 * cl : 1.055 * Math.pow(cl, 1 / 2.4) - 0.055;
  return Math.round(Math.min(255, Math.max(0, srgb * 255)));
}
function compensateSrgbColor(rIn, gIn, bIn) {
  const rl = srgbToLinearByte(rIn) / 255;
  const gl = srgbToLinearByte(gIn) / 255;
  const bl = srgbToLinearByte(bIn) / 255;
  const max = Math.max(rl, gl, bl);
  const min = Math.min(rl, gl, bl);
  const mid = (rl + gl + bl) / 3;
  const sat = max - min;
  const boosted = Math.min(1, sat * 1.08);
  const scale = sat > 0 ? boosted / sat : 1;
  const r = mid + (rl - mid) * scale;
  const g = mid + (gl - mid) * scale;
  const b = mid + (bl - mid) * scale;
  return [linearToSrgbByte(r), linearToSrgbByte(g), linearToSrgbByte(b)];
}

// src/pdf/renderer/radius.ts
function cloneRadius(radius) {
  return {
    topLeft: { x: radius.topLeft.x, y: radius.topLeft.y },
    topRight: { x: radius.topRight.x, y: radius.topRight.y },
    bottomRight: { x: radius.bottomRight.x, y: radius.bottomRight.y },
    bottomLeft: { x: radius.bottomLeft.x, y: radius.bottomLeft.y }
  };
}
function shrinkRadius(radii, top, right, bottom, left) {
  return {
    topLeft: {
      x: clampRadiusComponent(radii.topLeft.x - top),
      y: clampRadiusComponent(radii.topLeft.y - left)
    },
    topRight: {
      x: clampRadiusComponent(radii.topRight.x - top),
      y: clampRadiusComponent(radii.topRight.y - right)
    },
    bottomRight: {
      x: clampRadiusComponent(radii.bottomRight.x - bottom),
      y: clampRadiusComponent(radii.bottomRight.y - right)
    },
    bottomLeft: {
      x: clampRadiusComponent(radii.bottomLeft.x - bottom),
      y: clampRadiusComponent(radii.bottomLeft.y - left)
    }
  };
}
function adjustRadius2(radius, delta) {
  const result = cloneRadius(radius);
  result.topLeft.x = clampNonNegative3(result.topLeft.x + delta);
  result.topLeft.y = clampNonNegative3(result.topLeft.y + delta);
  result.topRight.x = clampNonNegative3(result.topRight.x + delta);
  result.topRight.y = clampNonNegative3(result.topRight.y + delta);
  result.bottomRight.x = clampNonNegative3(result.bottomRight.x + delta);
  result.bottomRight.y = clampNonNegative3(result.bottomRight.y + delta);
  result.bottomLeft.x = clampNonNegative3(result.bottomLeft.x + delta);
  result.bottomLeft.y = clampNonNegative3(result.bottomLeft.y + delta);
  return result;
}
function clampRadiusComponent(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  return value > 0 ? value : 0;
}
function clampNonNegative3(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  return value < 0 ? 0 : value;
}

// src/pdf/renderer/paint-box-shadows.ts
function paintBoxShadows(painter, boxes, inset) {
  for (const box of boxes) {
    if (!box.boxShadows?.length) {
      continue;
    }
    for (const shadow of box.boxShadows) {
      if (shadow.inset !== inset) {
        continue;
      }
      if (!isRenderableShadow(shadow)) {
        continue;
      }
      if (inset) {
        renderInsetShadow(painter, box, shadow);
      } else {
        renderOuterShadow(painter, box, shadow);
      }
    }
  }
}
function isRenderableShadow(shadow) {
  const alpha = clampUnit3(shadow.color.a ?? 1);
  return alpha > 0;
}
function renderOuterShadow(painter, box, shadow) {
  const baseRect = translateRect(box.borderBox, shadow.offsetX, shadow.offsetY);
  const baseRadius = cloneRadius(box.borderRadius);
  const blur = clampNonNegative3(shadow.blur);
  const spread = shadow.spread;
  if (blur > 0) {
    const raster = rasterizeDropShadowForRect(baseRect, baseRadius, shadow.color, blur, spread);
    if (raster) {
      painter.drawShadowImage(raster.image, raster.drawRect);
      return;
    }
  }
  drawShadowLayers(painter, {
    mode: "outer",
    baseRect,
    baseRadius,
    color: shadow.color,
    blur,
    spread
  });
}
function renderInsetShadow(painter, box, shadow) {
  const container = box.paddingBox ?? box.contentBox;
  if (!container) {
    return;
  }
  const baseRect = translateRect(container, shadow.offsetX, shadow.offsetY);
  const baseRadius = shrinkRadius(cloneRadius(box.borderRadius), box.border.top, box.border.right, box.border.bottom, box.border.left);
  const blur = clampNonNegative3(shadow.blur);
  const spread = shadow.spread;
  if (blur === 0 && spread === 0) {
    painter.fillRoundedRect(baseRect, baseRadius, shadow.color);
    return;
  }
  drawShadowLayers(painter, {
    mode: "inset",
    baseRect,
    baseRadius,
    color: shadow.color,
    blur,
    spread
  });
}
function drawShadowLayers(painter, params) {
  const iterations = buildShadowIterations(params);
  if (!iterations.length) {
    return;
  }
  if (params.mode === "outer") {
    renderOuterShadowIterations(painter, params.baseRect, params.baseRadius, iterations);
    return;
  }
  renderInsetShadowIterations(painter, params.baseRect, params.baseRadius, iterations);
}
function buildShadowIterations(params) {
  const { mode, color, blur, spread } = params;
  const steps = blur > 0 ? Math.max(2, Math.ceil(blur / 2)) : 1;
  const weights = buildShadowWeights(steps);
  const baseAlpha = clampUnit3(color.a ?? 1);
  const iterations = [];
  for (let index = 0; index < steps; index++) {
    const fraction = steps === 1 ? 0 : mode === "outer" ? index / (steps - 1) : (index + 1) / steps;
    const expansion = spread + blur * fraction;
    const weight = weights[index] ?? 0;
    if (weight <= 0) {
      continue;
    }
    iterations.push({
      expansion,
      color: {
        r: color.r,
        g: color.g,
        b: color.b,
        a: clampUnit3(baseAlpha * weight)
      }
    });
  }
  return iterations;
}
function renderOuterShadowIterations(painter, baseRect, baseRadius, iterations) {
  for (const iteration of iterations) {
    const rect = inflateRect2(baseRect, iteration.expansion);
    if (rect.width <= 0 || rect.height <= 0) {
      continue;
    }
    const radius = adjustRadius2(baseRadius, iteration.expansion);
    painter.fillRoundedRect(rect, radius, iteration.color);
  }
}
function renderInsetShadowIterations(painter, baseRect, baseRadius, iterations) {
  for (const iteration of iterations) {
    const contraction = Math.max(0, iteration.expansion);
    const innerRect = inflateRect2(baseRect, -contraction);
    if (innerRect.width <= 0 || innerRect.height <= 0) {
      continue;
    }
    const outerRadius = cloneRadius(baseRadius);
    const innerRadius = adjustRadius2(baseRadius, -contraction);
    painter.fillRoundedRectDifference(baseRect, outerRadius, innerRect, innerRadius, iteration.color);
  }
}
function translateRect(rect, dx, dy) {
  return { x: rect.x + dx, y: rect.y + dy, width: rect.width, height: rect.height };
}
function inflateRect2(rect, amount) {
  const width = rect.width + amount * 2;
  const height = rect.height + amount * 2;
  if (width <= 0 || height <= 0) {
    return {
      x: rect.x + rect.width / 2,
      y: rect.y + rect.height / 2,
      width: 0,
      height: 0
    };
  }
  return {
    x: rect.x - amount,
    y: rect.y - amount,
    width,
    height
  };
}
function buildShadowWeights(steps) {
  if (steps <= 1) {
    return [1];
  }
  const weights = [];
  let total = 0;
  for (let index = 0; index < steps; index++) {
    const weight = steps - index;
    weights.push(weight);
    total += weight;
  }
  return weights.map((weight) => weight / total);
}
function clampUnit3(value) {
  if (!Number.isFinite(value)) {
    return 1;
  }
  if (value <= 0) {
    return 0;
  }
  if (value >= 1) {
    return 1;
  }
  return value;
}

// src/svg/path-data.ts
function parsePathData(data) {
  if (!data) {
    return [];
  }
  const parser = new PathDataParser(data);
  return parser.parse();
}
var PathDataParser = class {
  constructor(data) {
    this.index = 0;
    this.source = data;
  }
  parse() {
    const segments = [];
    let currentCommand = null;
    let currentX = 0;
    let currentY = 0;
    let startX = 0;
    let startY = 0;
    let prevCubicControlX = null;
    let prevCubicControlY = null;
    let prevQuadControlX = null;
    let prevQuadControlY = null;
    while (true) {
      this.skipSeparators();
      if (this.isDone()) {
        break;
      }
      const char = this.peekChar();
      if (char !== null && isCommandLetter(char)) {
        currentCommand = char;
        this.index += 1;
      } else if (!currentCommand) {
        break;
      }
      switch (currentCommand) {
        case "M":
        case "m": {
          const isRelative = currentCommand === "m";
          const firstPoint = this.readCoordinatePair();
          if (!firstPoint) {
            return segments;
          }
          currentX = isRelative ? currentX + firstPoint.x : firstPoint.x;
          currentY = isRelative ? currentY + firstPoint.y : firstPoint.y;
          startX = currentX;
          startY = currentY;
          segments.push({ type: "M", x: currentX, y: currentY });
          prevCubicControlX = prevCubicControlY = null;
          prevQuadControlX = prevQuadControlY = null;
          while (true) {
            this.skipSeparators();
            const peek = this.peekChar();
            if (peek === null || isCommandLetter(peek)) {
              break;
            }
            const point = this.readCoordinatePair();
            if (!point) {
              return segments;
            }
            currentX = isRelative ? currentX + point.x : point.x;
            currentY = isRelative ? currentY + point.y : point.y;
            segments.push({ type: "L", x: currentX, y: currentY });
          }
          break;
        }
        case "L":
        case "l": {
          const isRelative = currentCommand === "l";
          while (true) {
            const point = this.readCoordinatePair();
            if (!point) {
              break;
            }
            currentX = isRelative ? currentX + point.x : point.x;
            currentY = isRelative ? currentY + point.y : point.y;
            segments.push({ type: "L", x: currentX, y: currentY });
          }
          prevCubicControlX = prevCubicControlY = null;
          prevQuadControlX = prevQuadControlY = null;
          break;
        }
        case "H":
        case "h": {
          const isRelative = currentCommand === "h";
          while (true) {
            const value = this.readNumber();
            if (value === null) {
              break;
            }
            currentX = isRelative ? currentX + value : value;
            segments.push({ type: "L", x: currentX, y: currentY });
          }
          prevCubicControlX = prevCubicControlY = null;
          prevQuadControlX = prevQuadControlY = null;
          break;
        }
        case "V":
        case "v": {
          const isRelative = currentCommand === "v";
          while (true) {
            const value = this.readNumber();
            if (value === null) {
              break;
            }
            currentY = isRelative ? currentY + value : value;
            segments.push({ type: "L", x: currentX, y: currentY });
          }
          prevCubicControlX = prevCubicControlY = null;
          prevQuadControlX = prevQuadControlY = null;
          break;
        }
        case "C":
        case "c": {
          const isRelative = currentCommand === "c";
          while (true) {
            const first = this.readCoordinatePair();
            const second = this.readCoordinatePair();
            const end = this.readCoordinatePair();
            if (!first || !second || !end) {
              break;
            }
            const x1 = isRelative ? currentX + first.x : first.x;
            const y1 = isRelative ? currentY + first.y : first.y;
            const x2 = isRelative ? currentX + second.x : second.x;
            const y2 = isRelative ? currentY + second.y : second.y;
            currentX = isRelative ? currentX + end.x : end.x;
            currentY = isRelative ? currentY + end.y : end.y;
            segments.push({ type: "C", x1, y1, x2, y2, x: currentX, y: currentY });
            prevCubicControlX = x2;
            prevCubicControlY = y2;
            prevQuadControlX = prevQuadControlY = null;
          }
          break;
        }
        case "S":
        case "s": {
          const isRelative = currentCommand === "s";
          while (true) {
            const second = this.readCoordinatePair();
            const end = this.readCoordinatePair();
            if (!second || !end) {
              break;
            }
            let x1 = currentX;
            let y1 = currentY;
            if (prevCubicControlX !== null && prevCubicControlY !== null) {
              x1 = currentX * 2 - prevCubicControlX;
              y1 = currentY * 2 - prevCubicControlY;
            }
            const x2 = isRelative ? currentX + second.x : second.x;
            const y2 = isRelative ? currentY + second.y : second.y;
            currentX = isRelative ? currentX + end.x : end.x;
            currentY = isRelative ? currentY + end.y : end.y;
            segments.push({ type: "C", x1, y1, x2, y2, x: currentX, y: currentY });
            prevCubicControlX = x2;
            prevCubicControlY = y2;
            prevQuadControlX = prevQuadControlY = null;
          }
          break;
        }
        case "Q":
        case "q": {
          const isRelative = currentCommand === "q";
          while (true) {
            const control = this.readCoordinatePair();
            const end = this.readCoordinatePair();
            if (!control || !end) {
              break;
            }
            const cx = isRelative ? currentX + control.x : control.x;
            const cy = isRelative ? currentY + control.y : control.y;
            const ex = isRelative ? currentX + end.x : end.x;
            const ey = isRelative ? currentY + end.y : end.y;
            const cubic = quadraticToCubic(currentX, currentY, cx, cy, ex, ey);
            segments.push(cubic);
            currentX = ex;
            currentY = ey;
            prevCubicControlX = cubic.x2;
            prevCubicControlY = cubic.y2;
            prevQuadControlX = cx;
            prevQuadControlY = cy;
          }
          break;
        }
        case "T":
        case "t": {
          const isRelative = currentCommand === "t";
          while (true) {
            const end = this.readCoordinatePair();
            if (!end) {
              break;
            }
            let cx = currentX;
            let cy = currentY;
            if (prevQuadControlX !== null && prevQuadControlY !== null) {
              cx = currentX * 2 - prevQuadControlX;
              cy = currentY * 2 - prevQuadControlY;
            }
            const ex = isRelative ? currentX + end.x : end.x;
            const ey = isRelative ? currentY + end.y : end.y;
            const cubic = quadraticToCubic(currentX, currentY, cx, cy, ex, ey);
            segments.push(cubic);
            currentX = ex;
            currentY = ey;
            prevCubicControlX = cubic.x2;
            prevCubicControlY = cubic.y2;
            prevQuadControlX = cx;
            prevQuadControlY = cy;
          }
          break;
        }
        case "A":
        case "a": {
          const isRelative = currentCommand === "a";
          while (true) {
            const rx = this.readNumber();
            const ry = this.readNumber();
            const xAxisRotation = this.readNumber();
            const largeArcFlag = this.readFlag();
            const sweepFlag = this.readFlag();
            const end = this.readCoordinatePair();
            if (rx === null || ry === null || xAxisRotation === null || largeArcFlag === null || sweepFlag === null || !end) {
              break;
            }
            const ex = isRelative ? currentX + end.x : end.x;
            const ey = isRelative ? currentY + end.y : end.y;
            const curves = arcToCubicCurves(currentX, currentY, rx, ry, xAxisRotation, largeArcFlag === 1, sweepFlag === 1, ex, ey);
            if (curves.length === 0) {
              if (currentX !== ex || currentY !== ey) {
                segments.push({ type: "L", x: ex, y: ey });
              }
            } else {
              for (const curve of curves) {
                segments.push({
                  type: "C",
                  x1: curve[0],
                  y1: curve[1],
                  x2: curve[2],
                  y2: curve[3],
                  x: curve[4],
                  y: curve[5]
                });
              }
            }
            currentX = ex;
            currentY = ey;
            prevCubicControlX = curves.length > 0 ? curves[curves.length - 1][2] : null;
            prevCubicControlY = curves.length > 0 ? curves[curves.length - 1][3] : null;
            prevQuadControlX = prevQuadControlY = null;
          }
          break;
        }
        case "Z":
        case "z": {
          if (currentX !== startX || currentY !== startY) {
            segments.push({ type: "L", x: startX, y: startY });
          }
          segments.push({ type: "Z" });
          currentX = startX;
          currentY = startY;
          prevCubicControlX = prevCubicControlY = null;
          prevQuadControlX = prevQuadControlY = null;
          break;
        }
        default:
          return segments;
      }
    }
    return segments;
  }
  readCoordinatePair() {
    const x = this.readNumber();
    const y = this.readNumber();
    if (x === null || y === null) {
      return null;
    }
    return { x, y };
  }
  readFlag() {
    this.skipSeparators();
    if (this.isDone()) {
      return null;
    }
    const char = this.source[this.index];
    if (char === "0" || char === "1") {
      this.index += 1;
      return char === "1" ? 1 : 0;
    }
    const value = this.readNumber();
    if (value === null) {
      return null;
    }
    return value === 0 ? 0 : 1;
  }
  readNumber() {
    this.skipSeparators();
    if (this.isDone()) {
      return null;
    }
    const slice = this.source.slice(this.index);
    const match = slice.match(/^[-+]?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?/);
    if (!match) {
      return null;
    }
    this.index += match[0].length;
    const value = Number.parseFloat(match[0]);
    if (!Number.isFinite(value)) {
      return null;
    }
    return value;
  }
  skipSeparators() {
    while (!this.isDone()) {
      const char = this.source[this.index];
      if (char === "," || char === " " || char === "	" || char === "\n" || char === "\r") {
        this.index += 1;
        continue;
      }
      break;
    }
  }
  peekChar() {
    if (this.isDone()) {
      return null;
    }
    return this.source[this.index];
  }
  isDone() {
    return this.index >= this.source.length;
  }
};
function quadraticToCubic(x0, y0, cx, cy, x, y) {
  const x1 = x0 + 2 / 3 * (cx - x0);
  const y1 = y0 + 2 / 3 * (cy - y0);
  const x2 = x + 2 / 3 * (cx - x);
  const y2 = y + 2 / 3 * (cy - y);
  return { type: "C", x1, y1, x2, y2, x, y };
}
function arcToCubicCurves(x0, y0, rx, ry, angle, largeArc, sweep, x, y) {
  const curves = [];
  if (x0 === x && y0 === y) {
    return curves;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  if (rx === 0 || ry === 0) {
    return curves;
  }
  const rad = angle * Math.PI / 180;
  const cosAngle = Math.cos(rad);
  const sinAngle = Math.sin(rad);
  const dx2 = (x0 - x) / 2;
  const dy2 = (y0 - y) / 2;
  const x1p = cosAngle * dx2 + sinAngle * dy2;
  const y1p = -sinAngle * dx2 + cosAngle * dy2;
  let rxSq = rx * rx;
  let rySq = ry * ry;
  let x1pSq = x1p * x1p;
  let y1pSq = y1p * y1p;
  let radiiCheck = x1pSq / rxSq + y1pSq / rySq;
  if (radiiCheck > 1) {
    const scale = Math.sqrt(radiiCheck);
    rx *= scale;
    ry *= scale;
    rxSq = rx * rx;
    rySq = ry * ry;
  }
  const sign = largeArc === sweep ? -1 : 1;
  const sq = (rxSq * rySq - rxSq * y1pSq - rySq * x1pSq) / (rxSq * y1pSq + rySq * x1pSq);
  const coef = sign * Math.sqrt(Math.max(0, sq));
  const cxp = coef * rx * y1p / ry;
  const cyp = -coef * ry * x1p / rx;
  const cx = cosAngle * cxp - sinAngle * cyp + (x0 + x) / 2;
  const cy = sinAngle * cxp + cosAngle * cyp + (y0 + y) / 2;
  const startAngle = angleBetween(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
  let deltaAngle = angleBetween(
    (x1p - cxp) / rx,
    (y1p - cyp) / ry,
    (-x1p - cxp) / rx,
    (-y1p - cyp) / ry
  );
  if (!sweep && deltaAngle > 0) {
    deltaAngle -= 2 * Math.PI;
  } else if (sweep && deltaAngle < 0) {
    deltaAngle += 2 * Math.PI;
  }
  const segments = Math.ceil(Math.abs(deltaAngle) / (Math.PI / 2));
  const delta = deltaAngle / segments;
  const t = 4 / 3 * Math.tan(delta / 4);
  let start = startAngle;
  let prevX = x0;
  let prevY = y0;
  for (let i = 0; i < segments; i += 1) {
    const end = start + delta;
    const sinStart = Math.sin(start);
    const cosStart = Math.cos(start);
    const sinEnd = Math.sin(end);
    const cosEnd = Math.cos(end);
    const x2 = cx + rx * cosAngle * cosEnd - ry * sinAngle * sinEnd;
    const y2 = cy + rx * sinAngle * cosEnd + ry * cosAngle * sinEnd;
    const dx1 = -rx * cosAngle * sinStart - ry * sinAngle * cosStart;
    const dy1 = -rx * sinAngle * sinStart + ry * cosAngle * cosStart;
    const dx22 = -rx * cosAngle * sinEnd - ry * sinAngle * cosEnd;
    const dy22 = -rx * sinAngle * sinEnd + ry * cosAngle * cosEnd;
    const cp1x = prevX + t * dx1;
    const cp1y = prevY + t * dy1;
    const cp2x = x2 - t * dx22;
    const cp2y = y2 - t * dy22;
    curves.push([cp1x, cp1y, cp2x, cp2y, x2, y2]);
    prevX = x2;
    prevY = y2;
    start = end;
  }
  return curves;
}
function angleBetween(ux, uy, vx, vy) {
  const dot = ux * vx + uy * vy;
  const len = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
  const clamped = clamp2(-1, 1, len === 0 ? 0 : dot / len);
  const sign = ux * vy - uy * vx < 0 ? -1 : 1;
  return sign * Math.acos(clamped);
}
function isCommandLetter(char) {
  return /[a-zA-Z]/.test(char);
}
function clamp2(min, max, value) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}

// src/pdf/svg/geometry-builder.ts
var CIRCLE_KAPPA = 0.5522847498307936;
function buildRectSegments(x, y, width, height) {
  return [
    { type: "M", x, y },
    { type: "L", x: x + width, y },
    { type: "L", x: x + width, y: y + height },
    { type: "L", x, y: y + height },
    { type: "Z" }
  ];
}
function buildRoundedRectSegments(x, y, width, height, rx, ry) {
  const right = x + width;
  const bottom = y + height;
  const kx = rx * CIRCLE_KAPPA;
  const ky = ry * CIRCLE_KAPPA;
  return [
    { type: "M", x: x + rx, y },
    { type: "L", x: right - rx, y },
    { type: "C", x1: right - rx + kx, y1: y, x2: right, y2: y + ry - ky, x: right, y: y + ry },
    { type: "L", x: right, y: bottom - ry },
    { type: "C", x1: right, y1: bottom - ry + ky, x2: right - rx + kx, y2: bottom, x: right - rx, y: bottom },
    { type: "L", x: x + rx, y: bottom },
    { type: "C", x1: x + rx - kx, y1: bottom, x2: x, y2: bottom - ry + ky, x, y: bottom - ry },
    { type: "L", x, y: y + ry },
    { type: "C", x1: x, y1: y + ry - ky, x2: x + rx - kx, y2: y, x: x + rx, y },
    { type: "Z" }
  ];
}
function buildEllipseSegments(cx, cy, rx, ry) {
  const mx = rx * CIRCLE_KAPPA;
  const my = ry * CIRCLE_KAPPA;
  return [
    { type: "M", x: cx, y: cy - ry },
    { type: "C", x1: cx + mx, y1: cy - ry, x2: cx + rx, y2: cy - my, x: cx + rx, y: cy },
    { type: "C", x1: cx + rx, y1: cy + my, x2: cx + mx, y2: cy + ry, x: cx, y: cy + ry },
    { type: "C", x1: cx - mx, y1: cy + ry, x2: cx - rx, y2: cy + my, x: cx - rx, y: cy },
    { type: "C", x1: cx - rx, y1: cy - my, x2: cx - mx, y2: cy - ry, x: cx, y: cy - ry },
    { type: "Z" }
  ];
}

// src/pdf/svg/coordinate-mapper.ts
function mapPoints(points, context) {
  const result = [];
  for (const point of points) {
    const mapped = mapSvgPoint(point.x, point.y, context);
    if (!mapped) {
      return [];
    }
    result.push(mapped);
  }
  return result;
}
function mapPathSegments(segments, context) {
  const commands = [];
  for (const segment of segments) {
    switch (segment.type) {
      case "M": {
        const point = mapSvgPoint(segment.x, segment.y, context);
        if (!point) {
          return null;
        }
        commands.push({ type: "moveTo", x: point.x, y: point.y });
        break;
      }
      case "L": {
        const point = mapSvgPoint(segment.x, segment.y, context);
        if (!point) {
          return null;
        }
        commands.push({ type: "lineTo", x: point.x, y: point.y });
        break;
      }
      case "C": {
        const cp1 = mapSvgPoint(segment.x1, segment.y1, context);
        const cp2 = mapSvgPoint(segment.x2, segment.y2, context);
        const end = mapSvgPoint(segment.x, segment.y, context);
        if (!cp1 || !cp2 || !end) {
          return null;
        }
        commands.push({
          type: "curveTo",
          x1: cp1.x,
          y1: cp1.y,
          x2: cp2.x,
          y2: cp2.y,
          x: end.x,
          y: end.y
        });
        break;
      }
      case "Z":
        commands.push({ type: "closePath" });
        break;
      default:
        return null;
    }
  }
  return commands;
}
function mapSvgPoint(x, y, context) {
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    return null;
  }
  const mapped = mapPointToViewport(context, x, y);
  if (!Number.isFinite(mapped.x) || !Number.isFinite(mapped.y)) {
    return null;
  }
  return mapped;
}
function mapPointToViewport(context, x, y) {
  const local = applyMatrixToPoint(context.transform, x, y);
  return applyMatrixToPoint(context.viewportMatrix, local.x, local.y);
}

// src/pdf/svg/style-computer.ts
function deriveStyle(base, node) {
  const style = { ...base };
  const attrs = node.attributes ?? {};
  if (attrs.opacity !== void 0) {
    const value = parseOpacity3(attrs.opacity);
    if (value !== void 0) {
      style.opacity = clamp01(style.opacity * value);
    }
  }
  if (attrs.fill !== void 0) {
    const fillValue = attrs.fill.trim();
    style.fill = !fillValue || fillValue === "none" ? void 0 : fillValue;
  }
  if (attrs["fill-opacity"] !== void 0) {
    const value = parseOpacity3(attrs["fill-opacity"]);
    if (value !== void 0) {
      style.fillOpacity = clamp01(value);
    }
  }
  if (attrs.stroke !== void 0) {
    const strokeValue = attrs.stroke.trim();
    style.stroke = !strokeValue || strokeValue === "none" ? void 0 : strokeValue;
  }
  if (attrs["stroke-opacity"] !== void 0) {
    const value = parseOpacity3(attrs["stroke-opacity"]);
    if (value !== void 0) {
      style.strokeOpacity = clamp01(value);
    }
  }
  if (attrs["stroke-width"] !== void 0) {
    const value = parseNumber(attrs["stroke-width"]);
    if (value !== void 0) {
      style.strokeWidth = value;
    }
  }
  if (attrs["stroke-linecap"] !== void 0) {
    const cap = normalizeLineCap(attrs["stroke-linecap"]);
    if (cap) {
      style.strokeLinecap = cap;
    }
  }
  if (attrs["stroke-linejoin"] !== void 0) {
    const join = normalizeLineJoin(attrs["stroke-linejoin"]);
    if (join) {
      style.strokeLinejoin = join;
    }
  }
  if (attrs["stroke-dasharray"] !== void 0) {
    const value = parseDashArray(attrs["stroke-dasharray"]);
    if (value) {
      style.strokeDashArray = value;
    }
  }
  if (attrs["stroke-dashoffset"] !== void 0) {
    const value = parseNumber(attrs["stroke-dashoffset"]);
    if (value !== void 0) {
      style.strokeDashOffset = value;
    }
  }
  if (attrs["fill-rule"] !== void 0) {
    const rule = normalizeFillRule(attrs["fill-rule"]);
    if (rule) {
      style.fillRule = rule;
    }
  }
  if (attrs["font-size"] !== void 0) {
    const value = parseNumber(attrs["font-size"]);
    if (value !== void 0) {
      style.fontSize = value;
    }
  }
  if (attrs["font-family"] !== void 0) {
    const family = attrs["font-family"].trim();
    if (family) {
      style.fontFamily = family;
    }
  }
  if (attrs["text-anchor"] !== void 0) {
    const anchor = normalizeTextAnchor2(attrs["text-anchor"]);
    if (anchor) {
      style.textAnchor = anchor;
    }
  }
  return style;
}
function createDefaultStyle() {
  return {
    fill: "#000000",
    stroke: void 0,
    strokeWidth: 1,
    strokeLinecap: "butt",
    strokeLinejoin: "miter",
    strokeDashArray: void 0,
    strokeDashOffset: 0,
    fillRule: "nonzero",
    opacity: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    fontSize: 16,
    fontFamily: void 0,
    textAnchor: "start"
  };
}
function resolvePaint(value, opacity) {
  if (!value) {
    return void 0;
  }
  if (value === "none") {
    return void 0;
  }
  const color = parseColor(value);
  if (!color) {
    return void 0;
  }
  const baseAlpha = color.a ?? 1;
  return {
    r: color.r,
    g: color.g,
    b: color.b,
    a: clamp01(baseAlpha * opacity)
  };
}
function parseOpacity3(value) {
  const parsed = parseNumber(value);
  if (parsed === void 0) {
    return void 0;
  }
  return clamp01(parsed);
}
function parseNumber(value) {
  if (!value) {
    return void 0;
  }
  const trimmed = value.trim();
  if (!trimmed) {
    return void 0;
  }
  const num = Number.parseFloat(trimmed);
  if (!Number.isFinite(num)) {
    return void 0;
  }
  return num;
}
function normalizeLineCap(value) {
  const lower = value.trim().toLowerCase();
  if (lower === "butt" || lower === "round" || lower === "square") {
    return lower;
  }
  return void 0;
}
function normalizeLineJoin(value) {
  const lower = value.trim().toLowerCase();
  if (lower === "miter" || lower === "round" || lower === "bevel") {
    return lower;
  }
  return void 0;
}
function normalizeFillRule(value) {
  const lower = value.trim().toLowerCase();
  if (lower === "nonzero" || lower === "evenodd") {
    return lower;
  }
  return void 0;
}
function normalizeTextAnchor2(value) {
  const lower = value.trim().toLowerCase();
  if (lower === "start" || lower === "middle" || lower === "end") {
    return lower;
  }
  return void 0;
}
function clamp01(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  if (value <= 0) {
    return 0;
  }
  if (value >= 1) {
    return 1;
  }
  return value;
}
function parseDashArray(value) {
  if (!value) {
    return void 0;
  }
  const trimmed = value.trim();
  if (!trimmed || trimmed === "none") {
    return void 0;
  }
  const parts = trimmed.split(/[\s,]+/).map((part) => Number.parseFloat(part)).filter((num) => Number.isFinite(num) && num >= 0);
  if (parts.length === 0) {
    return void 0;
  }
  return parts;
}

// src/pdf/svg/shape-renderer.ts
function isLinearGradientPaint(value) {
  if (typeof value !== "object" || value === null) return false;
  const candidate = value;
  return candidate.type === "linear" && Array.isArray(candidate.stops);
}
function isRadialGradientPaint(value) {
  if (typeof value !== "object" || value === null) return false;
  const candidate = value;
  return candidate.type === "radial" && typeof candidate.r === "number";
}
function renderRect(node, style, context) {
  const width = Number.isFinite(node.width ?? NaN) ? node.width ?? 0 : 0;
  const height = Number.isFinite(node.height ?? NaN) ? node.height ?? 0 : 0;
  if (width <= 0 || height <= 0) {
    return;
  }
  const x = Number.isFinite(node.x ?? NaN) ? node.x ?? 0 : 0;
  const y = Number.isFinite(node.y ?? NaN) ? node.y ?? 0 : 0;
  let rx = node.rx ?? node.ry ?? 0;
  let ry = node.ry ?? node.rx ?? 0;
  if (!Number.isFinite(rx)) rx = 0;
  if (!Number.isFinite(ry)) ry = 0;
  rx = clampRadius2(rx, width / 2);
  ry = clampRadius2(ry, height / 2);
  const segments = rx > 0 || ry > 0 ? buildRoundedRectSegments(x, y, width, height, rx, ry) : buildRectSegments(x, y, width, height);
  const gradient = resolveGradientPaint(style.fill, context);
  if (gradient) {
    const p1 = mapSvgPoint(x, y, context);
    const p2 = mapSvgPoint(x + width, y + height, context);
    if (p1 && p2) {
      const pxRect = { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
      if (gradient.type === "radial") {
        if (rx > 0 || ry > 0) {
          context.painter.fillRoundedRect(pxRect, {
            topLeft: { x: rx, y: ry },
            topRight: { x: rx, y: ry },
            bottomRight: { x: rx, y: ry },
            bottomLeft: { x: rx, y: ry }
          }, gradient);
        } else {
          context.painter.fillRect(pxRect, gradient);
        }
      } else {
        if (rx > 0 || ry > 0) {
          context.painter.fillRoundedRect(pxRect, {
            topLeft: { x: rx, y: ry },
            topRight: { x: rx, y: ry },
            bottomRight: { x: rx, y: ry },
            bottomLeft: { x: rx, y: ry }
          }, gradient);
        } else {
          context.painter.fillRect(pxRect, gradient);
        }
      }
      return;
    }
  }
  const commands = mapPathSegments(segments, context);
  if (!commands || commands.length === 0) {
    return;
  }
  paintPathCommands(commands, style, context, style.fillRule);
}
function renderCircle(node, style, context) {
  const radius = Number.isFinite(node.r ?? NaN) ? node.r ?? 0 : 0;
  if (radius <= 0) {
    return;
  }
  const cx = Number.isFinite(node.cx ?? NaN) ? node.cx ?? 0 : 0;
  const cy = Number.isFinite(node.cy ?? NaN) ? node.cy ?? 0 : 0;
  const gradient = resolveGradientPaint(style.fill, context);
  if (gradient) {
    const center = mapSvgPoint(cx, cy, context);
    const edge = mapSvgPoint(cx + radius, cy, context);
    if (center && edge) {
      const rPx = Math.sqrt((edge.x - center.x) ** 2 + (edge.y - center.y) ** 2);
      const pxRect = { x: center.x - rPx, y: center.y - rPx, width: rPx * 2, height: rPx * 2 };
      const radii = {
        topLeft: { x: rPx, y: rPx },
        topRight: { x: rPx, y: rPx },
        bottomRight: { x: rPx, y: rPx },
        bottomLeft: { x: rPx, y: rPx }
      };
      if (gradient.type === "radial") {
        context.painter.fillRoundedRect(pxRect, radii, gradient);
      } else {
        context.painter.fillRoundedRect(pxRect, radii, gradient);
      }
      return;
    }
  }
  const segments = buildEllipseSegments(cx, cy, radius, radius);
  const commands = mapPathSegments(segments, context);
  if (!commands || commands.length === 0) {
    return;
  }
  paintPathCommands(commands, style, context, style.fillRule);
}
function renderEllipse(node, style, context) {
  const rx = Number.isFinite(node.rx ?? NaN) ? node.rx ?? 0 : 0;
  const ry = Number.isFinite(node.ry ?? NaN) ? node.ry ?? 0 : 0;
  if (rx <= 0 || ry <= 0) {
    return;
  }
  const cx = Number.isFinite(node.cx ?? NaN) ? node.cx ?? 0 : 0;
  const cy = Number.isFinite(node.cy ?? NaN) ? node.cy ?? 0 : 0;
  const segments = buildEllipseSegments(cx, cy, rx, ry);
  const commands = mapPathSegments(segments, context);
  if (!commands || commands.length === 0) {
    return;
  }
  paintPathCommands(commands, style, context, style.fillRule);
}
function clampRadius2(value, limit) {
  if (!Number.isFinite(value) || value <= 0) {
    return 0;
  }
  if (value > limit) {
    return limit;
  }
  return value;
}
function renderPolygon(node, style, context) {
  const points = node.points ?? [];
  if (points.length < 2) {
    return;
  }
  const mapped = mapPoints(points, context);
  if (mapped.length < 2) {
    return;
  }
  const fillColor = resolvePaint(style.fill, style.opacity * style.fillOpacity);
  if (fillColor) {
    context.painter.fillPolygon(mapped, fillColor, true);
  }
  const strokeColor = resolvePaint(style.stroke, style.opacity * style.strokeOpacity);
  if (strokeColor) {
    context.painter.strokePolyline(mapped, strokeColor, {
      ...getStrokeOptions(style, context),
      close: true
    });
  }
}
function renderPolyline(node, style, context) {
  const points = node.points ?? [];
  if (points.length < 2) {
    return;
  }
  const mapped = mapPoints(points, context);
  if (mapped.length < 2) {
    return;
  }
  const strokeColor = resolvePaint(style.stroke, style.opacity * style.strokeOpacity);
  if (strokeColor) {
    context.painter.strokePolyline(mapped, strokeColor, {
      ...getStrokeOptions(style, context),
      close: false
    });
  }
}
function renderLine(node, style, context) {
  const strokeColor = resolvePaint(style.stroke, style.opacity * style.strokeOpacity);
  if (!strokeColor) {
    return;
  }
  const start = mapSvgPoint(node.x1 ?? 0, node.y1 ?? 0, context);
  const end = mapSvgPoint(node.x2 ?? 0, node.y2 ?? 0, context);
  if (!start || !end) {
    return;
  }
  const points = [start, end];
  context.painter.strokePolyline(points, strokeColor, {
    ...getStrokeOptions(style, context),
    close: false
  });
}
function renderPath(node, style, context) {
  const segments = parsePathData(node.d);
  if (segments.length === 0) {
    return;
  }
  const commands = mapPathSegments(segments, context);
  if (!commands || commands.length === 0) {
    return;
  }
  paintPathCommands(commands, style, context, style.fillRule);
}
function paintPathCommands(commands, style, context, fillRule) {
  if (commands.length === 0) {
    return;
  }
  const gradient = resolveGradientPaint(style.fill, context);
  if (gradient) {
    context.painter.fillPathWithGradient(commands, gradient, { fillRule });
    return;
  }
  const fillColor = resolvePaint(style.fill, style.opacity * style.fillOpacity);
  if (fillColor) {
    context.painter.fillPath(commands, fillColor, { fillRule: fillRule ?? style.fillRule });
  }
  const strokeColor = resolvePaint(style.stroke, style.opacity * style.strokeOpacity);
  if (strokeColor) {
    context.painter.strokePath(commands, strokeColor, getStrokeOptions(style, context));
  }
}
async function renderText2(node, style, context) {
  const fillColor = resolvePaint(style.fill, style.opacity * style.fillOpacity);
  if (!fillColor) {
    return;
  }
  const fontSize = node.fontSize ?? style.fontSize;
  if (!Number.isFinite(fontSize) || fontSize <= 0) {
    return;
  }
  const anchor = node.textAnchor ?? style.textAnchor ?? "start";
  const combined = multiplyMatrices(context.viewportMatrix, context.transform);
  const anchorX = Number.isFinite(node.x ?? NaN) ? node.x ?? 0 : 0;
  const anchorY = Number.isFinite(node.y ?? NaN) ? node.y ?? 0 : 0;
  const origin = applyMatrixToPoint(combined, anchorX, anchorY);
  const axisX = { x: combined.a, y: combined.b };
  const approxWidth = estimateTextWidth(node.text, fontSize);
  const anchorFactor = anchor === "middle" ? 0.5 : anchor === "end" ? 1 : 0;
  let baselineX = origin.x;
  let baselineY = origin.y;
  if (anchorFactor !== 0 && (axisX.x !== 0 || axisX.y !== 0)) {
    baselineX -= axisX.x * approxWidth * anchorFactor;
    baselineY -= axisX.y * approxWidth * anchorFactor;
  }
  const color = { r: fillColor.r, g: fillColor.g, b: fillColor.b, a: clampAlpha(fillColor.a ?? 1) };
  const fontFamily = node.fontFamily ?? style.fontFamily ?? "Helvetica";
  await context.painter.drawTextRun({
    text: node.text,
    fontFamily,
    fontSize,
    fill: color,
    lineMatrix: {
      a: combined.a,
      b: combined.b,
      c: combined.c,
      d: combined.d,
      e: baselineX,
      f: baselineY
    }
  });
}
function estimateTextWidth(text, fontSize) {
  if (!text) {
    return 0;
  }
  const averageFactor = 0.6;
  return text.length * fontSize * averageFactor;
}
function resolveGradientPaint(paint, context) {
  if (isLinearGradientPaint(paint) || isRadialGradientPaint(paint)) return paint;
  if (typeof paint === "string") {
    const trimmed = paint.trim();
    const urlMatch = trimmed.match(/^url\(\s*#([^\)\s]+)\s*\)$/i);
    if (urlMatch && context) {
      const defs = context.defs;
      if (defs) {
        const node = defs.get(urlMatch[1]);
        if (node && (node.type === "lineargradient" || node.type === "radialgradient")) {
          if (node.type === "lineargradient") {
            return svgLinearNodeToLinearGradient(node, context);
          }
          return svgRadialNodeToRadialGradient(node, context);
        }
      }
    }
    return parseLinearGradient(paint);
  }
  return null;
}
function svgLinearNodeToLinearGradient(node, context) {
  const x1 = node.x1 ?? 0;
  const y1 = node.y1 ?? 0;
  const x2 = node.x2 ?? 1;
  const y2 = node.y2 ?? 0;
  const stops = (node.stops ?? []).map((s) => ({ color: s.color, position: s.offset }));
  const units = node.gradientUnits === "userSpaceOnUse" ? "userSpace" : "ratio";
  if (units === "userSpace" && context) {
    const p1 = mapSvgPoint(x1, y1, context);
    const p2 = mapSvgPoint(x2, y2, context);
    if (p1 && p2) {
      return { type: "linear", direction: "to right", stops, coords: { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, units: "userSpace" } };
    }
  }
  let rp1 = { x: x1, y: y1 };
  let rp2 = { x: x2, y: y2 };
  const rawTransform = node.attributes && (node.attributes["gradientTransform"] ?? node.attributes["gradienttransform"]);
  if (rawTransform) {
    const t = parseTransform(rawTransform) || void 0;
    if (t) {
      rp1 = applyMatrixToPoint(t, rp1.x, rp1.y);
      rp2 = applyMatrixToPoint(t, rp2.x, rp2.y);
    }
  }
  const dx = rp2.x - rp1.x;
  const dy = rp2.y - rp1.y;
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
  const direction = `${angle.toFixed(2)}deg`;
  return { type: "linear", direction, stops, coords: { x1: rp1.x, y1: rp1.y, x2: rp2.x, y2: rp2.y, units: "ratio" } };
}
function svgRadialNodeToRadialGradient(node, context) {
  const cx = node.cx ?? 0.5;
  const cy = node.cy ?? 0.5;
  const r = node.r ?? 0.5;
  const fx = node.fx;
  const fy = node.fy;
  const stops = (node.stops ?? []).map((s) => ({ color: s.color, position: s.offset }));
  const units = node.gradientUnits === "userSpaceOnUse" ? "userSpace" : "ratio";
  if (units === "userSpace" && context) {
    const center = mapSvgPoint(cx, cy, context);
    const focal = fx !== void 0 && fy !== void 0 ? mapSvgPoint(fx, fy, context) : void 0;
    const radiusPt = (() => {
      const edge = mapSvgPoint(cx + r, cy, context);
      if (center && edge) {
        const dx = edge.x - center.x;
        const dy = edge.y - center.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
      return void 0;
    })();
    if (center && radiusPt !== void 0) {
      const rad = {
        type: "radial",
        cx: center.x,
        cy: center.y,
        r: radiusPt,
        stops,
        coordsUnits: "userSpace"
      };
      if (focal) {
        rad.fx = focal.x;
        rad.fy = focal.y;
      }
      return rad;
    }
  }
  const radRatio = {
    type: "radial",
    cx,
    cy,
    r,
    stops
  };
  if (fx !== void 0 && fy !== void 0) {
    radRatio.fx = fx;
    radRatio.fy = fy;
  }
  const rawTransform = node.attributes && (node.attributes["gradientTransform"] ?? node.attributes["gradienttransform"]);
  if (rawTransform) {
    const t = parseTransform(rawTransform) || void 0;
    if (t) {
      radRatio.transform = { a: t.a, b: t.b, c: t.c, d: t.d, e: t.e, f: t.f };
    }
  }
  return radRatio;
}
function getStrokeOptions(style, context) {
  const strokeWidthPx = (style.strokeWidth ?? 1) * context.strokeScale;
  const options = {
    lineWidth: strokeWidthPx > 0 ? strokeWidthPx : void 0,
    lineCap: style.strokeLinecap,
    lineJoin: style.strokeLinejoin
  };
  if (style.strokeDashArray && style.strokeDashArray.length > 0) {
    const pattern = style.strokeDashArray.map((v) => v * context.strokeScale);
    const phase = (style.strokeDashOffset ?? 0) * context.strokeScale;
    options.dash = { pattern, phase };
  }
  return options;
}

// src/pdf/svg/aspect-ratio.ts
function parsePreserveAspectRatio(raw) {
  const defaultValue = { align: "xMidYMid", meetOrSlice: "meet" };
  if (!raw) {
    return defaultValue;
  }
  const tokens = raw.trim().split(/[\s,]+/).filter(Boolean);
  if (tokens.length === 0) {
    return defaultValue;
  }
  const validAlignments = {
    none: "none",
    xminymin: "xMinYMin",
    xmidymin: "xMidYMin",
    xmaxymin: "xMaxYMin",
    xminymid: "xMinYMid",
    xmidymid: "xMidYMid",
    xmaxymid: "xMaxYMid",
    xminymax: "xMinYMax",
    xmidymax: "xMidYMax",
    xmaxymax: "xMaxYMax"
  };
  let index = 0;
  let alignToken = tokens[index]?.toLowerCase() ?? "";
  if (alignToken === "defer") {
    index += 1;
    alignToken = tokens[index]?.toLowerCase() ?? "";
  }
  index += 1;
  let align = validAlignments[alignToken] ?? defaultValue.align;
  if (align === "none") {
    return { align: "none", meetOrSlice: "meet" };
  }
  let meetOrSlice = "meet";
  for (; index < tokens.length; index += 1) {
    const token = tokens[index]?.toLowerCase();
    if (token === "meet") {
      meetOrSlice = "meet";
      break;
    }
    if (token === "slice") {
      meetOrSlice = "slice";
      break;
    }
  }
  if (!validAlignments[alignToken]) {
    align = defaultValue.align;
  }
  return { align, meetOrSlice };
}
function getAlignFactors(align) {
  if (align === "none") {
    return { x: 0, y: 0 };
  }
  const horizontal = align.includes("xMid") ? 0.5 : align.includes("xMax") ? 1 : 0;
  const vertical = align.includes("YMid") ? 0.5 : align.includes("YMax") ? 1 : 0;
  return { x: horizontal, y: vertical };
}

// src/pdf/svg/render-svg.ts
async function renderSvgBox(painter, box, environment) {
  const svgData = extractSvgCustomData(box);
  if (!svgData) {
    return;
  }
  const { root } = svgData;
  const content = box.contentBox;
  const widthPx = Math.max(content.width, 0);
  const heightPx = Math.max(content.height, 0);
  if (widthPx <= 0 || heightPx <= 0) {
    return;
  }
  const sourceWidth = resolvePositive(root.viewBox?.width ?? svgData.intrinsicWidth ?? widthPx);
  const sourceHeight = resolvePositive(root.viewBox?.height ?? svgData.intrinsicHeight ?? heightPx);
  const minX = root.viewBox?.minX ?? 0;
  const minY = root.viewBox?.minY ?? 0;
  const preserveAttr = root.attributes?.preserveAspectRatio ?? root.attributes?.preserveaspectratio;
  const preserve = parsePreserveAspectRatio(typeof preserveAttr === "string" ? preserveAttr : void 0);
  const baseScaleX = safeScale(widthPx / sourceWidth);
  const baseScaleY = safeScale(heightPx / sourceHeight);
  let scaleX = baseScaleX;
  let scaleY = baseScaleY;
  let offsetX = 0;
  let offsetY = 0;
  if (preserve.align !== "none") {
    const uniformScale = preserve.meetOrSlice === "slice" ? Math.max(baseScaleX, baseScaleY) : Math.min(baseScaleX, baseScaleY);
    scaleX = uniformScale;
    scaleY = uniformScale;
    const scaledWidth = sourceWidth * scaleX;
    const scaledHeight = sourceHeight * scaleY;
    const extraWidth = widthPx - scaledWidth;
    const extraHeight = heightPx - scaledHeight;
    const factors = getAlignFactors(preserve.align);
    offsetX = extraWidth * factors.x;
    offsetY = extraHeight * factors.y;
  }
  const viewportMatrix = {
    a: scaleX,
    b: 0,
    c: 0,
    d: scaleY,
    e: content.x + offsetX - minX * scaleX,
    f: content.y + offsetY - minY * scaleY
  };
  const initialTransform = identityMatrix();
  const strokeScale = computeStrokeScale(viewportMatrix, initialTransform);
  const context = {
    painter,
    viewportMatrix,
    transform: initialTransform,
    strokeScale,
    environment
    // resource roots will be set below from the box customData if available
  };
  const defs = /* @__PURE__ */ new Map();
  collectDefs(root, defs);
  context.defs = defs;
  if (svgData.resourceBaseDir) {
    context.resourceBaseDir = svgData.resourceBaseDir;
  }
  if (svgData.assetRootDir) {
    context.assetRootDir = svgData.assetRootDir;
  }
  const baseStyle = createDefaultStyle();
  await renderNode2(root, baseStyle, context);
}
function collectDefs(node, map) {
  if (!node) return;
  const id = node.id;
  if (id && typeof id === "string") {
    map.set(id, node);
  }
  if (node.children && Array.isArray(node.children)) {
    for (const child of node.children) {
      collectDefs(child, map);
    }
  }
}
function extractSvgCustomData(box) {
  const raw = box.customData?.svg;
  if (!raw || typeof raw !== "object") {
    return null;
  }
  const candidate = raw;
  if (!candidate.root) {
    return null;
  }
  return {
    root: candidate.root,
    intrinsicWidth: resolvePositive(candidate.intrinsicWidth ?? 0),
    intrinsicHeight: resolvePositive(candidate.intrinsicHeight ?? 0),
    resourceBaseDir: candidate.resourceBaseDir,
    assetRootDir: candidate.assetRootDir
  };
}
async function renderNode2(node, style, context) {
  let workingContext = context;
  const nodeTransform = parseTransform(node.transform);
  if (nodeTransform) {
    const combined = multiplyMatrices(context.transform, nodeTransform);
    workingContext = {
      painter: context.painter,
      viewportMatrix: context.viewportMatrix,
      transform: combined,
      strokeScale: computeStrokeScale(context.viewportMatrix, combined)
    };
  }
  switch (node.type) {
    case "svg":
    case "g": {
      const nextStyle = deriveStyle(style, node);
      for (const child of node.children) {
        await renderNode2(child, nextStyle, workingContext);
      }
      return;
    }
    case "rect":
      return renderRect(node, deriveStyle(style, node), workingContext);
    case "circle":
      return renderCircle(node, deriveStyle(style, node), workingContext);
    case "ellipse":
      return renderEllipse(node, deriveStyle(style, node), workingContext);
    case "polygon":
      return renderPolygon(node, deriveStyle(style, node), workingContext);
    case "polyline":
      return renderPolyline(node, deriveStyle(style, node), workingContext);
    case "line":
      return renderLine(node, deriveStyle(style, node), workingContext);
    case "text":
      return renderText2(node, deriveStyle(style, node), workingContext);
    case "image":
      return await renderImage(node, deriveStyle(style, node), workingContext);
    case "path":
      return renderPath(node, deriveStyle(style, node), workingContext);
    default:
      return;
  }
}
function safeScale(value) {
  if (!Number.isFinite(value) || value === 0) {
    return 1;
  }
  return value;
}
function resolvePositive(value) {
  if (!Number.isFinite(value) || value <= 0) {
    return 1;
  }
  return value;
}
async function renderImage(node, _style, context) {
  const hrefAttr = node.href ?? node.attributes?.href ?? node.attributes?.["xlink:href"];
  if (!hrefAttr || typeof hrefAttr !== "string") {
    return;
  }
  let imageInfo;
  const imageService = ImageService.getInstance(context.environment);
  try {
    if (hrefAttr.startsWith("data:")) {
      const comma = hrefAttr.indexOf(",");
      if (comma < 0) return;
      const meta = hrefAttr.substring(5, comma);
      const isBase64 = meta.endsWith(";base64");
      const payload = hrefAttr.substring(comma + 1);
      const bytes = isBase64 ? decodeBase64ToUint8Array(payload) : new TextEncoder().encode(decodeURIComponent(payload));
      const copy = bytes.slice();
      imageInfo = await imageService.decodeImage(copy.buffer);
    } else if (/^https?:\/\//i.test(hrefAttr)) {
      console.debug("Skipping remote image in SVG:", hrefAttr);
      return;
    } else {
      const hasProcess = typeof process !== "undefined" && !!process.versions?.node;
      if (!hasProcess) {
        console.debug("Skipping local SVG image in non-Node environment:", hrefAttr);
        return;
      }
      const resolver = context.environment?.resolveLocal;
      if (!resolver) {
        console.debug("Skipping local SVG image (no resolver in environment):", hrefAttr);
        return;
      }
      const resolved = resolver(hrefAttr, context.resourceBaseDir ?? context.assetRootDir);
      imageInfo = await imageService.loadImage(resolved);
      node._resolvedHref = resolved;
    }
  } catch (err) {
    console.debug("Failed to load SVG image", hrefAttr, err instanceof Error ? err.message : err);
    return;
  }
  if (!imageInfo) return;
  const drawWidth = Number.isFinite(node.width) ? node.width : imageInfo.width;
  const drawHeight = Number.isFinite(node.height) ? node.height : imageInfo.height;
  const p1 = mapSvgPoint(Number(node.x ?? 0), Number(node.y ?? 0), context);
  const p2 = mapSvgPoint(Number(node.x ?? 0) + drawWidth, Number(node.y ?? 0) + drawHeight, context);
  if (!p1 || !p2) {
    return;
  }
  const rect = { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
  const imageRef = {
    src: node._resolvedHref ?? hrefAttr,
    width: imageInfo.width,
    height: imageInfo.height,
    format: imageInfo.format,
    channels: imageInfo.channels,
    bitsPerComponent: imageInfo.bitsPerChannel,
    data: imageInfo.data
  };
  try {
    context.painter.drawImage(imageRef, rect);
  } catch (err) {
    console.debug("Failed to draw image in SVG", hrefAttr, err instanceof Error ? err.message : err);
  }
}

// src/pdf/utils/background-tiles.ts
function intersectRects(a, b) {
  const x = Math.max(a.x, b.x);
  const y = Math.max(a.y, b.y);
  const right = Math.min(a.x + a.width, b.x + b.width);
  const bottom = Math.min(a.y + a.height, b.y + b.height);
  const width = right - x;
  const height = bottom - y;
  if (width <= 0 || height <= 0) {
    return null;
  }
  return { x, y, width, height };
}
function rectEquals(a, b, epsilon = 0.01) {
  if (!a || !b) {
    return false;
  }
  return Math.abs(a.x - b.x) < epsilon && Math.abs(a.y - b.y) < epsilon && Math.abs(a.width - b.width) < epsilon && Math.abs(a.height - b.height) < epsilon;
}
function computeBackgroundTileRects(tileRect, clipRect, repeat) {
  const width = tileRect.width;
  const height = tileRect.height;
  if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
    return [];
  }
  if (repeat === "no-repeat") {
    const single = intersectRects(tileRect, clipRect);
    return single ? [single] : [];
  }
  if (repeat === "space") {
    return computeSpacedTiles(tileRect, clipRect);
  }
  if (repeat === "round") {
    return computeRoundedTiles(tileRect, clipRect);
  }
  const repeatX = repeat === "repeat" || repeat === "repeat-x";
  const repeatY = repeat === "repeat" || repeat === "repeat-y";
  const result = [];
  const startIx = repeatX ? Math.floor((clipRect.x - tileRect.x) / width) : 0;
  const startIy = repeatY ? Math.floor((clipRect.y - tileRect.y) / height) : 0;
  const maxX = clipRect.x + clipRect.width;
  const maxY = clipRect.y + clipRect.height;
  for (let iy = startIy; ; iy++) {
    const ty = tileRect.y + iy * height;
    if (ty >= maxY) {
      break;
    }
    if (ty + height <= clipRect.y && !repeatY) {
      break;
    }
    for (let ix = startIx; ; ix++) {
      const tx = tileRect.x + ix * width;
      if (tx >= maxX) {
        break;
      }
      if (tx + width <= clipRect.x && !repeatX) {
        break;
      }
      const candidate = { x: tx, y: ty, width, height };
      const clipped = intersectRects(candidate, clipRect);
      if (clipped) {
        result.push(clipped);
      }
      if (!repeatX) {
        break;
      }
    }
    if (!repeatY) {
      break;
    }
  }
  return result;
}
function computeSpacedTiles(tileRect, clipRect) {
  const result = [];
  const tileWidth = tileRect.width;
  const tileHeight = tileRect.height;
  const availableWidth = clipRect.width;
  const availableHeight = clipRect.height;
  const tilesX = Math.max(1, Math.floor(availableWidth / tileWidth));
  const tilesY = Math.max(1, Math.floor(availableHeight / tileHeight));
  const spacingX = tilesX > 1 ? (availableWidth - tilesX * tileWidth) / (tilesX - 1) : 0;
  const spacingY = tilesY > 1 ? (availableHeight - tilesY * tileHeight) / (tilesY - 1) : 0;
  for (let iy = 0; iy < tilesY; iy++) {
    const ty = clipRect.y + iy * (tileHeight + spacingY);
    for (let ix = 0; ix < tilesX; ix++) {
      const tx = clipRect.x + ix * (tileWidth + spacingX);
      const candidate = {
        x: tx,
        y: ty,
        width: tileWidth,
        height: tileHeight
      };
      const clipped = intersectRects(candidate, clipRect);
      if (clipped) {
        result.push(clipped);
      }
    }
  }
  return result;
}
function computeRoundedTiles(tileRect, clipRect) {
  const result = [];
  const tileWidth = tileRect.width;
  const tileHeight = tileRect.height;
  const availableWidth = clipRect.width;
  const availableHeight = clipRect.height;
  const tilesX = Math.max(1, Math.round(availableWidth / tileWidth));
  const tilesY = Math.max(1, Math.round(availableHeight / tileHeight));
  const scaledWidth = availableWidth / tilesX;
  const scaledHeight = availableHeight / tilesY;
  for (let iy = 0; iy < tilesY; iy++) {
    const ty = clipRect.y + iy * scaledHeight;
    for (let ix = 0; ix < tilesX; ix++) {
      const tx = clipRect.x + ix * scaledWidth;
      const candidate = {
        x: tx,
        y: ty,
        width: scaledWidth,
        height: scaledHeight
      };
      const clipped = intersectRects(candidate, clipRect);
      if (clipped) {
        result.push(clipped);
      }
    }
  }
  return result;
}

// src/pdf/utils/border-dashes.ts
function computeDashForStyle(style, widthPx) {
  const w = Math.max(widthPx, 0);
  if (!Number.isFinite(w) || w <= 0) {
    return void 0;
  }
  const normalized = style.toLowerCase();
  if (normalized === "dashed") {
    const base = w;
    return { pattern: [3 * base, 3 * base], phase: 0 };
  }
  if (normalized === "dotted") {
    const base = w;
    return { pattern: [base, base], phase: 0 };
  }
  return void 0;
}
function computeBorderSideStrokes(borderBox, borderWidth, borderStyle, color, _radius) {
  const result = [];
  const outerX = borderBox.x;
  const outerY = borderBox.y;
  const outerW = borderBox.width;
  const outerH = borderBox.height;
  if (!Number.isFinite(outerW) || !Number.isFinite(outerH) || outerW <= 0 || outerH <= 0) {
    return result;
  }
  const topCenterY = outerY + borderWidth.top / 2;
  const bottomCenterY = outerY + outerH - borderWidth.bottom / 2;
  const leftCenterX = outerX + borderWidth.left / 2;
  const rightCenterX = outerX + outerW - borderWidth.right / 2;
  const pushSide = (side, width, style, p1, p2) => {
    if (!Number.isFinite(width) || width <= 0) {
      return;
    }
    const normalized = style.toLowerCase();
    if (normalized === "none") {
      return;
    }
    result.push({
      side,
      points: [p1, p2],
      color,
      lineWidth: width,
      dash: computeDashForStyle(normalized, width)
    });
  };
  pushSide(
    "top",
    borderWidth.top,
    borderStyle.top,
    { x: leftCenterX, y: topCenterY },
    { x: rightCenterX, y: topCenterY }
  );
  pushSide(
    "right",
    borderWidth.right,
    borderStyle.right,
    { x: rightCenterX, y: topCenterY },
    { x: rightCenterX, y: bottomCenterY }
  );
  pushSide(
    "bottom",
    borderWidth.bottom,
    borderStyle.bottom,
    { x: rightCenterX, y: bottomCenterY },
    { x: leftCenterX, y: bottomCenterY }
  );
  pushSide(
    "left",
    borderWidth.left,
    borderStyle.left,
    { x: leftCenterX, y: bottomCenterY },
    { x: leftCenterX, y: topCenterY }
  );
  return result;
}

// src/pdf/renderer/box-painter.ts
async function paintBoxAtomic(painter, box) {
  log("paint", "debug", `paintBoxAtomic: ${box.tagName} id:${box.id} opacity:${box.opacity}`, { id: box.id, opacity: box.opacity });
  const hasTransform = box.transform && (box.transform.b !== 0 || box.transform.c !== 0);
  const hasOpacity = box.opacity < 1;
  if (hasTransform) {
    painter.beginTransformScope(box.transform, box.borderBox);
  }
  if (hasOpacity) {
    painter.beginOpacityScope(box.opacity);
  }
  paintBoxShadows(painter, [box], false);
  const clipCommands = buildClipPathCommands(box.clipPath);
  const hasClip = !!clipCommands;
  if (hasClip && clipCommands) {
    painter.beginClipPath(clipCommands);
  }
  paintBackground(painter, box);
  paintBorder(painter, box);
  paintBoxShadows(painter, [box], true);
  if (box.kind === "svg" /* Svg */ || box.tagName === "svg" && box.customData?.svg) {
    await renderSvgBox(painter, box, painter.environment);
  } else if (box.image) {
    painter.drawImage(box.image, box.contentBox);
  }
  await paintText(painter, box);
  if (hasClip) {
    painter.endClipPath();
  }
  if (hasOpacity) {
    painter.endOpacityScope(box.opacity);
  }
  if (hasTransform) {
    painter.endTransformScope();
  }
}
function paintPageBackground(painter, color, widthPx, heightPx, offsetY) {
  if (!color) {
    return;
  }
  if (!Number.isFinite(widthPx) || widthPx <= 0 || !Number.isFinite(heightPx) || heightPx <= 0) {
    return;
  }
  const rect = { x: 0, y: offsetY, width: widthPx, height: heightPx };
  painter.fillRect(rect, color);
}
async function paintText(painter, box) {
  if (!box.textRuns || box.textRuns.length === 0) {
    return;
  }
  for (const run of box.textRuns) {
    if (box.textShadows && box.textShadows.length > 0) {
      run.textShadows = [...box.textShadows ?? [], ...run.textShadows ?? []];
    }
    await painter.drawTextRun(run);
  }
}
function paintBackground(painter, box) {
  const background = box.background;
  if (!background) {
    return;
  }
  const paintArea = determineBackgroundPaintArea(box);
  if (!paintArea) {
    return;
  }
  log("paint", "debug", `painting background z:${box.zIndexComputed ?? 0}`, {
    tagName: box.tagName,
    zIndex: box.zIndexComputed ?? 0,
    id: box.id,
    background: background.color ? "color" : background.gradient ? "gradient" : background.image ? "image" : "none"
  });
  if (background.color) {
    painter.fillRoundedRect(paintArea.rect, paintArea.radius, background.color);
  }
  if (background.gradient) {
    const gradient = background.gradient;
    const clipRect = paintArea.rect;
    const gradientRect = gradient.rect ?? clipRect;
    const repeatMode = gradient.repeat ?? "no-repeat";
    const tiles = computeBackgroundTileRects(gradientRect, clipRect, repeatMode);
    for (const tile of tiles) {
      const radius = rectEquals(tile, clipRect) || rectEquals(tile, gradient.originRect) ? paintArea.radius : zeroRadius();
      painter.fillRoundedRect(tile, radius, gradient.gradient);
    }
  }
  if (background.image) {
    paintBackgroundImageLayer(painter, background.image, paintArea.rect, paintArea.radius);
  }
}
function paintBackgroundImageLayer(painter, layer, clipRect, clipRadius) {
  if (!layer || !layer.rect) {
    return;
  }
  const repeatMode = layer.repeat ?? "repeat";
  const tiles = computeBackgroundTileRects(layer.rect, clipRect, repeatMode);
  for (const tile of tiles) {
    painter.drawBackgroundImage(layer.image, tile, clipRect, clipRadius);
  }
}
function paintBorder(painter, box) {
  const color = box.borderColor;
  if (!color) {
    return;
  }
  const { border } = box;
  if (!hasVisibleBorder(border)) {
    return;
  }
  const styles = box.borderStyle;
  const allSolid = !styles || styles.top === "solid" && styles.right === "solid" && styles.bottom === "solid" && styles.left === "solid";
  if (allSolid) {
    const outerRect = box.borderBox;
    const innerRect = {
      x: outerRect.x + border.left,
      y: outerRect.y + border.top,
      width: Math.max(outerRect.width - border.left - border.right, 0),
      height: Math.max(outerRect.height - border.top - border.bottom, 0)
    };
    const innerRadius = shrinkRadius(box.borderRadius, border.top, border.right, border.bottom, border.left);
    if (innerRect.width <= 0 || innerRect.height <= 0) {
      painter.fillRoundedRect(outerRect, box.borderRadius, color);
    } else {
      painter.fillRoundedRectDifference(outerRect, box.borderRadius, innerRect, innerRadius, color);
    }
    return;
  }
  const effectiveStyles = styles ?? {
    top: "solid",
    right: "solid",
    bottom: "solid",
    left: "solid"
  };
  const strokes = computeBorderSideStrokes(box.borderBox, border, effectiveStyles, color, box.borderRadius);
  for (const stroke of strokes) {
    painter.strokePolyline(stroke.points, stroke.color, {
      lineWidth: stroke.lineWidth,
      lineCap: "butt",
      lineJoin: "miter",
      dash: stroke.dash
    });
  }
}
function determineBackgroundPaintArea(box) {
  const rect = box.borderBox ?? box.paddingBox ?? box.contentBox;
  if (!rect) {
    return null;
  }
  if (rect === box.borderBox) {
    return { rect, radius: box.borderRadius };
  }
  let radius = shrinkRadius(box.borderRadius, box.border.top, box.border.right, box.border.bottom, box.border.left);
  if (rect === box.contentBox) {
    radius = shrinkRadius(radius, box.padding.top, box.padding.right, box.padding.bottom, box.padding.left);
  }
  return { rect, radius };
}
function hasVisibleBorder(border) {
  return border.top > 0 || border.right > 0 || border.bottom > 0 || border.left > 0;
}
function zeroRadius() {
  return {
    topLeft: { x: 0, y: 0 },
    topRight: { x: 0, y: 0 },
    bottomRight: { x: 0, y: 0 },
    bottomLeft: { x: 0, y: 0 }
  };
}
function buildClipPathCommands(clipPath) {
  if (!clipPath || clipPath.type !== "polygon" || clipPath.points.length < 3) {
    return null;
  }
  const [first, ...rest] = clipPath.points;
  const commands = [{ type: "moveTo", x: first.x, y: first.y }];
  for (const point of rest) {
    commands.push({ type: "lineTo", x: point.x, y: point.y });
  }
  commands.push({ type: "closePath" });
  return commands;
}

// src/pdf/header-footer-renderer.ts
async function renderHeaderFooterHtml(options) {
  const {
    html,
    css = "",
    widthPx,
    maxHeightPx,
    fontEmbedder,
    resourceBaseDir,
    assetRootDir,
    tokens,
    pageNumber = 1,
    totalPages = 1,
    environment
  } = options;
  const resolvedResourceBase = resourceBaseDir ?? "";
  const resolvedAssetRoot = assetRootDir ?? resolvedResourceBase;
  if (!html || !html.trim()) {
    return null;
  }
  let processedHtml = html;
  if (tokens) {
    processedHtml = applyPlaceholders(html, tokens, pageNumber, totalPages);
  }
  const normalizedHtml = normalizeHtmlFragment(processedHtml);
  const unitCtx = { viewport: { width: widthPx, height: maxHeightPx } };
  const units = makeUnitParsers(unitCtx);
  const { document } = parseHTML(normalizedHtml);
  const { styleRules: cssRules } = parseCss(css);
  const rootElement = document.body || document.documentElement;
  const baseParentStyle = new ComputedStyle();
  const rootFontSize = baseParentStyle.fontSize;
  let rootStyle = computeStyleForElement(rootElement, cssRules, baseParentStyle, units, rootFontSize);
  if (isInlineDisplay6(rootStyle.display)) {
    rootStyle.display = "block" /* Block */;
  }
  const rootLayout = new LayoutNode(rootStyle, [], { tagName: rootElement?.tagName?.toLowerCase() });
  const conversionContext = { resourceBaseDir: resolvedResourceBase, assetRootDir: resolvedAssetRoot, units, rootFontSize, environment };
  if (rootElement) {
    for (const child of Array.from(rootElement.childNodes)) {
      if (child.nodeType === child.ELEMENT_NODE) {
        const tagName19 = child.tagName.toLowerCase();
        if (tagName19 === "head" || tagName19 === "meta" || tagName19 === "title" || tagName19 === "link" || tagName19 === "script") {
          continue;
        }
      }
      const layoutChild = await convertDomNode(child, cssRules, rootStyle, conversionContext);
      if (layoutChild) rootLayout.appendChild(layoutChild);
    }
  }
  layoutTree(rootLayout, { width: widthPx, height: maxHeightPx }, fontEmbedder ?? null);
  const renderTree = buildRenderTree(rootLayout, {});
  const actualHeight = Math.min(calculateTreeHeight(renderTree.root), maxHeightPx);
  log("layout", "debug", "Header/footer rendered", {
    widthPx,
    maxHeightPx,
    actualHeight,
    hasContent: renderTree.root.children.length > 0
  });
  return {
    renderTree,
    heightPx: actualHeight,
    root: renderTree.root
  };
}
function cloneRenderBox(box) {
  const clonedRuns = box.textRuns.map((run) => ({
    ...run,
    lineMatrix: run.lineMatrix ? { ...run.lineMatrix } : void 0,
    decorations: run.decorations ? { ...run.decorations } : void 0,
    glyphs: run.glyphs ? { ...run.glyphs } : void 0
  }));
  const clonedBox = {
    ...box,
    contentBox: { ...box.contentBox },
    paddingBox: { ...box.paddingBox },
    borderBox: { ...box.borderBox },
    visualOverflow: { ...box.visualOverflow },
    padding: { ...box.padding },
    border: { ...box.border },
    borderRadius: {
      topLeft: { ...box.borderRadius.topLeft },
      topRight: { ...box.borderRadius.topRight },
      bottomRight: { ...box.borderRadius.bottomRight },
      bottomLeft: { ...box.borderRadius.bottomLeft }
    },
    background: box.background ? {
      color: box.background.color ? { ...box.background.color } : void 0,
      image: box.background.image ? {
        ...box.background.image,
        rect: { ...box.background.image.rect },
        originRect: { ...box.background.image.originRect }
      } : void 0,
      gradient: box.background.gradient ? {
        ...box.background.gradient,
        rect: { ...box.background.gradient.rect },
        originRect: { ...box.background.gradient.originRect }
      } : void 0
    } : { color: void 0 },
    textRuns: clonedRuns,
    markerRect: box.markerRect ? { ...box.markerRect } : void 0,
    boxShadows: box.boxShadows.map((s) => ({ ...s, color: { ...s.color } })),
    links: box.links.map((link) => ({
      rect: { ...link.rect },
      target: { ...link.target }
    })),
    children: box.children.map((child) => cloneRenderBox(child))
  };
  return clonedBox;
}
async function paintRenderedHeaderFooter(painter, rendered, xOffsetPx, yOffsetPx, fontRegistry, pageOffsetY) {
  const clonedRoot = cloneRenderBox(rendered.root);
  const fontResolver = new FontRegistryResolver(fontRegistry);
  await enrichTreeWithGlyphRuns(clonedRoot, fontResolver);
  offsetRenderTree(clonedRoot, xOffsetPx, yOffsetPx - pageOffsetY, false);
  const stack = [clonedRoot];
  while (stack.length > 0) {
    const box = stack.pop();
    await paintBoxAtomic(painter, box);
    for (let i = box.children.length - 1; i >= 0; i--) {
      stack.push(box.children[i]);
    }
  }
}
function normalizeHtmlFragment(html) {
  const hasHtmlTag = /<\s*html[\s>]/i.test(html);
  if (hasHtmlTag) {
    return html;
  }
  return `<!doctype html><html><head></head><body>${html}</body></html>`;
}
function isInlineDisplay6(display) {
  return display === "inline" /* Inline */ || display === "inline-block" /* InlineBlock */ || display === "inline-flex" /* InlineFlex */ || display === "inline-grid" /* InlineGrid */ || display === "inline-table" /* InlineTable */;
}
function calculateTreeHeight(root) {
  let maxBottom = 0;
  function traverse3(box) {
    const bottom = box.borderBox.y + box.borderBox.height;
    maxBottom = Math.max(maxBottom, bottom);
    for (const child of box.children) {
      traverse3(child);
    }
  }
  traverse3(root);
  return maxBottom;
}
async function enrichTreeWithGlyphRuns(root, fontResolver) {
  async function enrichRun(run) {
    if (run.glyphs) {
      return;
    }
    try {
      const font = await fontResolver.resolve(run.fontFamily, run.fontWeight, run.fontStyle);
      const letterSpacing = run.letterSpacing ?? 0;
      const glyphRun = computeGlyphRun(font, run.text, run.fontSize, letterSpacing);
      applyWordSpacingToGlyphRun(glyphRun, run.text, run.wordSpacing);
      run.glyphs = glyphRun;
    } catch {
    }
  }
  async function traverse3(box) {
    if (box.textRuns && box.textRuns.length > 0) {
      for (const run of box.textRuns) {
        await enrichRun(run);
      }
    }
    for (const child of box.children) {
      await traverse3(child);
    }
  }
  await traverse3(root);
}

// src/pdf/header-footer-painter.ts
async function paintHeaderFooter(painter, header, footer, tokens, pageIndex, totalPages, baseOptions = { fontSizePt: 10 }, under = false, context) {
  if (context) {
    log("layout", "debug", "Using HTML rendering path for headers/footers", {
      hasHeader: !!header?.content,
      hasFooter: !!footer?.content,
      margins: context.margins
    });
    await paintHeaderFooterWithContext(
      painter,
      header,
      footer,
      tokens,
      pageIndex,
      totalPages,
      context
    );
    return;
  }
  log("layout", "debug", "Using legacy text rendering for headers/footers (no context)");
  await paintHeaderFooterLegacy(painter, header, footer, tokens, pageIndex, totalPages, baseOptions);
}
async function paintHeaderFooterWithContext(painter, header, footer, tokens, pageIndex, totalPages, context) {
  const { margins, pageWidthPx, pageHeightPx, fontRegistry, pageOffsetY, css } = context;
  const contentWidthPx = pageWidthPx - margins.left - margins.right;
  log("layout", "debug", "paintHeaderFooterWithContext", {
    headerContent: header?.content ? String(header.content).slice(0, 100) : "none",
    footerContent: footer?.content ? String(footer.content).slice(0, 100) : "none",
    contentWidthPx,
    pageWidthPx,
    pageHeightPx
  });
  if (header?.content) {
    const headerHtml = stringify(header.content);
    log("layout", "debug", "Rendering header HTML", { headerHtml: headerHtml.slice(0, 200) });
    if (headerHtml) {
      try {
        const rendered = await renderHeaderFooterHtml({
          html: headerHtml,
          css,
          widthPx: contentWidthPx,
          maxHeightPx: header.maxHeightPx,
          tokens,
          pageNumber: pageIndex,
          totalPages,
          environment: context.environment
        });
        if (rendered) {
          log("layout", "debug", "Header rendered successfully", { heightPx: rendered.heightPx });
          await paintRenderedHeaderFooter(
            painter,
            rendered,
            margins.left,
            margins.top,
            fontRegistry,
            pageOffsetY
          );
        }
      } catch (err) {
        log("layout", "warn", "Failed to render header HTML", { error: err });
      }
    }
  }
  if (footer?.content) {
    const footerHtml = stringify(footer.content);
    if (footerHtml) {
      try {
        const rendered = await renderHeaderFooterHtml({
          html: footerHtml,
          css,
          widthPx: contentWidthPx,
          maxHeightPx: footer.maxHeightPx,
          tokens,
          pageNumber: pageIndex,
          totalPages,
          environment: context.environment
        });
        if (rendered) {
          const footerY = pageHeightPx - margins.bottom - footer.maxHeightPx;
          await paintRenderedHeaderFooter(
            painter,
            rendered,
            margins.left,
            footerY,
            fontRegistry,
            pageOffsetY
          );
        }
      } catch (err) {
        log("layout", "warn", "Failed to render footer HTML", { error: err });
      }
    }
  }
}
async function paintHeaderFooterLegacy(painter, header, footer, tokens, pageIndex, totalPages, baseOptions) {
  const headerText = header?.content ? stringify(header.content) : void 0;
  const footerText = footer?.content ? stringify(footer.content) : void 0;
  if (headerText) {
    const rendered = applyPlaceholders(headerText, tokens, pageIndex, totalPages);
    await painter.drawText(rendered, 16, header?.maxHeightPx ?? 24, { ...baseOptions, absolute: true });
  }
  if (footerText) {
    const rendered = applyPlaceholders(footerText, tokens, pageIndex, totalPages);
    const yPx = painter.pageHeightPx ? painter.pageHeightPx - ((footer?.maxHeightPx ?? 24) + 16) : 16;
    await painter.drawText(rendered, 16, yPx, { ...baseOptions, absolute: true });
  }
}
function stringify(content) {
  if (content == null) {
    return "";
  }
  if (typeof content === "string") {
    return content;
  }
  if (typeof content === "function") {
    return String(content());
  }
  return JSON.stringify(content);
}

// src/pdf/stacking/build-stacking-contexts.ts
function getStackingFlags(box) {
  const isPositioned = box.positioning.type !== "normal";
  const raw = box.zIndexComputed;
  const hasNumericZ = typeof raw === "number" && Number.isFinite(raw);
  const zIndex = hasNumericZ ? raw : "auto";
  const establishesContext = isPositioned && hasNumericZ;
  return { isPositioned, zIndex, establishesContext };
}
function buildStackingContexts(root) {
  const contexts = /* @__PURE__ */ new Map();
  const rootContextId = makeContextId(root, 0);
  const rootContext = {
    id: rootContextId,
    box: root,
    parentId: null,
    childContextIds: []
  };
  contexts.set(rootContextId, rootContext);
  traverse(root, rootContextId, 1, contexts);
  return { rootContextId, contexts };
}
function traverse(box, currentContextId, counterStart, contexts) {
  let counter = counterStart;
  for (const child of box.children) {
    const flags = getStackingFlags(child);
    if (flags.establishesContext) {
      const ctxId = makeContextId(child, counter++);
      const node = {
        id: ctxId,
        box: child,
        parentId: currentContextId,
        childContextIds: []
      };
      contexts.set(ctxId, node);
      const parent = contexts.get(currentContextId);
      if (parent) {
        parent.childContextIds.push(ctxId);
      }
      counter = traverse(child, ctxId, counter, contexts);
    } else {
      counter = traverse(child, currentContextId, counter, contexts);
    }
  }
  return counter;
}
function makeContextId(box, suffix) {
  return `${box.id || "ctx"}-${suffix}`;
}

// src/pdf/stacking/resolve-paint-order.ts
function resolvePaintOrder(root) {
  const { rootContextId, contexts } = buildStackingContexts(root);
  const steps = [];
  resolveContextPaintOrder(rootContextId, contexts, steps);
  return steps.map((s) => s.box);
}
function resolveContextPaintOrder(contextId, contexts, out) {
  const context = contexts.get(contextId);
  if (!context) return;
  const rootBox = context.box;
  out.push({ box: rootBox });
  const descendants = [];
  collectDescendantsInContext(rootBox, contextId, contexts, descendants);
  const negativeZ = [];
  const normalFlowAutoZ = [];
  const positionedNonNegative = [];
  for (const box of descendants) {
    const flags = getStackingFlags(box);
    if (flags.isPositioned && flags.zIndex !== "auto") {
      const z = flags.zIndex;
      if (z < 0) {
        negativeZ.push(box);
      } else {
        positionedNonNegative.push(box);
      }
    } else {
      normalFlowAutoZ.push(box);
    }
  }
  negativeZ.sort((a, b) => {
    const az = getStackingFlags(a).zIndex ?? 0;
    const bz = getStackingFlags(b).zIndex ?? 0;
    if (az !== bz) return az - bz;
    return 0;
  });
  for (const box of negativeZ) {
    appendBoxOrContext(box, contextId, contexts, out);
  }
  for (const box of normalFlowAutoZ) {
    appendBoxOrContext(box, contextId, contexts, out);
  }
  positionedNonNegative.sort((a, b) => {
    const az = getStackingFlags(a).zIndex ?? 0;
    const bz = getStackingFlags(b).zIndex ?? 0;
    if (az !== bz) return az - bz;
    return 0;
  });
  for (const box of positionedNonNegative) {
    appendBoxOrContext(box, contextId, contexts, out);
  }
}
function appendBoxOrContext(box, parentContextId, contexts, out) {
  const nested = findContextByBox(box, parentContextId, contexts);
  if (nested) {
    resolveContextPaintOrder(nested.id, contexts, out);
  } else {
    out.push({ box });
  }
}
function collectDescendantsInContext(box, contextId, contexts, out) {
  for (const child of box.children) {
    const childCtx = findContextByBox(child, null, contexts);
    if (childCtx && childCtx.id !== contextId) {
      out.push(child);
      continue;
    }
    out.push(child);
    collectDescendantsInContext(child, contextId, contexts, out);
  }
}
function findContextByBox(box, parentContextId, contexts) {
  for (const ctx of contexts.values()) {
    if (ctx.box === box && (parentContextId === null || ctx.parentId === parentContextId)) {
      return ctx;
    }
  }
  return void 0;
}

// src/pdf/pagination.ts
function paginateTree(root, options) {
  const pageHeight = Number.isFinite(options.pageHeight) && options.pageHeight > 0 ? options.pageHeight : 1;
  const paintOrderAll = resolvePaintOrder(root);
  const flowOrderAll = collectFlowOrder(root);
  const positionedAll = collectPositionedLayers(root);
  const linksAll = collectLinks(root);
  const documentHeight = resolveDocumentHeight(paintOrderAll);
  const totalPages = Math.max(1, Math.ceil(documentHeight / pageHeight));
  const pages = [];
  for (let index = 0; index < totalPages; index++) {
    const pageTop = index * pageHeight;
    const pageBottom = pageTop + pageHeight;
    const paintOrder = paintOrderAll.filter((box) => intersectsVerticalSlice(box, pageTop, pageBottom));
    const flowContentOrder = flowOrderAll.filter((box) => intersectsVerticalSlice(box, pageTop, pageBottom));
    const positionedLayersSortedByZ = filterPositionedLayers(positionedAll, pageTop, pageBottom);
    const links = filterLinks(linksAll, pageTop, pageBottom, pageTop);
    const decorations = [];
    pages.push({
      paintOrder,
      floatLayerOrder: [],
      flowContentOrder,
      positionedLayersSortedByZ,
      decorations,
      links,
      pageOffsetY: pageTop
    });
  }
  return pages;
}
function collectFlowOrder(root) {
  const result = [];
  dfs(root, (box) => {
    result.push(box);
    return box.positioning.type === "normal";
  });
  return result;
}
function collectPositionedLayers(_root) {
  return [];
}
function collectLinks(root) {
  const links = [];
  dfs(root, (box) => {
    links.push(...box.links);
    return true;
  });
  return links;
}
function filterPositionedLayers(layers, top, bottom) {
  const result = [];
  for (const layer of layers) {
    const boxes = layer.boxes.filter((box) => intersectsVerticalSlice(box, top, bottom));
    if (boxes.length > 0) {
      result.push({ z: layer.z, boxes });
    }
  }
  return result;
}
function filterLinks(links, top, bottom, offset) {
  const result = [];
  for (const link of links) {
    const linkTop = link.rect.y;
    const linkBottom = link.rect.y + Math.max(link.rect.height, 0);
    if (linkBottom <= top || linkTop >= bottom) {
      continue;
    }
    result.push({
      rect: {
        x: link.rect.x,
        y: link.rect.y - offset,
        width: link.rect.width,
        height: link.rect.height
      },
      target: { ...link.target }
    });
  }
  return result;
}
function resolveDocumentHeight(boxes) {
  let maxBottom = 0;
  for (const box of boxes) {
    const span = getBoxVerticalSpan(box);
    maxBottom = Math.max(maxBottom, span.bottom);
  }
  return maxBottom;
}
function intersectsVerticalSlice(box, sliceTop, sliceBottom) {
  const span = getBoxVerticalSpan(box);
  return span.bottom > sliceTop && span.top < sliceBottom;
}
function getBoxVerticalSpan(box) {
  const referenceRect = box.visualOverflow ?? box.borderBox ?? box.contentBox;
  let top = referenceRect ? referenceRect.y : box.contentBox.y;
  let bottom = referenceRect ? referenceRect.y + Math.max(referenceRect.height, 0) : box.contentBox.y + Math.max(box.contentBox.height, 0);
  if (!Number.isFinite(top)) {
    top = 0;
  }
  if (!Number.isFinite(bottom)) {
    bottom = top;
  }
  if (box.textRuns.length > 0) {
    for (const run of box.textRuns) {
      const baseline = run.lineMatrix?.f ?? 0;
      const ascent = run.fontSize;
      const descent = Math.max(run.fontSize * 0.2, 0);
      top = Math.min(top, baseline - ascent);
      bottom = Math.max(bottom, baseline + descent);
    }
  }
  return { top, bottom };
}
function dfs(node, visitor) {
  const descend = visitor(node);
  if (!descend) {
    return;
  }
  for (const child of node.children) {
    dfs(child, visitor);
  }
}

// src/text/text.ts
function needsUnicode(text) {
  for (const ch of Array.from(text)) {
    const cp = ch.codePointAt(0);
    if (!UNICODE_TO_WIN_ANSI.has(cp)) return true;
  }
  return false;
}

// src/pdf/font/font-subset.ts
function createPdfFontSubset(options) {
  const { baseName, fontMetrics, fontProgram, usedGlyphIds } = options;
  const encoding = options.encoding ?? "identity";
  const glyphIds = Array.from(usedGlyphIds).sort((a, b) => a - b);
  if (!glyphIds.includes(0)) {
    glyphIds.unshift(0);
  }
  const gidToCharCode = /* @__PURE__ */ new Map();
  if (encoding === "identity") {
    for (const gid of glyphIds) {
      gidToCharCode.set(gid, gid);
    }
  } else {
    for (let i = 0; i < glyphIds.length; i++) {
      gidToCharCode.set(glyphIds[i], i);
    }
  }
  const firstChar = encoding === "identity" ? Math.min(...glyphIds) : 0;
  const lastChar = encoding === "identity" ? Math.max(...glyphIds) : glyphIds.length - 1;
  const unitsPerEm = fontMetrics.metrics.unitsPerEm;
  const widths = [];
  if (encoding === "identity") {
    for (const gid of glyphIds) {
      const glyphMetric = fontMetrics.glyphMetrics.get(gid);
      const advanceWidth = glyphMetric?.advanceWidth ?? 0;
      const pdfWidth = Math.round(advanceWidth / unitsPerEm * 1e3);
      widths.push(pdfWidth);
    }
  } else {
    for (const gid of glyphIds) {
      const glyphMetric = fontMetrics.glyphMetrics.get(gid);
      const advanceWidth = glyphMetric?.advanceWidth ?? 0;
      const pdfWidth = Math.round(advanceWidth / unitsPerEm * 1e3);
      widths.push(pdfWidth);
    }
  }
  const cmapEntries = [];
  const unicodeMap = fontMetrics.cmap.unicodeMap;
  for (const gid of glyphIds) {
    let unicode;
    for (const [cp, mappedGid] of unicodeMap.entries()) {
      if (mappedGid === gid) {
        unicode = cp;
        break;
      }
    }
    if (unicode !== void 0) {
      const cid = gidToCharCode.get(gid);
      if (cid !== void 0) {
        cmapEntries.push({ gid: cid, unicode });
      }
    }
  }
  const toUnicodeCMap = createToUnicodeCMapText(cmapEntries);
  const fontFile = extractFontFile(fontProgram);
  const encodeGlyph = (gid) => {
    const charCode = gidToCharCode.get(gid);
    if (charCode === void 0) {
      throw new Error(`Glyph ID ${gid} not found in subset`);
    }
    return charCode;
  };
  return {
    name: `/${baseName}`,
    firstChar,
    lastChar,
    widths,
    toUnicodeCMap,
    fontFile,
    encodeGlyph,
    glyphIds
  };
}
function extractFontFile(fontProgram) {
  if (fontProgram.getRawTableData) {
    return buildTtfFromTables(fontProgram);
  }
  console.warn("Font subsetting not fully implemented; no raw table data available");
  return new Uint8Array(0);
}
function buildTtfFromTables(fontProgram) {
  const tableTags = [
    "head",
    "hhea",
    "maxp",
    "OS/2",
    "hmtx",
    "cmap",
    "loca",
    "glyf",
    "name",
    "post",
    "cvt ",
    "fpgm",
    "prep"
  ];
  const tables = /* @__PURE__ */ new Map();
  for (const tag of tableTags) {
    const data = fontProgram.getRawTableData(tag);
    if (data && data.length > 0) {
      tables.set(tag, data);
    }
  }
  if (tables.size === 0) {
    console.warn("No TTF tables available for font subsetting");
    return new Uint8Array(0);
  }
  const numTables = tables.size;
  const searchRange = Math.pow(2, Math.floor(Math.log2(numTables))) * 16;
  const entrySelector = Math.floor(Math.log2(numTables));
  const rangeShift = numTables * 16 - searchRange;
  const headerSize = 12;
  const directorySize = numTables * 16;
  let dataSize = 0;
  for (const data of tables.values()) {
    dataSize += data.length + (4 - data.length % 4) % 4;
  }
  const totalSize = headerSize + directorySize + dataSize;
  const buffer = new ArrayBuffer(totalSize);
  const view = new DataView(buffer);
  const bytes = new Uint8Array(buffer);
  view.setUint32(0, 65536, false);
  view.setUint16(4, numTables, false);
  view.setUint16(6, searchRange, false);
  view.setUint16(8, entrySelector, false);
  view.setUint16(10, rangeShift, false);
  let directoryOffset = 12;
  let dataOffset = headerSize + directorySize;
  for (const [tag, data] of tables) {
    const tagBytes = new TextEncoder().encode(tag.padEnd(4));
    bytes.set(tagBytes.slice(0, 4), directoryOffset);
    const checksum = calculateTableChecksum2(data);
    view.setUint32(directoryOffset + 4, checksum, false);
    view.setUint32(directoryOffset + 8, dataOffset, false);
    view.setUint32(directoryOffset + 12, data.length, false);
    bytes.set(data, dataOffset);
    const paddedLength = data.length + (4 - data.length % 4) % 4;
    directoryOffset += 16;
    dataOffset += paddedLength;
  }
  updateHeadChecksum(bytes, view, tables);
  return bytes;
}
function calculateTableChecksum2(data) {
  let sum = 0;
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  const nLongs = Math.floor(data.length / 4);
  for (let i = 0; i < nLongs; i++) {
    sum = sum + view.getUint32(i * 4, false) >>> 0;
  }
  const remaining = data.length % 4;
  if (remaining > 0) {
    let last = 0;
    for (let i = 0; i < remaining; i++) {
      last = last << 8 | data[nLongs * 4 + i];
    }
    last = last << (4 - remaining) * 8;
    sum = sum + last >>> 0;
  }
  return sum >>> 0;
}
function updateHeadChecksum(bytes, view, tables) {
  const numTables = tables.size;
  let headOffset = -1;
  for (let i = 0; i < numTables; i++) {
    const dirOffset = 12 + i * 16;
    const tag = new TextDecoder().decode(bytes.slice(dirOffset, dirOffset + 4));
    if (tag.trim() === "head") {
      headOffset = view.getUint32(dirOffset + 8, false);
      break;
    }
  }
  if (headOffset === -1) return;
  view.setUint32(headOffset + 8, 0, false);
  const fileChecksum = calculateTableChecksum2(bytes);
  const adjustment = 2981146554 - fileChecksum >>> 0;
  view.setUint32(headOffset + 8, adjustment, false);
}

// src/pdf/font-subset/font-registry.ts
var PdfFontRegistry = class {
  constructor(encoding = "identity") {
    this.encoding = encoding;
    // Map from font key to set of used glyph IDs
    this.glyphUsage = /* @__PURE__ */ new Map();
    // Map from font key to PdfFontHandle (lazily created)
    this.fonts = /* @__PURE__ */ new Map();
    // Counter for generating unique font resource names
    this.fontCounter = 0;
  }
  /**
   * Generates a stable key for a UnifiedFont.
   * Uses CSS metadata if available, otherwise falls back to a generic key.
   */
  fontKey(font) {
    if (font.css) {
      const { family, weight, style } = font.css;
      return `${family}|${weight}|${style}`;
    }
    const { unitsPerEm, ascender } = font.metrics.metrics;
    return `_fallback_${unitsPerEm}_${ascender}`;
  }
  /**
   * Registers a GlyphRun, collecting its glyph IDs for later subsetting.
   */
  registerGlyphRun(run) {
    const key2 = this.fontKey(run.font);
    let usage = this.glyphUsage.get(key2);
    if (!usage) {
      usage = /* @__PURE__ */ new Set();
      this.glyphUsage.set(key2, usage);
    }
    for (const gid of run.glyphIds) {
      usage.add(gid);
    }
  }
  /**
   * Ensures a font subset exists for the given UnifiedFont.
   * Creates the subset lazily if it doesn't exist yet.
   */
  ensureSubsetFor(font) {
    const key2 = this.fontKey(font);
    const usedGlyphIds = this.glyphUsage.get(key2) ?? /* @__PURE__ */ new Set([0]);
    if (!this.glyphUsage.has(key2)) {
      this.glyphUsage.set(key2, usedGlyphIds);
    }
    usedGlyphIds.add(0);
    const existing = this.fonts.get(key2);
    if (existing && this.subsetCoversGlyphs(existing.subset, usedGlyphIds)) {
      return existing;
    }
    const existingBaseName = existing?.subset.name.startsWith("/") ? existing.subset.name.slice(1) : void 0;
    const baseName = existingBaseName ?? `F${++this.fontCounter}`;
    const subset = createPdfFontSubset({
      baseName,
      fontMetrics: font.metrics,
      fontProgram: font.program,
      usedGlyphIds,
      encoding: this.encoding
    });
    const handle = {
      subset,
      unifiedFont: font
    };
    this.fonts.set(key2, handle);
    return handle;
  }
  /**
   * Checks whether an existing subset already contains every glyph we've seen.
   */
  subsetCoversGlyphs(subset, glyphs) {
    const inSubset = new Set(subset.glyphIds);
    for (const gid of glyphs) {
      if (!inSubset.has(gid)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns all font subsets created so far.
   */
  getAllSubsets() {
    return this.fonts.values();
  }
  /**
   * Returns the total number of fonts registered.
   */
  getFontCount() {
    return this.fonts.size;
  }
};

// src/css/font-face-parser.ts
function parseFontFaces(stylesheets) {
  const facesByFamily = /* @__PURE__ */ new Map();
  for (const face of stylesheets.fontFaces ?? []) {
    const family = normalizeToken(face.family);
    if (!family) {
      continue;
    }
    const list = facesByFamily.get(family) ?? [];
    list.push(face);
    facesByFamily.set(family, list);
  }
  return { facesByFamily };
}
function selectFaceForWeight(faces, requestedWeight) {
  let bestFace;
  let smallestDiff = Number.POSITIVE_INFINITY;
  for (const face of faces) {
    const faceWeight = parseFaceWeight(face.weight, requestedWeight);
    if (faceWeight === null) {
      if (!bestFace) {
        bestFace = face;
      }
      continue;
    }
    const diff = Math.abs(faceWeight - requestedWeight);
    if (diff < smallestDiff) {
      smallestDiff = diff;
      bestFace = face;
    }
  }
  return bestFace ?? faces[0];
}
function parseFamilyList(value) {
  if (!value) {
    return [];
  }
  return value.split(",").map((token) => stripQuotes2(token.trim())).filter((token) => token.length > 0);
}
function isItalicStyle(style) {
  if (!style) {
    return false;
  }
  const normalized = style.toLowerCase();
  return normalized === "italic" || normalized === "oblique";
}
function normalizeToken(value) {
  if (!value) {
    return "";
  }
  return stripQuotes2(value).trim().toLowerCase();
}
function stripQuotes2(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  return value;
}
function baseFontFromFace(face, aliases2) {
  const localName = extractLocalSource(face.src);
  if (localName) {
    const normalized = normalizeToken(localName);
    const alias = aliases2.get(normalized);
    if (alias) {
      return alias;
    }
  }
  const familyAlias = aliases2.get(normalizeToken(face.family));
  if (familyAlias) {
    return familyAlias;
  }
  return null;
}
function extractLocalSource(srcList) {
  for (const src of srcList) {
    const match = src.match(/local\(([^)]+)\)/i);
    if (match) {
      return stripQuotes2(match[1].trim());
    }
  }
  return null;
}
function parseFaceWeight(value, fallback) {
  if (typeof value === "number") {
    return normalizeFontWeight(value);
  }
  if (typeof value !== "string") {
    return null;
  }
  const parts = value.split(/\s+/).filter(Boolean);
  if (parts.length > 1) {
    const parsedWeights = parts.map((part) => parseFontWeightValue(part, fallback)).filter((weight) => weight !== void 0).map((weight) => normalizeFontWeight(weight));
    if (parsedWeights.length === 0) {
      return null;
    }
    return parsedWeights.reduce((closest, candidate) => {
      const candidateDiff = Math.abs(candidate - fallback);
      const closestDiff = Math.abs(closest - fallback);
      return candidateDiff < closestDiff ? candidate : closest;
    }, parsedWeights[0]);
  }
  const parsed = parseFontWeightValue(value, fallback);
  if (parsed === void 0) {
    return null;
  }
  return normalizeFontWeight(parsed);
}

// src/pdf/font/resolvers/weight-style-applicator.ts
function applyWeightToBaseFont(baseFont, weight, style) {
  const wantsItalic = isItalicStyle(style);
  const wantsBold = isBoldFontWeight(weight);
  const base14Family = detectBase14Family(baseFont);
  if (base14Family) {
    const variants = BASE14_FAMILY_VARIANTS[base14Family];
    const currentVariant = classifyBase14Variant(baseFont);
    const targetVariant = wantsBold && wantsItalic ? "boldItalic" : wantsBold ? "bold" : wantsItalic ? "italic" : "normal";
    if (currentVariant === targetVariant) {
      return baseFont;
    }
    return variants[targetVariant];
  }
  let result = baseFont;
  if (wantsItalic && !/-italic$/i.test(result) && !/-oblique$/i.test(result)) {
    result = `${result}-Italic`;
  }
  if (wantsBold && !/-bold$/i.test(result)) {
    if (/-italic$/i.test(result)) {
      result = result.replace(/-italic$/i, "");
    } else if (/-oblique$/i.test(result)) {
      result = result.replace(/-oblique$/i, "");
    }
    return wantsItalic ? `${result}-BoldItalic` : `${result}-Bold`;
  }
  return result;
}

// src/pdf/font/resolvers/family-resolver.ts
function buildAliasedFamilyStack(family, defaultStack = []) {
  const baseStack = family ? parseFamilyList(family) : defaultStack;
  return baseStack.flatMap((f) => {
    const normalized = normalizeToken(f);
    const alias = BASE_FONT_ALIASES.get(normalized);
    const generic = GENERIC_FAMILIES.get(normalized);
    return [f, alias, generic].filter((x) => !!x);
  });
}

// src/pdf/font/resolvers/base-font-mapper.ts
var DEFAULT_FONT = "Times New Roman";
function resolveBaseFont(family, weight, style, allowEmbeddedAlias, facesByFamily) {
  const faces = facesByFamily.get(family);
  if (faces && faces.length > 0) {
    const selectedFace = selectFaceForWeight(faces, weight);
    if (selectedFace) {
      const base = baseFontFromFace(selectedFace, BASE_FONT_ALIASES);
      if (base) {
        return applyWeightToBaseFont(base, weight, style);
      }
    }
  }
  if (!allowEmbeddedAlias) {
    const base14Fallback = BASE14_FALLBACKS.get(family);
    if (base14Fallback) {
      return applyWeightToBaseFont(base14Fallback, weight, style);
    }
  }
  const alias = BASE_FONT_ALIASES.get(family);
  if (alias) {
    const isAliasBase14 = BASE14_VARIANT_LOOKUP.has(alias.toLowerCase());
    if (allowEmbeddedAlias || isAliasBase14) {
      return applyWeightToBaseFont(alias, weight, style);
    }
  }
  const generic = GENERIC_FAMILIES.get(family);
  if (generic) {
    return applyWeightToBaseFont(generic, weight, style);
  }
  return applyWeightToBaseFont(DEFAULT_FONT, weight, style);
}

// src/pdf/font/managers/font-resource-manager.ts
var FontResourceManager = class {
  constructor(doc) {
    this.doc = doc;
    this.fontsByFamilyWeight = /* @__PURE__ */ new Map();
    this.fontsByBaseFont = /* @__PURE__ */ new Map();
    this.aliasCounter = 1;
  }
  /**
   * Retrieve a cached FontResource by its unique key.
   */
  getCached(key2) {
    return this.fontsByFamilyWeight.get(key2);
  }
  /**
   * Cache a FontResource by its unique key.
   */
  setCached(key2, resource) {
    this.fontsByFamilyWeight.set(key2, resource);
  }
  /**
   * Ensure a FontResource exists for a given base font name.
   * 
   * If the resource already exists in the cache, it is returned.
   * Otherwise, a new standard font resource is registered with the PDF document.
   */
  ensureBaseFontResource(baseFont) {
    const existing = this.fontsByBaseFont.get(baseFont);
    if (existing) {
      return existing;
    }
    const ref = this.doc.registerStandardFont(baseFont);
    const alias = `F${this.aliasCounter++}`;
    const BASE14_FAMILIES = /* @__PURE__ */ new Set([
      "Helvetica",
      "Helvetica-Bold",
      "Helvetica-Oblique",
      "Helvetica-BoldOblique",
      "Times-Roman",
      "Times-Bold",
      "Times-Italic",
      "Times-BoldItalic",
      "Courier",
      "Courier-Bold",
      "Courier-Oblique",
      "Courier-BoldOblique",
      "Symbol",
      "ZapfDingbats"
    ]);
    const isBase14 = BASE14_FAMILIES.has(baseFont);
    const resource = { baseFont, resourceName: alias, ref, isBase14 };
    this.fontsByBaseFont.set(baseFont, resource);
    return resource;
  }
};

// src/pdf/font/managers/subset-resource-manager.ts
var DEFAULT_STEM_V = 80;
var SubsetResourceManager = class {
  constructor(doc) {
    this.doc = doc;
    this.glyphSubsetRegistry = new PdfFontRegistry();
    this.subsetResources = /* @__PURE__ */ new Map();
  }
  registerGlyphRun(glyphRun) {
    this.glyphSubsetRegistry.registerGlyphRun(glyphRun);
  }
  ensureSubsetForGlyphRun(glyphRun, font) {
    this.registerGlyphRun(glyphRun);
    const handle = this.glyphSubsetRegistry.ensureSubsetFor(glyphRun.font);
    const baseAlias = handle.subset.name.startsWith("/") ? handle.subset.name.slice(1) : handle.subset.name;
    const alias = `GS${baseAlias}`;
    const existing = this.subsetResources.get(alias);
    const subsetForUse = { ...handle.subset, name: `/${alias}` };
    if (existing && this.subsetMatches(existing.subset, subsetForUse)) {
      return existing;
    }
    const ref = this.materializeSubsetFont(subsetForUse, font, handle.unifiedFont);
    const resource = { alias, subset: subsetForUse, ref, font };
    this.subsetResources.set(alias, resource);
    return resource;
  }
  subsetMatches(current2, next) {
    if (current2.glyphIds.length !== next.glyphIds.length) {
      return false;
    }
    for (let i = 0; i < current2.glyphIds.length; i++) {
      if (current2.glyphIds[i] !== next.glyphIds[i]) {
        return false;
      }
    }
    return true;
  }
  materializeSubsetFont(subset, font, unifiedFont) {
    const metrics = font.metrics ?? unifiedFont.metrics;
    if (!metrics) {
      return font.ref;
    }
    const unitsPerEm = metrics.metrics.unitsPerEm;
    const scaleTo1000 = (v) => Math.round(v / unitsPerEm * 1e3);
    const fontBBox = metrics.headBBox ? [
      scaleTo1000(metrics.headBBox[0]),
      scaleTo1000(metrics.headBBox[1]),
      scaleTo1000(metrics.headBBox[2]),
      scaleTo1000(metrics.headBBox[3])
    ] : [-1e3, -1e3, 1e3, 1e3];
    const fontFile = font.embedded?.subset ?? subset.fontFile;
    if (!fontFile || fontFile.length === 0) {
      log("font", "warn", "missing-font-file-for-subset", { baseFont: font.baseFont, alias: subset.name });
      return font.ref;
    }
    const { DW, W } = computeWidths(metrics);
    const subsetTag = subset.name.startsWith("/") ? subset.name.slice(1) : subset.name;
    const subsetBaseName = `${subsetTag}+${font.baseFont}`;
    const fontFileRef = this.doc.registerStream(fontFile, {});
    const fontDescriptor = {
      Type: "/FontDescriptor",
      FontName: `/${subsetBaseName}`,
      Flags: this.computePdfFlags(font, unifiedFont),
      FontBBox: fontBBox,
      ItalicAngle: unifiedFont.css?.style === "italic" ? -12 : 0,
      Ascent: scaleTo1000(metrics.metrics.ascender),
      Descent: scaleTo1000(metrics.metrics.descender),
      CapHeight: scaleTo1000(metrics.metrics.capHeight ?? metrics.metrics.ascender),
      XHeight: scaleTo1000(metrics.metrics.xHeight ?? metrics.metrics.ascender / 2),
      StemV: DEFAULT_STEM_V,
      FontFile2: fontFileRef
    };
    const fontDescriptorRef = this.doc.register(fontDescriptor);
    const cidFontDict = {
      Type: "/Font",
      Subtype: "/CIDFontType2",
      BaseFont: `/${subsetBaseName}`,
      CIDSystemInfo: {
        Registry: "(Adobe)",
        Ordering: "(Identity)",
        Supplement: 0
      },
      FontDescriptor: fontDescriptorRef,
      DW,
      W,
      CIDToGIDMap: "/Identity"
    };
    const cidFontRef = this.doc.register(cidFontDict);
    const toUnicodeRef = this.doc.registerStream(new TextEncoder().encode(subset.toUnicodeCMap), {});
    const type0Font = {
      Type: "/Font",
      Subtype: "/Type0",
      BaseFont: `/${subsetBaseName}-Identity-H`,
      Encoding: "/Identity-H",
      DescendantFonts: [cidFontRef],
      ToUnicode: toUnicodeRef
    };
    return this.doc.register(type0Font);
  }
  computePdfFlags(font, unifiedFont) {
    const family = unifiedFont.css?.family?.toLowerCase() ?? font.baseFont.toLowerCase();
    const style = unifiedFont.css?.style ?? "";
    const isItalic2 = /italic|oblique/i.test(style) || /italic|oblique/i.test(font.baseFont);
    const isSerif = family.includes("serif");
    const isSymbol = family.includes("symbol") || family.includes("dingbat") || font.baseFont.toLowerCase().includes("symbol");
    let flags = 0;
    if (isSymbol) {
      flags |= 1 << 2;
    } else {
      flags |= 1 << 5;
    }
    if (isSerif) {
      flags |= 1 << 1;
    }
    if (isItalic2) {
      flags |= 1 << 6;
    }
    return flags;
  }
};

// src/pdf/font/font-registry.ts
var DEFAULT_FONT2 = "Times New Roman";
var FontRegistry2 = class {
  constructor(doc, stylesheets) {
    this.doc = doc;
    this.facesByFamily = /* @__PURE__ */ new Map();
    this.embedder = null;
    this.fontConfig = null;
    const { facesByFamily } = parseFontFaces(stylesheets);
    this.facesByFamily = facesByFamily;
    this.fontResourceManager = new FontResourceManager(doc);
    this.subsetResourceManager = new SubsetResourceManager(doc);
  }
  async ensureFontResource(family, weight, style) {
    const normalizedWeight = normalizeFontWeight(weight);
    const familyKey = this.makeFamilyKey(family, normalizedWeight, style);
    const cached = this.fontResourceManager.getCached(familyKey);
    if (cached) {
      return cached;
    }
    if (this.embedder && this.fontConfig) {
      const familyStack = buildAliasedFamilyStack(family, this.fontConfig?.defaultStack);
      const embedded = this.embedder.ensureFont(familyStack, normalizedWeight, style);
      if (embedded) {
        const resource = {
          baseFont: embedded.baseFont,
          resourceName: embedded.resourceName,
          ref: embedded.ref,
          isBase14: false,
          metrics: embedded.metrics,
          embedded
        };
        this.fontResourceManager.setCached(familyKey, resource);
        return resource;
      }
    }
    const resolved = this.ensureStandardFontResource(family, normalizedWeight, style);
    this.fontResourceManager.setCached(familyKey, resolved);
    return resolved;
  }
  // New method to get embedder reference
  getEmbedder() {
    return this.embedder;
  }
  getDefaultFontStack() {
    if (!this.fontConfig?.defaultStack || this.fontConfig.defaultStack.length === 0) {
      return [];
    }
    return [...this.fontConfig.defaultStack];
  }
  ensureFontResourceSync(family, weight, style) {
    const normalizedWeight = normalizeFontWeight(weight);
    const familyKey = this.makeFamilyKey(family, normalizedWeight, style);
    const cached = this.fontResourceManager.getCached(familyKey);
    if (cached) {
      return cached;
    }
    if (this.embedder && this.fontConfig) {
      const familyStack = buildAliasedFamilyStack(family, this.fontConfig?.defaultStack);
      const embedded = this.embedder.ensureFont(familyStack, normalizedWeight, style);
      if (embedded) {
        const resource = {
          baseFont: embedded.baseFont,
          resourceName: embedded.resourceName,
          ref: embedded.ref,
          isBase14: false,
          metrics: embedded.metrics,
          embedded
        };
        this.fontResourceManager.setCached(familyKey, resource);
        return resource;
      }
    }
    const resolved = this.ensureStandardFontResource(family, normalizedWeight, style);
    this.fontResourceManager.setCached(familyKey, resolved);
    return resolved;
  }
  ensureSubsetForGlyphRun(glyphRun, font) {
    return this.subsetResourceManager.ensureSubsetForGlyphRun(glyphRun, font);
  }
  ensureStandardFontResource(family, weight, style) {
    const candidates = [...parseFamilyList(family), DEFAULT_FONT2];
    for (const candidate of candidates) {
      const normalizedCandidate = normalizeToken(candidate);
      if (!normalizedCandidate) {
        continue;
      }
      const candidateKey = this.familyWeightKey(normalizedCandidate, weight, style);
      const existing = this.fontResourceManager.getCached(candidateKey);
      if (existing) {
        this.fontResourceManager.setCached(this.makeFamilyKey(family, weight, style), existing);
        return existing;
      }
      const baseFont = resolveBaseFont(normalizedCandidate, weight, style, this.embedder !== null, this.facesByFamily);
      const resource = this.fontResourceManager.ensureBaseFontResource(baseFont);
      this.fontResourceManager.setCached(candidateKey, resource);
      this.fontResourceManager.setCached(this.makeFamilyKey(candidate, weight, style), resource);
      if (family && candidate !== family) {
        this.fontResourceManager.setCached(this.makeFamilyKey(family, weight, style), resource);
      }
      return resource;
    }
    const fallbackBase = applyWeightToBaseFont(DEFAULT_FONT2, weight, style);
    const fallback = this.fontResourceManager.ensureBaseFontResource(fallbackBase);
    this.fontResourceManager.setCached(this.familyWeightKey("", weight, style), fallback);
    return fallback;
  }
  makeFamilyKey(family, weight, style) {
    return this.familyWeightKey(normalizeToken(family), weight, style);
  }
  familyWeightKey(normalizedFamily, weight, style) {
    const familyToken = normalizedFamily && normalizedFamily.length > 0 ? normalizedFamily : "__default";
    const styleToken = isItalicStyle(style) ? "_italic" : "";
    return `${familyToken}@${fontWeightCacheKey(weight)}${styleToken}`;
  }
  async initializeEmbedder(fontConfig) {
    this.fontConfig = fontConfig;
    this.embedder = new FontEmbedder(fontConfig, this.doc);
    await this.embedder.initialize();
    log("font", "debug", "embedder initialized", { fontConfig });
  }
  setFontConfig(fontConfig) {
    this.fontConfig = fontConfig;
    this.embedder = new FontEmbedder(fontConfig, this.doc);
    log("font", "debug", "font config set", { fontConfig });
  }
};
function initFontSystem(doc, stylesheets) {
  return new FontRegistry2(doc, stylesheets);
}
function finalizeFontSubsets(_registry) {
}
function preflightFontsForPdfa(_registry) {
}

// src/pdf/utils/coordinate-transformer.ts
var CoordinateTransformer = class {
  constructor(pageHeightPt, pxToPt3, pageOffsetPx = 0) {
    this.pageHeightPt = pageHeightPt;
    this.pxToPt = pxToPt3;
    this.pageOffsetPx = pageOffsetPx;
  }
  get pageHeightPx() {
    return this.ptToPx(this.pageHeightPt);
  }
  ptToPx(value) {
    if (!this.ptToPxFactor) {
      const factor = this.pxToPt(1);
      this.ptToPxFactor = factor === 0 ? 0 : 1 / factor;
    }
    return value * (this.ptToPxFactor ?? 0);
  }
  convertPxToPt(value) {
    return this.pxToPt(value);
  }
  // NOVO
  convertPtToPx(value) {
    return this.ptToPx(value);
  }
};

// src/pdf/renderers/text-renderer-utils.ts
function normalizeChannel(value) {
  if (value > 1) {
    return value / 255;
  }
  return value;
}
function formatNumber2(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return Number.isInteger(value) ? value.toString() : value.toFixed(4).replace(/0+$/, "").replace(/\.$/, "");
}
function fillColorCommand(color, graphicsStateManager) {
  const r = formatNumber2(normalizeChannel(color.r));
  const g = formatNumber2(normalizeChannel(color.g));
  const b = formatNumber2(normalizeChannel(color.b));
  const alpha = color.a ?? 1;
  if (alpha < 1 && graphicsStateManager) {
    const stateName = graphicsStateManager.ensureFillAlphaState(alpha);
    return `/${stateName} gs
${r} ${g} ${b} rg`;
  }
  return `${r} ${g} ${b} rg`;
}

// src/pdf/font/rasterizer.ts
function flattenQuadratic(p0, p1, p2, tol, out) {
  const stack = [];
  stack.push({ x0: p0.x, y0: p0.y, cx: p1.x, cy: p1.y, x1: p2.x, y1: p2.y });
  while (stack.length > 0) {
    const seg = stack.pop();
    const ax = seg.x0, ay = seg.y0;
    const bx = seg.x1, by = seg.y1;
    const cx = seg.cx, cy = seg.cy;
    const vx = bx - ax, vy = by - ay;
    const len2 = vx * vx + vy * vy;
    let dist = 0;
    if (len2 === 0) {
      const dx = cx - ax, dy = cy - ay;
      dist = Math.hypot(dx, dy);
    } else {
      const t = ((cx - ax) * vx + (cy - ay) * vy) / len2;
      const projx = ax + t * vx;
      const projy = ay + t * vy;
      dist = Math.hypot(cx - projx, cy - projy);
    }
    if (dist <= tol) {
      out.push({ x: bx, y: by });
    } else {
      const x01 = (ax + cx) / 2;
      const y01 = (ay + cy) / 2;
      const x12 = (cx + bx) / 2;
      const y12 = (cy + by) / 2;
      const x012 = (x01 + x12) / 2;
      const y012 = (y01 + y12) / 2;
      stack.push({ x0: x012, y0: y012, cx: x12, cy: y12, x1: bx, y1: by });
      stack.push({ x0: ax, y0: ay, cx: x01, cy: y01, x1: x012, y1: y012 });
    }
  }
}
function flattenOutline(cmds, scale, tolPx = 0.5) {
  const contours = [];
  let cursorX = 0;
  let cursorY = 0;
  let curContour = [];
  const emitMove = (x, y) => {
    if (curContour.length > 0) {
      contours.push(curContour);
    }
    curContour = [{ x, y }];
    cursorX = x;
    cursorY = y;
  };
  const emitLine = (x, y) => {
    if (!curContour) curContour = [{ x: cursorX, y: cursorY }];
    curContour.push({ x, y });
    cursorX = x;
    cursorY = y;
  };
  const emitQuad = (cx, cy, x, y) => {
    if (!curContour) curContour = [{ x: cursorX, y: cursorY }];
    const start = { x: cursorX, y: cursorY };
    const ctrl = { x: cx, y: cy };
    const end = { x, y };
    flattenQuadratic(start, ctrl, end, tolPx, curContour);
    cursorX = x;
    cursorY = y;
  };
  for (const c of cmds) {
    switch (c.type) {
      case "moveTo": {
        const x = c.x * scale;
        const y = -c.y * scale;
        emitMove(x, y);
        break;
      }
      case "lineTo": {
        const x = c.x * scale;
        const y = -c.y * scale;
        emitLine(x, y);
        break;
      }
      case "quadTo": {
        const cx = c.cx * scale;
        const cy = -c.cy * scale;
        const x = c.x * scale;
        const y = -c.y * scale;
        emitQuad(cx, cy, x, y);
        break;
      }
      case "cubicTo": {
        const steps = 8;
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const x = Math.pow(1 - t, 3) * cursorX + 3 * t * Math.pow(1 - t, 2) * (c.cx1 * scale) + 3 * t * t * (1 - t) * (c.cx2 * scale) + t * t * t * (c.x * scale);
          const y = Math.pow(1 - t, 3) * cursorY + 3 * t * Math.pow(1 - t, 2) * (-c.cy1 * scale) + 3 * t * t * (1 - t) * (-c.cy2 * scale) + t * t * t * (-c.y * scale);
          emitLine(x, y);
        }
        break;
      }
      case "close": {
        if (curContour.length > 0) {
          const first = curContour[0];
          const last = curContour[curContour.length - 1];
          if (Math.abs(first.x - last.x) > 1e-6 || Math.abs(first.y - last.y) > 1e-6) {
            curContour.push({ x: first.x, y: first.y });
          }
          contours.push(curContour);
          curContour = [];
        }
        break;
      }
    }
  }
  if (curContour.length > 0) {
    const first = curContour[0];
    const last = curContour[curContour.length - 1];
    if (Math.abs(first.x - last.x) > 1e-6 || Math.abs(first.y - last.y) > 1e-6) {
      curContour.push({ x: first.x, y: first.y });
    }
    contours.push(curContour);
  }
  return { contours };
}
function rasterizeContours(contours, supersample = 4) {
  if (!contours || contours.length === 0) return null;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const c of contours) {
    for (const p of c) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
  }
  if (!isFinite(minX) || !isFinite(minY)) return null;
  const pad = 1;
  minX = Math.floor(minX) - pad;
  minY = Math.floor(minY) - pad;
  maxX = Math.ceil(maxX) + pad;
  maxY = Math.ceil(maxY) + pad;
  const width = maxX - minX;
  const height = maxY - minY;
  if (width <= 0 || height <= 0) return null;
  const hiW = width * supersample;
  const hiH = height * supersample;
  const hi = new Uint8ClampedArray(hiW * hiH);
  for (let y = 0; y < hiH; y++) {
    const fy = minY + y / supersample + 0.5 / supersample;
    const intersections = [];
    for (const contour of contours) {
      for (let i = 0; i < contour.length - 1; i++) {
        const a = contour[i];
        const b = contour[i + 1];
        const y0 = a.y;
        const y1 = b.y;
        if (y0 === y1) continue;
        const ymin = Math.min(y0, y1);
        const ymax = Math.max(y0, y1);
        if (fy < ymin || fy >= ymax) continue;
        const t = (fy - y0) / (y1 - y0);
        const ix = a.x + t * (b.x - a.x);
        intersections.push(ix);
      }
    }
    if (intersections.length === 0) continue;
    intersections.sort((a, b) => a - b);
    for (let k = 0; k < intersections.length; k += 2) {
      const x0 = intersections[k];
      const x1 = intersections[k + 1];
      if (x1 === void 0) break;
      const hiX0 = Math.max(0, Math.floor((x0 - minX) * supersample));
      const hiX1 = Math.min(hiW, Math.ceil((x1 - minX) * supersample));
      if (hiX1 <= hiX0) continue;
      const base = y * hiW;
      for (let hx = hiX0; hx < hiX1; hx++) hi[base + hx] = 255;
    }
  }
  const outW = width;
  const outH = height;
  const out = new Uint8ClampedArray(outW * outH);
  for (let ty = 0; ty < outH; ty++) {
    for (let tx = 0; tx < outW; tx++) {
      let sum = 0;
      const startY = ty * supersample;
      const startX = tx * supersample;
      for (let sy = 0; sy < supersample; sy++) {
        const row = (startY + sy) * hiW;
        for (let sx = 0; sx < supersample; sx++) {
          sum += hi[row + startX + sx];
        }
      }
      const avg = Math.round(sum / (supersample * supersample));
      out[ty * outW + tx] = avg;
    }
  }
  return { width: outW, height: outH, data: out, offsetX: minX, offsetY: minY };
}

// src/pdf/font/glyph-cache.ts
init_glyph_atlas();

// src/pdf/font/blur.ts
function blurAlpha2(src, width, height, radiusPx) {
  if (!src || src.length === 0) return src;
  if (radiusPx <= 0) return src.slice();
  const sigma = Math.max(1e-4, radiusPx / 3);
  const half = Math.ceil(3 * sigma);
  const ksize = half * 2 + 1;
  const kernel = new Float32Array(ksize);
  const sigma2 = sigma * sigma;
  const denom = 1 / (Math.sqrt(2 * Math.PI) * sigma);
  let sum = 0;
  for (let i = -half; i <= half; i++) {
    const v = denom * Math.exp(-(i * i) / (2 * sigma2));
    kernel[i + half] = v;
    sum += v;
  }
  for (let i = 0; i < ksize; i++) kernel[i] /= sum;
  const tmp = new Float32Array(width * height);
  for (let y = 0; y < height; y++) {
    const row = y * width;
    for (let x = 0; x < width; x++) {
      let acc = 0;
      for (let k = -half; k <= half; k++) {
        const sx = x + k;
        if (sx < 0) {
          acc += kernel[k + half] * src[row + 0];
        } else if (sx >= width) {
          acc += kernel[k + half] * src[row + (width - 1)];
        } else {
          acc += kernel[k + half] * src[row + sx];
        }
      }
      tmp[row + x] = acc;
    }
  }
  const out = new Uint8ClampedArray(width * height);
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let acc = 0;
      for (let k = -half; k <= half; k++) {
        const sy = y + k;
        if (sy < 0) {
          acc += kernel[k + half] * tmp[0 * width + x];
        } else if (sy >= height) {
          acc += kernel[k + half] * tmp[(height - 1) * width + x];
        } else {
          acc += kernel[k + half] * tmp[sy * width + x];
        }
      }
      out[y * width + x] = Math.round(acc);
    }
  }
  return out;
}

// src/pdf/font/glyph-cache.ts
var maxEntries = 500;
var glyphMaskCache = /* @__PURE__ */ new Map();
var glyphAtlasPlacements = /* @__PURE__ */ new Map();
function trimCacheIfNeeded() {
  while (glyphMaskCache.size > maxEntries) {
    const oldestKey = glyphMaskCache.keys().next().value;
    if (!oldestKey) break;
    glyphMaskCache.delete(oldestKey);
  }
}
function makeKey(metrics, gid, fontSizePx, supersample = 4, blurPx = 0) {
  const uid = `${metrics.metrics.unitsPerEm}-${metrics.headBBox ? metrics.headBBox.join(",") : "nbb"}`;
  const blurKey = Math.round(Math.max(0, blurPx || 0) * 10) / 10;
  return `${uid}|gid:${gid}|size:${Math.round(fontSizePx)}|ss:${supersample}|blur:${blurKey}`;
}
function getGlyphMask(metrics, gid, fontSizePx, supersample = 4, blurPx = 0) {
  const key2 = makeKey(metrics, gid, fontSizePx, supersample, blurPx);
  const cached = glyphMaskCache.get(key2);
  if (cached) {
    glyphMaskCache.delete(key2);
    glyphMaskCache.set(key2, cached);
    return cached;
  }
  if (!metrics.getGlyphOutline) return null;
  const cmds = metrics.getGlyphOutline(gid);
  if (!cmds || cmds.length === 0) return null;
  const unitsPerEm = metrics.metrics.unitsPerEm || 1e3;
  const scale = fontSizePx / unitsPerEm;
  try {
    const { contours } = flattenOutline(cmds, scale, 0.5);
    const mask = rasterizeContours(contours, supersample);
    if (!mask) return null;
    let alphaBuf = mask.data;
    if (blurPx && blurPx > 0) {
      alphaBuf = blurAlpha2(mask.data, mask.width, mask.height, blurPx);
    }
    const extraPadding = blurPx && blurPx > 0 ? Math.ceil(blurPx * 2) + 2 : 0;
    try {
      const placement = globalGlyphAtlas.pack(key2, alphaBuf, mask.width, mask.height, extraPadding);
      glyphAtlasPlacements.set(key2, placement);
    } catch {
      glyphAtlasPlacements.set(key2, null);
    }
    const clamped = alphaBuf instanceof Uint8ClampedArray ? alphaBuf : new Uint8ClampedArray(alphaBuf);
    const finalMask = {
      width: mask.width,
      height: mask.height,
      data: clamped,
      offsetX: mask.offsetX,
      offsetY: mask.offsetY
    };
    glyphMaskCache.set(key2, finalMask);
    trimCacheIfNeeded();
    return finalMask;
  } catch {
    return null;
  }
}

// src/pdf/renderers/text-shadow-renderer.ts
var TextShadowRenderer = class {
  constructor(coordinateTransformer, fontRegistry, imageRenderer, graphicsStateManager) {
    this.coordinateTransformer = coordinateTransformer;
    this.fontRegistry = fontRegistry;
    this.imageRenderer = imageRenderer;
    this.graphicsStateManager = graphicsStateManager;
    this.runShadowCache = /* @__PURE__ */ new Map();
  }
  async render(context) {
    const commands = [];
    const { run, font, encoded, Tm, fontSizePt, fontSizePx, wordSpacingPt, appliedWordSpacing, fontResourceName } = context;
    if (!run.textShadows || run.textShadows.length === 0) {
      return commands;
    }
    const needsRaster = run.textShadows.some((sh) => (sh.blur ?? 0) > 0 || sh.color && sh.color.a !== void 0 && sh.color.a < 1);
    const glyphMetrics = run.glyphs ? mergeMetricsWithOutline(run.glyphs.font) : null;
    const embedder = this.fontRegistry.getEmbedder ? this.fontRegistry.getEmbedder() : void 0;
    const faceMetrics = glyphMetrics ?? (embedder ? embedder.getMetrics(font.baseFont) : null);
    const wordSpacingCmd = appliedWordSpacing ? `${formatNumber2(wordSpacingPt)} Tw` : void 0;
    const resetWordSpacingCmd = appliedWordSpacing ? "0 Tw" : void 0;
    const fontName = fontResourceName ?? font.resourceName;
    if (this.imageRenderer && needsRaster) {
      if (run.glyphs && faceMetrics) {
        try {
          const pages = (await Promise.resolve().then(() => (init_glyph_atlas(), glyph_atlas_exports))).globalGlyphAtlas.getPages();
          if (pages && pages.length > 0) {
            this.imageRenderer.registerAtlasPages(pages);
          }
        } catch {
        }
        const supersample = 4;
        const glyphMasks = [];
        for (let gi = 0; gi < run.glyphs.glyphIds.length; gi++) {
          const gid = run.glyphs.glyphIds[gi];
          const pos = run.glyphs.positions[gi] ?? { x: 0, y: 0 };
          try {
            const gm = getGlyphMask(faceMetrics, gid, fontSizePx, supersample, 0);
            if (!gm) continue;
            glyphMasks.push({ mask: gm, pos });
          } catch {
          }
        }
        if (glyphMasks.length > 0) {
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          const maxBlurPx = run.textShadows.reduce((acc, sh) => Math.max(acc, Math.max(0, sh?.blur ?? 0)), 0);
          for (const item of glyphMasks) {
            const { mask, pos } = item;
            const maskOffsetX = mask.offsetX ?? 0;
            const maskOffsetY = mask.offsetY ?? 0;
            const gx0 = pos.x + maskOffsetX;
            const gy0 = pos.y + maskOffsetY;
            const gx1 = gx0 + mask.width;
            const gy1 = gy0 + mask.height;
            if (gx0 < minX) minX = gx0;
            if (gy0 < minY) minY = gy0;
            if (gx1 > maxX) maxX = gx1;
            if (gy1 > maxY) maxY = gy1;
          }
          const bleedPad = Math.ceil(maxBlurPx * 2);
          minX = Math.floor(minX - bleedPad);
          minY = Math.floor(minY - bleedPad);
          maxX = Math.ceil(maxX + bleedPad);
          maxY = Math.ceil(maxY + bleedPad);
          const combinedW = Math.max(0, maxX - minX);
          const combinedH = Math.max(0, maxY - minY);
          if (combinedW > 0 && combinedH > 0) {
            const combinedAlpha = new Uint8Array(combinedW * combinedH);
            for (const item of glyphMasks) {
              const { mask, pos } = item;
              const maskOffsetX = mask.offsetX ?? 0;
              const maskOffsetY = mask.offsetY ?? 0;
              const ox = Math.round(pos.x + maskOffsetX - minX);
              const oy = Math.round(pos.y + maskOffsetY - minY);
              for (let yy = 0; yy < mask.height; yy++) {
                const dstRow = oy + yy;
                if (dstRow < 0 || dstRow >= combinedH) continue;
                const srcRow = yy;
                const dstBase = dstRow * combinedW;
                const srcBase = srcRow * mask.width;
                for (let xx = 0; xx < mask.width; xx++) {
                  const dstIdx = dstBase + ox + xx;
                  if (dstIdx < 0 || dstIdx >= combinedAlpha.length) continue;
                  const a = mask.data[srcBase + xx] || 0;
                  const summed = combinedAlpha[dstIdx] + a;
                  combinedAlpha[dstIdx] = summed > 255 ? 255 : summed;
                }
              }
            }
            for (const sh of run.textShadows) {
              if (!sh || !sh.color) {
                continue;
              }
              const blurPx = Math.max(0, sh.blur ?? 0);
              const clampedCombined = combinedAlpha instanceof Uint8ClampedArray ? combinedAlpha : new Uint8ClampedArray(combinedAlpha);
              const rawAlphaBuf = blurPx > 0 ? blurAlpha2(clampedCombined, combinedW, combinedH, blurPx) : clampedCombined;
              const alphaBuf = rawAlphaBuf instanceof Uint8ClampedArray ? rawAlphaBuf : new Uint8ClampedArray(rawAlphaBuf);
              const r8 = Math.round(normalizeChannel(sh.color.r) * 255);
              const g8 = Math.round(normalizeChannel(sh.color.g) * 255);
              const b8 = Math.round(normalizeChannel(sh.color.b) * 255);
              const shadowAlpha = sh.color.a ?? 1;
              const cacheKey = `${run.text}|${font.baseFont}|size:${fontSizePx}|blur:${Math.round(blurPx)}|color:${r8},${g8},${b8},${shadowAlpha}|ss:${supersample}`;
              let resAlias;
              const cached = this.runShadowCache.get(cacheKey);
              if (cached) {
                resAlias = cached.alias;
              } else {
                const rgba = new Uint8Array(combinedW * combinedH * 4);
                for (let i = 0, j = 0; i < alphaBuf.length; i++, j += 4) {
                  rgba[j] = r8;
                  rgba[j + 1] = g8;
                  rgba[j + 2] = b8;
                  rgba[j + 3] = Math.round(alphaBuf[i] * shadowAlpha);
                }
                const img = {
                  src: `internal:shadow:run:${font.resourceName}:${Math.round(Math.random() * 1e9)}`,
                  width: combinedW,
                  height: combinedH,
                  format: "png",
                  channels: 4,
                  bitsPerComponent: 8,
                  data: rgba.buffer
                };
                const res = this.imageRenderer.registerResource(img);
                resAlias = res.alias;
                this.runShadowCache.set(cacheKey, { alias: resAlias, image: img });
              }
              const offsetX = sh.offsetX ?? 0;
              const offsetY = sh.offsetY ?? 0;
              const xPx = Tm.e + offsetX + minX;
              const yPxTop = Tm.f + offsetY + minY;
              const widthPt = this.coordinateTransformer.convertPxToPt(combinedW);
              const heightPt = this.coordinateTransformer.convertPxToPt(combinedH);
              const xPt = this.coordinateTransformer.convertPxToPt(xPx);
              const localYTop = yPxTop - this.coordinateTransformer.pageOffsetPx;
              const yPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localYTop + combinedH);
              commands.push(
                "q",
                `${formatNumber2(widthPt)} 0 0 ${formatNumber2(heightPt)} ${formatNumber2(xPt)} ${formatNumber2(yPt)} cm`,
                `/${resAlias} Do`,
                "Q"
              );
            }
          }
        }
        if (glyphMasks.length === 0) {
          this.appendVectorShadowLayers(commands, run, font, encoded, Tm, fontSizePt, fontName, wordSpacingCmd, resetWordSpacingCmd);
        }
      } else {
        if (needsRaster && this.imageRenderer) {
          try {
            for (const sh of run.textShadows) {
              if (!sh || !sh.color) continue;
              const offsetX = sh.offsetX ?? 0;
              const offsetY = sh.offsetY ?? 0;
              const blurPx = Math.max(0, sh.blur ?? 0);
              const baseAlpha = sh.color.a ?? 1;
              const samples = [];
              if (blurPx <= 1) {
                samples.push({ dx: 0, dy: 0, weight: 1 });
              } else {
                const centerW = 0.38;
                const orthoW = 0.12;
                const diagW = (1 - (centerW + 4 * orthoW)) / 4;
                const radius = blurPx / 2;
                samples.push({ dx: 0, dy: 0, weight: centerW });
                samples.push({ dx: -radius, dy: 0, weight: orthoW });
                samples.push({ dx: radius, dy: 0, weight: orthoW });
                samples.push({ dx: 0, dy: -radius, weight: orthoW });
                samples.push({ dx: 0, dy: radius, weight: orthoW });
                samples.push({ dx: -radius, dy: -radius, weight: diagW });
                samples.push({ dx: radius, dy: -radius, weight: diagW });
                samples.push({ dx: -radius, dy: radius, weight: diagW });
                samples.push({ dx: radius, dy: radius, weight: diagW });
              }
              for (const s of samples) {
                const sx = s.dx;
                const sy = s.dy;
                const sampleAlpha = baseAlpha * s.weight;
                const sampleColor = { r: sh.color.r, g: sh.color.g, b: sh.color.b, a: sampleAlpha };
                const shadowX = this.coordinateTransformer.convertPxToPt(Tm.e + offsetX + sx);
                const shadowLocalBaseline = Tm.f - this.coordinateTransformer.pageOffsetPx + offsetY + sy;
                const shadowYPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(shadowLocalBaseline);
                const shadowSequence = ["q", fillColorCommand(sampleColor, this.graphicsStateManager), "BT"];
                if (wordSpacingCmd) shadowSequence.push(wordSpacingCmd);
                shadowSequence.push(
                  `/${fontName} ${formatNumber2(fontSizePt)} Tf`,
                  `${formatNumber2(Tm.a)} ${formatNumber2(Tm.b)} ${formatNumber2(Tm.c)} ${formatNumber2(Tm.d)} ${formatNumber2(shadowX)} ${formatNumber2(shadowYPt)} Tm`,
                  `(${encoded}) Tj`
                );
                if (resetWordSpacingCmd) shadowSequence.push(resetWordSpacingCmd);
                shadowSequence.push("ET", "Q");
                commands.push(...shadowSequence);
              }
            }
          } catch {
            this.appendVectorShadowLayers(commands, run, font, encoded, Tm, fontSizePt, fontName, wordSpacingCmd, resetWordSpacingCmd);
          }
        } else {
          this.appendVectorShadowLayers(commands, run, font, encoded, Tm, fontSizePt, fontName, wordSpacingCmd, resetWordSpacingCmd);
        }
      }
    } else {
      this.appendVectorShadowLayers(commands, run, font, encoded, Tm, fontSizePt, fontName, wordSpacingCmd, resetWordSpacingCmd);
    }
    return commands;
  }
  appendVectorShadowLayers(commands, run, font, encoded, Tm, fontSizePt, fontName, wordSpacingCmd, resetWordSpacingCmd) {
    const shadows = run.textShadows ?? [];
    for (const sh of shadows) {
      if (!sh || !sh.color) {
        continue;
      }
      const shadowX = this.coordinateTransformer.convertPxToPt(Tm.e + (sh.offsetX ?? 0));
      const shadowLocalBaseline = Tm.f - this.coordinateTransformer.pageOffsetPx + (sh.offsetY ?? 0);
      const shadowYPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(shadowLocalBaseline);
      const shadowSequence = ["q", fillColorCommand(sh.color, this.graphicsStateManager), "BT"];
      if (wordSpacingCmd) shadowSequence.push(wordSpacingCmd);
      shadowSequence.push(
        `/${fontName} ${formatNumber2(fontSizePt)} Tf`,
        `${formatNumber2(Tm.a)} ${formatNumber2(Tm.b)} ${formatNumber2(Tm.c)} ${formatNumber2(Tm.d)} ${formatNumber2(shadowX)} ${formatNumber2(shadowYPt)} Tm`,
        `(${encoded}) Tj`
      );
      if (resetWordSpacingCmd) shadowSequence.push(resetWordSpacingCmd);
      shadowSequence.push("ET", "Q");
      commands.push(...shadowSequence);
    }
  }
};
function mergeMetricsWithOutline(font) {
  if (!font?.metrics || !font.program?.getGlyphOutline) {
    return null;
  }
  return {
    metrics: font.metrics.metrics,
    glyphMetrics: font.metrics.glyphMetrics,
    cmap: font.metrics.cmap,
    headBBox: font.metrics.headBBox,
    getGlyphOutline: font.program.getGlyphOutline
  };
}

// src/pdf/renderers/text-decoration-renderer.ts
var TextDecorationRenderer = class {
  constructor(coordinateTransformer, graphicsStateManager) {
    this.coordinateTransformer = coordinateTransformer;
    this.graphicsStateManager = graphicsStateManager;
  }
  render(run, color) {
    if (!run.decorations) {
      return [];
    }
    const matrix = run.lineMatrix;
    if (!matrix) {
      return [];
    }
    const commands = [];
    const style = run.decorations.style ?? "solid";
    switch (style) {
      case "double":
        commands.push(...this.renderDouble(run, color));
        break;
      case "dotted":
      case "dashed":
        commands.push(...this.renderDashedOrDotted(run, color, style));
        break;
      case "wavy":
        commands.push(...this.renderWavy(run, color));
        break;
      case "solid":
      default:
        commands.push(...this.renderSolid(run, color));
        break;
    }
    return commands;
  }
  renderSolid(run, color) {
    const matrix = run.lineMatrix;
    if (!matrix) {
      return [];
    }
    const widthPx = Math.max(run.advanceWidth ?? 0, 0);
    if (widthPx <= 0) {
      return [];
    }
    const rects = [];
    if (run.decorations?.lineThrough) {
      const thicknessPx = Math.max(run.fontSize * 0.085, 0.5);
      const centerYPx = matrix.f - run.fontSize * 0.3;
      rects.push({
        x: matrix.e,
        y: centerYPx - thicknessPx / 2,
        width: widthPx,
        height: thicknessPx
      });
    }
    if (run.decorations?.underline) {
      const thicknessPx = Math.max(run.fontSize * 0.065, 0.5);
      const underlineYPx = matrix.f + run.fontSize * 0.1;
      rects.push({
        x: matrix.e,
        y: underlineYPx - thicknessPx / 2,
        width: widthPx,
        height: thicknessPx
      });
    }
    if (run.decorations?.overline) {
      const thicknessPx = Math.max(run.fontSize * 0.05, 0.5);
      const overlineYPx = matrix.f - run.fontSize * 0.9;
      rects.push({
        x: matrix.e,
        y: overlineYPx - thicknessPx / 2,
        width: widthPx,
        height: thicknessPx
      });
    }
    const commands = [];
    const decorationColor = run.decorations?.color ?? color;
    for (const rect of rects) {
      const pdfRect = this.rectToPdf(rect);
      if (!pdfRect) {
        continue;
      }
      commands.push(
        fillColorCommand(decorationColor, this.graphicsStateManager),
        `${pdfRect.x} ${pdfRect.y} ${pdfRect.width} ${pdfRect.height} re`,
        "f"
      );
    }
    return commands;
  }
  renderDouble(run, color) {
    const matrix = run.lineMatrix;
    if (!matrix || !run.decorations?.underline && !run.decorations?.overline && !run.decorations?.lineThrough) {
      return [];
    }
    const widthPx = Math.max(run.advanceWidth ?? 0, 0);
    if (widthPx <= 0) {
      return [];
    }
    const commands = [];
    const decorationColor = run.decorations?.color ?? color;
    const pushLinePair = (centerY, thickness) => {
      const gap = Math.max(thickness * 0.8, 0.5);
      const singleHeight = Math.max(thickness * 0.8, 0.5);
      const firstY = centerY - gap / 2 - singleHeight / 2;
      const secondY = centerY + gap / 2 - singleHeight / 2;
      const rects = [
        { x: matrix.e, y: firstY, width: widthPx, height: singleHeight },
        { x: matrix.e, y: secondY, width: widthPx, height: singleHeight }
      ];
      for (const rect of rects) {
        const pdfRect = this.rectToPdf(rect);
        if (!pdfRect) continue;
        commands.push(
          fillColorCommand(decorationColor, this.graphicsStateManager),
          `${pdfRect.x} ${pdfRect.y} ${pdfRect.width} ${pdfRect.height} re`,
          "f"
        );
      }
    };
    if (run.decorations.lineThrough) {
      const thicknessPx = Math.max(run.fontSize * 0.085, 0.5);
      const centerYPx = matrix.f - run.fontSize * 0.3;
      pushLinePair(centerYPx, thicknessPx);
    }
    if (run.decorations.underline) {
      const thicknessPx = Math.max(run.fontSize * 0.065, 0.5);
      const underlineYPx = matrix.f + run.fontSize * 0.1;
      pushLinePair(underlineYPx, thicknessPx);
    }
    if (run.decorations.overline) {
      const thicknessPx = Math.max(run.fontSize * 0.05, 0.5);
      const overlineYPx = matrix.f - run.fontSize * 0.9;
      pushLinePair(overlineYPx, thicknessPx);
    }
    return commands;
  }
  renderDashedOrDotted(run, color, style) {
    const matrix = run.lineMatrix;
    if (!matrix || !run.decorations?.underline && !run.decorations?.overline && !run.decorations?.lineThrough) {
      return [];
    }
    const widthPx = Math.max(run.advanceWidth ?? 0, 0);
    if (widthPx <= 0) {
      return [];
    }
    const decorationColor = run.decorations?.color ?? color;
    const commands = [];
    const thicknessBase = run.fontSize * 0.065;
    const lineWidthPx = Math.max(thicknessBase, 0.5);
    const dashUnit = Math.max(lineWidthPx, 0.5);
    const dashPattern = style === "dashed" ? [3 * dashUnit, 3 * dashUnit] : [dashUnit, dashUnit];
    const pushLine = (yPx) => {
      const xStartPt = formatNumber2(this.coordinateTransformer.convertPxToPt(matrix.e));
      const xEndPt = formatNumber2(this.coordinateTransformer.convertPxToPt(matrix.e + widthPx));
      const localY = yPx - this.coordinateTransformer.pageOffsetPx;
      const yPt = formatNumber2(
        this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY)
      );
      const widthPt = this.coordinateTransformer.convertPxToPt(Math.max(lineWidthPx, 0));
      const dashPt = dashPattern.map((v) => this.coordinateTransformer.convertPxToPt(Math.max(v, 0))).map(formatNumber2).join(" ");
      commands.push(
        fillColorCommand(decorationColor, this.graphicsStateManager),
        `${widthPt > 0 ? formatNumber2(widthPt) : "0"} w`,
        `[${dashPt}] 0 d`,
        `${xStartPt} ${yPt} m`,
        `${xEndPt} ${yPt} l`,
        "S",
        "[] 0 d"
      );
    };
    if (run.decorations.lineThrough) {
      const centerYPx = matrix.f - run.fontSize * 0.3;
      pushLine(centerYPx);
    }
    if (run.decorations.underline) {
      const underlineYPx = matrix.f + run.fontSize * 0.1;
      pushLine(underlineYPx);
    }
    if (run.decorations.overline) {
      const overlineYPx = matrix.f - run.fontSize * 0.9;
      pushLine(overlineYPx);
    }
    return commands;
  }
  renderWavy(run, color) {
    const matrix = run.lineMatrix;
    if (!matrix || !run.decorations?.underline && !run.decorations?.overline && !run.decorations?.lineThrough) {
      return [];
    }
    const widthPx = Math.max(run.advanceWidth ?? 0, 0);
    if (widthPx <= 0) {
      return [];
    }
    const decorationColor = run.decorations?.color ?? color;
    const commands = [];
    const amplitudePx = Math.max(run.fontSize * 0.08, 0.5);
    const wavelengthPx = Math.max(run.fontSize * 0.4, 2);
    const lineWidthPx = Math.max(run.fontSize * 0.065, 0.5);
    const buildWavePoints = (baselineY) => {
      const points = [];
      const steps = Math.max(Math.round(widthPx / (wavelengthPx / 2)), 2);
      for (let i = 0; i <= steps; i++) {
        const x = matrix.e + widthPx * i / steps;
        const phase = i % 2 === 0 ? -1 : 1;
        const y = baselineY + phase * amplitudePx;
        points.push({ x, y });
      }
      return points;
    };
    const pushWave = (baselineY) => {
      const points = buildWavePoints(baselineY);
      if (points.length < 2) {
        return;
      }
      const localY = points[0].y - this.coordinateTransformer.pageOffsetPx;
      const yPtFirst = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY);
      const xPtFirst = this.coordinateTransformer.convertPxToPt(points[0].x);
      const widthPt = this.coordinateTransformer.convertPxToPt(Math.max(lineWidthPx, 0));
      commands.push(
        fillColorCommand(decorationColor, this.graphicsStateManager),
        `${formatNumber2(widthPt)} w`
      );
      commands.push(
        `${formatNumber2(xPtFirst)} ${formatNumber2(yPtFirst)} m`
      );
      for (let i = 1; i < points.length; i++) {
        const localYPoint = points[i].y - this.coordinateTransformer.pageOffsetPx;
        const yPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localYPoint);
        const xPt = this.coordinateTransformer.convertPxToPt(points[i].x);
        commands.push(`${formatNumber2(xPt)} ${formatNumber2(yPt)} l`);
      }
      commands.push("S");
    };
    if (run.decorations.lineThrough) {
      const centerYPx = matrix.f - run.fontSize * 0.3;
      pushWave(centerYPx);
    }
    if (run.decorations.underline) {
      const underlineYPx = matrix.f + run.fontSize * 0.1;
      pushWave(underlineYPx);
    }
    if (run.decorations.overline) {
      const overlineYPx = matrix.f - run.fontSize * 0.9;
      pushWave(overlineYPx);
    }
    return commands;
  }
  rectToPdf(rect) {
    if (!rect) {
      return null;
    }
    const widthPx = Math.max(rect.width, 0);
    const heightPx = Math.max(rect.height, 0);
    if (widthPx === 0 || heightPx === 0) {
      return null;
    }
    const localY = rect.y - this.coordinateTransformer.pageOffsetPx;
    const x = this.coordinateTransformer.convertPxToPt(rect.x);
    const y = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY + heightPx);
    const width = this.coordinateTransformer.convertPxToPt(widthPx);
    const height = this.coordinateTransformer.convertPxToPt(heightPx);
    return {
      x: formatNumber2(x),
      y: formatNumber2(y),
      width: formatNumber2(width),
      height: formatNumber2(height)
    };
  }
};

// src/pdf/renderers/text-font-resolver.ts
var TextFontResolver = class {
  constructor(fontRegistry) {
    this.fontRegistry = fontRegistry;
  }
  async ensureFontResource(options) {
    const text = options.text ?? "";
    const requiresUnicode = needsUnicode(text);
    const familiesToTry = [];
    if (options.fontFamily) {
      familiesToTry.push(options.fontFamily);
    }
    if (requiresUnicode) {
      const fallbackStack = this.fontRegistry.getDefaultFontStack();
      for (const family of fallbackStack) {
        if (family && family.length > 0) {
          familiesToTry.push(family);
        }
      }
    }
    familiesToTry.push(void 0);
    const seen = /* @__PURE__ */ new Set();
    const attempted = [];
    for (const family of familiesToTry) {
      const key2 = family ?? "__default__";
      if (seen.has(key2)) {
        continue;
      }
      seen.add(key2);
      const resource = await this.fontRegistry.ensureFontResource(family, options.fontWeight, options.fontStyle);
      attempted.push(resource);
      if (fontSupportsText(resource, text, requiresUnicode)) {
        return resource;
      }
    }
    return attempted[attempted.length - 1];
  }
};
function fontSupportsText(font, text, requiresUnicode) {
  if (!text) {
    return true;
  }
  if (!font.metrics) {
    return !requiresUnicode;
  }
  for (const char of text) {
    const codePoint = char.codePointAt(0);
    if (codePoint === void 0) {
      continue;
    }
    const glyphId = font.metrics.cmap.getGlyphId(codePoint);
    if (glyphId === 0) {
      return false;
    }
  }
  return true;
}

// src/pdf/renderers/text-encoder.ts
function encodeTextPayload(text, font) {
  if (font.isBase14) {
    return { encoded: encodeAndEscapePdfText(text, "WinAnsi"), scheme: "WinAnsi" };
  }
  return { encoded: encodeIdentityText(text, font), scheme: "Identity-H" };
}
function encodeIdentityText(text, font) {
  const metrics = font.metrics;
  if (!metrics) {
    return encodeAndEscapePdfText(text, "WinAnsi");
  }
  let encoded = "";
  const samples = [];
  for (const char of text) {
    const codePoint = char.codePointAt(0);
    if (codePoint === void 0) {
      continue;
    }
    const glyphId = metrics.cmap.getGlyphId(codePoint);
    if (samples.length < 10) {
      samples.push({ char, codePoint, gid: glyphId });
    }
    encoded += String.fromCharCode(codePoint >> 8 & 255, codePoint & 255);
  }
  if (samples.length > 0) {
    log("encoding", "debug", "Identity-H encoding samples", { font: font.baseFont, samples });
  }
  return escapePdfLiteral(encoded);
}

// src/pdf/utils/glyph-run-renderer.ts
function drawGlyphRun(run, subset, xPt, yPt, fontSizePt, color, graphicsStateManager, wordSpacingPt = 0, options) {
  const commands = [];
  if (!options?.skipColor) {
    commands.push(fillColorCommand(color, graphicsStateManager));
  }
  commands.push("BT");
  commands.push(`${subset.name} ${formatNumber2(fontSizePt)} Tf`);
  commands.push(`${formatNumber2(xPt)} ${formatNumber2(yPt)} Td`);
  const appliedWordSpacing = wordSpacingPt !== 0;
  if (appliedWordSpacing) {
    commands.push(`${formatNumber2(wordSpacingPt)} Tw`);
  }
  if (options?.textRenderingMode !== void 0) {
    commands.push(`${options.textRenderingMode} Tr`);
  }
  const ptPerPx = fontSizePt / run.fontSize;
  const unitsPerEm = run.font.metrics.metrics.unitsPerEm;
  const glyphWidths = run.font.metrics.glyphMetrics;
  const encodeGlyphId = (gid) => {
    const charCode = subset.encodeGlyph(gid);
    const hex = charCode.toString(16).toUpperCase();
    const evenHex = hex.length % 2 === 0 ? hex : `0${hex}`;
    return evenHex.length < 4 ? evenHex.padStart(4, "0") : evenHex;
  };
  const elements = [];
  let hasAdjustments = false;
  for (let i = 0; i < run.glyphIds.length; i++) {
    const gid = run.glyphIds[i];
    const hexCode = encodeGlyphId(gid);
    elements.push(`<${hexCode}>`);
    if (i < run.glyphIds.length - 1) {
      const currentPos = run.positions[i]?.x ?? 0;
      const nextPos = run.positions[i + 1]?.x ?? currentPos;
      let desiredAdvancePx = nextPos - currentPos;
      if (appliedWordSpacing) {
        const nextChar = run.text[i + 1] ?? "";
        if (nextChar === " ") {
          desiredAdvancePx += wordSpacingPt / ptPerPx;
        }
      }
      const gm = glyphWidths.get(gid);
      const defaultAdvancePx = (gm?.advanceWidth ?? 0) / unitsPerEm * run.fontSize;
      const deltaPx = desiredAdvancePx - defaultAdvancePx;
      if (Math.abs(deltaPx) > 1e-6) {
        const deltaPt = deltaPx * ptPerPx;
        const adjustment = -deltaPt / fontSizePt * 1e3;
        if (Math.abs(adjustment) > 1e-6) {
          hasAdjustments = true;
          elements.push(adjustment);
        }
      }
    }
  }
  if (!hasAdjustments) {
    const hex = run.glyphIds.map((gid) => encodeGlyphId(gid)).join("");
    commands.push(`<${hex}> Tj`);
  } else {
    const tjContent = elements.map((el) => typeof el === "number" ? formatPdfNumber(el) : el).join(" ");
    commands.push(`[${tjContent}] TJ`);
  }
  commands.push("ET");
  if (options?.afterTextCommands && options.afterTextCommands.length > 0) {
    commands.push(...options.afterTextCommands);
  }
  return commands;
}
function formatPdfNumber(n) {
  return n.toFixed(6).replace(/\.?0+$/, "");
}

// src/pdf/shading/gradient-service.ts
var GLOBAL_GRADIENT_SERVICE_ID = 0;
var GradientService = class {
  constructor(coordinateTransformer) {
    this.coordinateTransformer = coordinateTransformer;
    this.shadings = /* @__PURE__ */ new Map();
    this.shadingCounter = 0;
    this.serviceId = GLOBAL_GRADIENT_SERVICE_ID++;
  }
  createLinearGradient(gradient, rect) {
    const shadingName = this.generateShadingName();
    const stops = this.normalizeStops(gradient.stops);
    const offsetX = gradient.renderOffset?.x ?? 0;
    const offsetY = gradient.renderOffset?.y ?? 0;
    const scaleX = gradient.renderScale?.x ?? 1;
    const scaleY = gradient.renderScale?.y ?? 1;
    const coordRect = {
      x: (rect.x ?? 0) + offsetX,
      y: (rect.y ?? 0) + offsetY,
      width: rect.width * scaleX,
      height: rect.height * scaleY
    };
    let coords;
    if (gradient.coords && gradient.coords.units === "userSpace") {
      const x0 = gradient.coords.x1 - coordRect.x;
      const y0 = gradient.coords.y1 - coordRect.y;
      const x1 = gradient.coords.x2 - coordRect.x;
      const y1 = gradient.coords.y2 - coordRect.y;
      coords = [
        x0,
        y0,
        x1,
        y1
      ];
    } else if (gradient.coords && gradient.coords.units === "ratio") {
      const widthPx = Math.max(coordRect.width, 0);
      const heightPx = Math.max(coordRect.height, 0);
      const x0 = gradient.coords.x1 * widthPx;
      const y0 = gradient.coords.y1 * heightPx;
      const x1 = gradient.coords.x2 * widthPx;
      const y1 = gradient.coords.y2 * heightPx;
      coords = [x0, y0, x1, y1];
    } else {
      coords = this.calculateGradientCoordinates(gradient, coordRect);
    }
    const interpolationFn = this.buildInterpolationFunction(stops);
    const dictionary = [
      "<<",
      "/ShadingType 2",
      "/ColorSpace /DeviceRGB",
      `/Coords [${coords.map(formatNumber3).join(" ")}]`,
      "/Domain [0 1]",
      `/Function ${interpolationFn}`,
      "/Extend [true true]",
      ">>"
    ].join("\n");
    const shading = { shadingName, dictionary };
    this.shadings.set(shadingName, shading);
    return shading;
  }
  createPatternFromLinearGradient(gradient, rect) {
    const shading = this.createLinearGradient(gradient, { x: rect.x, y: rect.y, width: rect.width, height: rect.height });
    const patternName = `${shading.shadingName}_Pat`;
    const scale = this.coordinateTransformer.convertPxToPt(1);
    const localY = (rect.y ?? 0) - this.coordinateTransformer.pageOffsetPx;
    const tx = this.coordinateTransformer.convertPxToPt(rect.x ?? 0);
    const ty = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY);
    const dict = [
      "<<",
      "/Type /Pattern",
      "/PatternType 2",
      `/Shading ${shading.dictionary}`,
      `/Matrix [${formatNumber3(scale)} 0 0 ${formatNumber3(-scale)} ${formatNumber3(tx)} ${formatNumber3(ty)}]`,
      ">>"
    ].join("\n");
    return { patternName, dictionary: dict };
  }
  createRadialGradient(gradient, rect) {
    const shadingName = this.generateShadingName();
    const stops = this.normalizeStops(gradient.stops);
    const widthPx = Math.max(rect.width, 0);
    const heightPx = Math.max(rect.height, 0);
    const safeWidth = widthPx > 0 ? widthPx : 1;
    const safeHeight = heightPx > 0 ? heightPx : 1;
    let coords;
    let matrixEntry = null;
    if (gradient.coordsUnits === "userSpace") {
      const cxPx = gradient.cx ?? 0;
      const cyPx = gradient.cy ?? 0;
      const rPx = gradient.r ?? 0;
      const localCxPx = cxPx - (rect.x ?? 0);
      const localCyPx = cyPx - (rect.y ?? 0);
      const centerX = localCxPx;
      const centerY = localCyPx;
      const radius = rPx;
      if (gradient.fx !== void 0 && gradient.fy !== void 0) {
        const fxPx = gradient.fx - (rect.x ?? 0);
        const fyPx = gradient.fy - (rect.y ?? 0);
        const focalX = fxPx;
        const focalY = fyPx;
        coords = [focalX, focalY, 0, centerX, centerY, radius];
      } else {
        coords = [centerX, centerY, 0, centerX, centerY, radius];
      }
    } else {
      const cx = gradient.cx ?? 0.5;
      const cy = gradient.cy ?? 0.5;
      const r = gradient.r ?? 0.5;
      if (gradient.transform) {
        const t = gradient.transform;
        const apply = (x, y) => {
          return {
            x: t.a * x + t.c * y + t.e,
            y: t.b * x + t.d * y + t.f
          };
        };
        const tc = apply(cx, cy);
        const te = apply(cx + r, cy);
        const centerX = tc.x * safeWidth;
        const centerY = tc.y * safeHeight;
        const edgeX = te.x * safeWidth;
        const edgeY = te.y * safeHeight;
        const radius = Math.sqrt((edgeX - centerX) * (edgeX - centerX) + (edgeY - centerY) * (edgeY - centerY));
        if (gradient.fx !== void 0 && gradient.fy !== void 0) {
          const tf = apply(gradient.fx, gradient.fy);
          const fx = tf.x * safeWidth;
          const fy = tf.y * safeHeight;
          coords = [fx, fy, 0, centerX, centerY, radius];
        } else {
          coords = [centerX, centerY, 0, centerX, centerY, radius];
        }
      } else {
        const centerX = cx * safeWidth;
        const centerY = cy * safeHeight;
        const radius = r * Math.max(safeWidth, safeHeight);
        if (gradient.fx !== void 0 && gradient.fy !== void 0) {
          const fx = gradient.fx * safeWidth;
          const fy = gradient.fy * safeHeight;
          coords = [fx, fy, 0, centerX, centerY, radius];
        } else {
          coords = [centerX, centerY, 0, centerX, centerY, radius];
        }
      }
    }
    const interpolationFn = this.buildInterpolationFunction(stops);
    const dictionary = [
      "<<",
      "/ShadingType 3",
      "/ColorSpace /DeviceRGB",
      `/Coords [${coords.map(formatNumber3).join(" ")}]`,
      ...matrixEntry ? [matrixEntry] : [],
      "/Domain [0 1]",
      `/Function ${interpolationFn}`,
      "/Extend [true true]",
      ">>"
    ].join("\n");
    const shading = { shadingName, dictionary };
    this.shadings.set(shadingName, shading);
    return shading;
  }
  getShadings() {
    const result = /* @__PURE__ */ new Map();
    for (const { shadingName, dictionary } of this.shadings.values()) {
      result.set(shadingName, dictionary);
    }
    return result;
  }
  clear() {
    this.shadings.clear();
    this.shadingCounter = 0;
  }
  generateShadingName() {
    return `Sh${this.serviceId}_${this.shadingCounter++}`;
  }
  calculateGradientCoordinates(gradient, rect) {
    const widthPx = Math.max(rect.width, 0);
    const heightPx = Math.max(rect.height, 0);
    const safeWidth = widthPx > 0 ? widthPx : 1;
    const safeHeight = heightPx > 0 ? heightPx : 1;
    const centerX = safeWidth / 2;
    const centerY = safeHeight / 2;
    switch (gradient.direction) {
      case "to right":
        return [0, centerY, safeWidth, centerY];
      case "to left":
        return [safeWidth, centerY, 0, centerY];
      case "to bottom":
        return [centerX, 0, centerX, safeHeight];
      case "to top":
        return [centerX, safeHeight, centerX, 0];
      case "to top right":
        return [0, safeHeight, safeWidth, 0];
      case "to top left":
        return [safeWidth, safeHeight, 0, 0];
      case "to bottom right":
        return [0, 0, safeWidth, safeHeight];
      case "to bottom left":
        return [safeWidth, 0, 0, safeHeight];
      default:
        if (gradient.direction.endsWith("deg")) {
          const angle = Number.parseFloat(gradient.direction);
          return this.calculateCoordinatesFromAngle(angle, safeWidth, safeHeight);
        }
        return [0, centerY, safeWidth, centerY];
    }
  }
  calculateCoordinatesFromAngle(angleDeg, widthPt, heightPt) {
    if (!Number.isFinite(angleDeg)) {
      return [0, heightPt / 2, widthPt, heightPt / 2];
    }
    const normalized = (angleDeg % 360 + 360) % 360;
    const radians = normalized * Math.PI / 180;
    const dirX = Math.sin(radians);
    const dirY = -Math.cos(radians);
    const halfWidth = widthPt / 2;
    const halfHeight = heightPt / 2;
    const extent = this.computeMaxExtent(dirX, dirY, halfWidth, halfHeight);
    const startX = halfWidth - dirX * extent;
    const startY = halfHeight - dirY * extent;
    const endX = halfWidth + dirX * extent;
    const endY = halfHeight + dirY * extent;
    return [startX, startY, endX, endY];
  }
  computeMaxExtent(dirX, dirY, halfWidth, halfHeight) {
    const epsilon = 1e-6;
    const absX = Math.abs(dirX);
    const absY = Math.abs(dirY);
    if (absX <= epsilon && absY <= epsilon) {
      return 0;
    }
    if (absX <= epsilon) {
      return halfHeight / absY;
    }
    if (absY <= epsilon) {
      return halfWidth / absX;
    }
    return Math.max(halfWidth / absX, halfHeight / absY);
  }
  normalizeStops(stops) {
    if (stops.length === 0) {
      return [{ color: this.parseColor("#000000"), position: 0 }];
    }
    const enriched = stops.map((stop) => ({
      color: this.parseColor(stop.color),
      position: stop.position
    }));
    const hasExplicit = enriched.some((stop) => stop.position !== void 0);
    if (!hasExplicit) {
      if (enriched.length === 1) {
        return [{ color: enriched[0].color, position: 0 }];
      }
      const denom = enriched.length - 1;
      return enriched.map((stop, index) => ({
        color: stop.color,
        position: denom === 0 ? 0 : index / denom
      }));
    }
    const positions = enriched.map((stop) => stop.position);
    if (positions[0] === void 0) {
      positions[0] = 0;
    }
    if (positions[positions.length - 1] === void 0) {
      positions[positions.length - 1] = 1;
    }
    let lastDefinedIndex = 0;
    positions[lastDefinedIndex] = clampUnit4(positions[lastDefinedIndex] ?? 0);
    for (let i = 1; i < positions.length; i++) {
      const current2 = positions[i];
      if (current2 === void 0) {
        continue;
      }
      const start = positions[lastDefinedIndex] ?? 0;
      const end = clampUnit4(current2);
      const span = i - lastDefinedIndex;
      if (span > 1) {
        for (let j = 1; j < span; j++) {
          const ratio = j / span;
          const value = start + (end - start) * ratio;
          positions[lastDefinedIndex + j] = clampUnit4(value);
        }
      }
      positions[i] = end;
      lastDefinedIndex = i;
    }
    for (let i = 1; i < positions.length; i++) {
      if (positions[i] === void 0) {
        positions[i] = positions[i - 1];
      }
    }
    const normalized = [];
    let previous = clampUnit4(positions[0] ?? 0);
    normalized.push({ color: enriched[0].color, position: previous });
    for (let i = 1; i < positions.length; i++) {
      const current2 = clampUnit4(positions[i] ?? previous);
      const monotonic = current2 < previous ? previous : current2;
      normalized.push({ color: enriched[i].color, position: monotonic });
      previous = monotonic;
    }
    if (normalized.length === 1) {
      const [only] = normalized;
      return [{ color: only.color, position: 0 }, { color: only.color, position: 1 }];
    }
    normalized[0].position = 0;
    normalized[normalized.length - 1].position = 1;
    return normalized;
  }
  buildInterpolationFunction(stops) {
    if (stops.length <= 1) {
      const color = stops.length === 1 ? stops[0].color : this.parseColor("#000000");
      return serializeType2Function(color, color);
    }
    const segments = [];
    for (let i = 0; i < stops.length - 1; i++) {
      const start = stops[i];
      const end = stops[i + 1];
      if (end.position <= start.position) {
        continue;
      }
      segments.push({ start, end });
    }
    if (segments.length === 0) {
      const color = stops[stops.length - 1].color;
      return serializeType2Function(color, color);
    }
    if (segments.length === 1) {
      const [segment] = segments;
      return serializeType2Function(segment.start.color, segment.end.color);
    }
    const bounds = [];
    const encodeParts = [];
    const functionParts = [];
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i < segments.length - 1) {
        bounds.push(formatNumber3(segment.end.position));
      }
      encodeParts.push("0 1");
      functionParts.push(serializeType2Function(segment.start.color, segment.end.color));
    }
    const functionDict = [
      "<<",
      "/FunctionType 3",
      "/Domain [0 1]",
      `/Bounds [${bounds.join(" ")}]`,
      `/Encode [${encodeParts.join(" ")}]`,
      "/Functions [",
      functionParts.join("\n"),
      "]",
      ">>"
    ].join("\n");
    return functionDict;
  }
  parseColor(colorStr) {
    const rgba = parseColor(colorStr);
    return rgbaToUnitRgb(rgba);
  }
};
function rgbaToUnitRgb(color) {
  if (!color) {
    return { r: 1, g: 1, b: 1 };
  }
  const alpha = color.a ?? 1;
  const r = normalizeChannel2(color.r);
  const g = normalizeChannel2(color.g);
  const b = normalizeChannel2(color.b);
  if (alpha >= 1) {
    return { r, g, b };
  }
  return {
    r: r * alpha + (1 - alpha),
    g: g * alpha + (1 - alpha),
    b: b * alpha + (1 - alpha)
  };
}
function clampUnit4(value) {
  if (!Number.isFinite(value ?? NaN)) {
    return 0;
  }
  if ((value ?? 0) <= 0) {
    return 0;
  }
  if ((value ?? 0) >= 1) {
    return 1;
  }
  return value ?? 0;
}
function serializeType2Function(start, end) {
  return [
    "<<",
    "/FunctionType 2",
    "/Domain [0 1]",
    `/C0 [ ${formatNumber3(start.r)} ${formatNumber3(start.g)} ${formatNumber3(start.b)} ]`,
    `/C1 [ ${formatNumber3(end.r)} ${formatNumber3(end.g)} ${formatNumber3(end.b)} ]`,
    "/N 1",
    ">>"
  ].join("\n");
}
function normalizeChannel2(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  if (value > 1) {
    return Math.min(Math.max(value / 255, 0), 1);
  }
  if (value < 0) {
    return 0;
  }
  return value;
}
function formatNumber3(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return Number.isInteger(value) ? value.toString() : value.toFixed(5).replace(/0+$/, "").replace(/\.$/, "");
}

// src/pdf/renderers/shape-utils.ts
function strokeColorCommand(color) {
  const r = formatNumber4(normalizeChannel3(color.r));
  const g = formatNumber4(normalizeChannel3(color.g));
  const b = formatNumber4(normalizeChannel3(color.b));
  return `${r} ${g} ${b} RG`;
}
function fillColorCommand2(color) {
  const r = formatNumber4(normalizeChannel3(color.r));
  const g = formatNumber4(normalizeChannel3(color.g));
  const b = formatNumber4(normalizeChannel3(color.b));
  return `${r} ${g} ${b} rg`;
}
function mapLineCap(cap) {
  switch (cap) {
    case "butt":
      return 0;
    case "round":
      return 1;
    case "square":
      return 2;
    default:
      return void 0;
  }
}
function mapLineJoin(join) {
  switch (join) {
    case "miter":
      return 0;
    case "round":
      return 1;
    case "bevel":
      return 2;
    default:
      return void 0;
  }
}
function normalizeChannel3(value) {
  if (value > 1) {
    return value / 255;
  }
  return value;
}
function formatNumber4(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return Number.isInteger(value) ? value.toString() : value.toFixed(4).replace(/0+$/, "").replace(/\.$/, "");
}
function rectToPdf(rect, coordinateTransformer, transformContext) {
  if (!rect) {
    return null;
  }
  const widthPx = Math.max(rect.width, 0);
  const heightPx = Math.max(rect.height, 0);
  if (widthPx === 0 || heightPx === 0) {
    return null;
  }
  if (transformContext) {
    const relX = rect.x - transformContext.x;
    const relY = rect.y - transformContext.y;
    const x2 = coordinateTransformer.convertPxToPt(relX);
    const y2 = coordinateTransformer.convertPxToPt(-(relY + heightPx));
    const width2 = coordinateTransformer.convertPxToPt(widthPx);
    const height2 = coordinateTransformer.convertPxToPt(heightPx);
    return {
      x: formatNumber4(x2),
      y: formatNumber4(y2),
      width: formatNumber4(width2),
      height: formatNumber4(height2)
    };
  }
  const localY = rect.y - coordinateTransformer.pageOffsetPx;
  const x = coordinateTransformer.convertPxToPt(rect.x);
  const y = coordinateTransformer.pageHeightPt - coordinateTransformer.convertPxToPt(localY + heightPx);
  const width = coordinateTransformer.convertPxToPt(widthPx);
  const height = coordinateTransformer.convertPxToPt(heightPx);
  return {
    x: formatNumber4(x),
    y: formatNumber4(y),
    width: formatNumber4(width),
    height: formatNumber4(height)
  };
}
function pointToPdf(point, coordinateTransformer, transformContext) {
  if (transformContext) {
    const relX = point.x - transformContext.x;
    const relY = point.y - transformContext.y;
    const x2 = coordinateTransformer.convertPxToPt(relX);
    const y2 = coordinateTransformer.convertPxToPt(-relY);
    if (!Number.isFinite(x2) || !Number.isFinite(y2)) {
      return null;
    }
    return {
      x: formatNumber4(x2),
      y: formatNumber4(y2)
    };
  }
  const localY = point.y - coordinateTransformer.pageOffsetPx;
  const x = coordinateTransformer.convertPxToPt(point.x);
  const y = coordinateTransformer.pageHeightPt - coordinateTransformer.convertPxToPt(localY);
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    return null;
  }
  return {
    x: formatNumber4(x),
    y: formatNumber4(y)
  };
}
function transformForRect(rect, coordinateTransformer, transformContext) {
  if (transformContext) {
    const relX = rect.x - transformContext.x;
    const relY = rect.y - transformContext.y;
    const scaleX2 = coordinateTransformer.convertPxToPt(1);
    const scaleY2 = coordinateTransformer.convertPxToPt(1);
    const translateX2 = coordinateTransformer.convertPxToPt(relX);
    const translateY2 = coordinateTransformer.convertPxToPt(-relY);
    return `${formatNumber4(scaleX2)} 0 0 ${formatNumber4(scaleY2)} ${formatNumber4(translateX2)} ${formatNumber4(translateY2)} cm`;
  }
  const scaleX = coordinateTransformer.convertPxToPt(1);
  const scaleY = coordinateTransformer.convertPxToPt(1);
  const localY = rect.y - coordinateTransformer.pageOffsetPx;
  const translateX = coordinateTransformer.convertPxToPt(rect.x);
  const translateY = coordinateTransformer.pageHeightPt - coordinateTransformer.convertPxToPt(localY);
  return `${formatNumber4(scaleX)} 0 0 ${formatNumber4(-scaleY)} ${formatNumber4(translateX)} ${formatNumber4(translateY)} cm`;
}

// src/pdf/renderers/text-renderer.ts
var PINK = "\x1B[38;5;205m";
var RESET_COLOR = "\x1B[0m";
var TextRenderer = class {
  constructor(coordinateTransformer, fontRegistry, imageRenderer, graphicsStateManager) {
    this.coordinateTransformer = coordinateTransformer;
    this.fontRegistry = fontRegistry;
    this.commands = [];
    this.fonts = /* @__PURE__ */ new Map();
    this.patterns = /* @__PURE__ */ new Map();
    this.graphicsStateManager = graphicsStateManager;
    this.fontResolver = new TextFontResolver(fontRegistry);
    this.shadowRenderer = new TextShadowRenderer(coordinateTransformer, fontRegistry, imageRenderer, graphicsStateManager);
    this.decorationRenderer = new TextDecorationRenderer(coordinateTransformer, graphicsStateManager);
    this.gradientService = new GradientService(coordinateTransformer);
  }
  async drawText(text, xPx, yPx, options = { fontSizePt: 10 }) {
    if (!text) {
      return;
    }
    const fontFamily = options.fontFamily ?? "Times New Roman";
    const fontWeight = options.fontWeight ?? 400;
    const fontStyle = options.fontStyle ?? "normal";
    const fontVariant = options.fontVariant;
    const fontSizePx = this.coordinateTransformer.convertPtToPx(options.fontSizePt);
    const run = {
      text,
      fontFamily,
      fontWeight,
      fontStyle,
      fontVariant,
      fontSize: fontSizePx,
      letterSpacing: 0,
      wordSpacing: 0,
      fill: options.color ?? { r: 0, g: 0, b: 0, a: 1 },
      lineMatrix: {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: xPx,
        f: yPx
        // baseline em px, igual aos outros runs
      }
    };
    await this.drawTextRun(run);
  }
  async drawTextRun(run) {
    const font = await this.fontResolver.ensureFontResource({
      fontFamily: run.fontFamily,
      fontWeight: run.fontWeight,
      fontStyle: run.fontStyle,
      fontVariant: run.fontVariant,
      text: run.text
    });
    await this.drawTextRunWithGlyphs(run, font);
  }
  async drawTextRunWithGlyphs(run, font) {
    const color = run.fill ?? { r: 0, g: 0, b: 0, a: 1 };
    const fontSizePt = this.coordinateTransformer.convertPxToPt(run.fontSize);
    let glyphRun = run.glyphs;
    if (!glyphRun && font.metrics) {
      glyphRun = computeGlyphRunFromText(
        font.metrics,
        run.text,
        run.fontSize,
        run.letterSpacing ?? 0,
        {
          family: run.fontFamily,
          weight: run.fontWeight ?? 400,
          style: run.fontStyle ?? "normal"
        }
      );
    }
    if (!glyphRun) {
      log("paint", "warn", "Skipping run without glyph data", {
        text: run.text.slice(0, 32),
        fontFamily: run.fontFamily,
        fontSize: run.fontSize
      });
      return;
    }
    log("paint", "debug", `${PINK}USING GLYPH RUN${RESET_COLOR}`, {
      text: run.text.slice(0, 64),
      glyphCount: glyphRun.glyphIds.length
    });
    const Tm = run.lineMatrix ?? { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
    if (!run.lineMatrix) {
      log("paint", "debug", "Run provided without lineMatrix, using identity fallback", {
        text: run.text.slice(0, 32),
        fontFamily: run.fontFamily
      });
    }
    const localBaseline = Tm.f - this.coordinateTransformer.pageOffsetPx;
    const y = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localBaseline);
    const x = this.coordinateTransformer.convertPxToPt(Tm.e);
    log("paint", "debug", "drawing text run with glyphs", {
      text: run.text.slice(0, 32),
      glyphIds: glyphRun.glyphIds.slice(0, 10),
      fontSizePt,
      x,
      y
    });
    let normalizedText = run.text;
    if (run.fontVariant === "small-caps") {
      normalizedText = normalizedText.toUpperCase();
    }
    const { encoded } = encodeTextPayload(normalizedText, font);
    const wordSpacingPx = run.wordSpacing ?? 0;
    const wordSpacingPt = this.coordinateTransformer.convertPxToPt(wordSpacingPx);
    const appliedWordSpacing = wordSpacingPx !== 0 && wordSpacingPt !== 0;
    this.registerFont(font);
    if (run.textShadows && run.textShadows.length > 0) {
      const shadowCommands = await this.shadowRenderer.render({
        run,
        font,
        encoded,
        Tm,
        fontSizePt,
        fontSizePx: run.fontSize,
        wordSpacingPt,
        appliedWordSpacing,
        fontResourceName: font.resourceName
      });
      this.commands.push(...shadowCommands);
    }
    const subsetResource = this.fontRegistry.ensureSubsetForGlyphRun(glyphRun, font);
    this.registerSubsetFont(subsetResource.alias, subsetResource.ref);
    const gradientBackground = run.textGradient;
    if (gradientBackground && gradientBackground.rect && gradientBackground.rect.width > 0 && gradientBackground.rect.height > 0) {
      log("paint", "debug", "text run has background clip gradient", {
        text: run.text.slice(0, 32),
        rect: gradientBackground.rect
      });
      const gradientPaint = gradientBackground.gradient;
      const isLinear = gradientPaint.type === "linear";
      const isRadial = gradientPaint.type === "radial";
      if (isLinear || isRadial) {
        const pattern = this.gradientService.createPatternFromLinearGradient(
          gradientPaint,
          {
            width: gradientBackground.rect.width,
            height: gradientBackground.rect.height,
            x: gradientBackground.rect.x,
            y: gradientBackground.rect.y
          }
        );
        this.patterns.set(pattern.patternName, pattern.dictionary);
        const usePattern = [
          "q",
          `/Pattern cs`,
          `/${pattern.patternName} scn`
        ];
        const glyphPatternCommands = drawGlyphRun(
          glyphRun,
          subsetResource.subset,
          x,
          y,
          fontSizePt,
          color,
          this.graphicsStateManager,
          wordSpacingPt,
          { skipColor: true }
        );
        if (glyphPatternCommands.length > 0) {
          this.commands.push(...usePattern, ...glyphPatternCommands, "Q");
          if (run.decorations) {
            this.commands.push(...this.decorationRenderer.render(run, color));
          }
          return;
        }
      }
    }
    const glyphCommands = drawGlyphRun(
      glyphRun,
      subsetResource.subset,
      x,
      y,
      fontSizePt,
      color,
      this.graphicsStateManager,
      wordSpacingPt
    );
    this.commands.push(...glyphCommands);
    if (run.decorations) {
      this.commands.push(...this.decorationRenderer.render(run, color));
    }
  }
  registerFont(font) {
    if (!this.fonts.has(font.resourceName)) {
      this.fonts.set(font.resourceName, font.ref);
    }
  }
  registerSubsetFont(alias, ref) {
    this.fonts.set(alias, ref);
  }
  fillGradientRect(rect, gradient) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width <= 0 || height <= 0) {
      return [];
    }
    const shading = gradient.type === "radial" ? this.gradientService.createRadialGradient(gradient, rect) : this.gradientService.createLinearGradient(gradient, rect);
    return [
      "q",
      transformForRect(rect, this.coordinateTransformer, null),
      `0 0 ${formatNumber2(width)} ${formatNumber2(height)} re`,
      "W n",
      `/${shading.shadingName} sh`,
      "Q"
    ];
  }
  fillPatternRect(rect) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width <= 0 || height <= 0) {
      return [];
    }
    return [
      transformForRect(rect, this.coordinateTransformer, null),
      `0 0 ${formatNumber2(width)} ${formatNumber2(height)} re`,
      "f"
    ];
  }
  getResult() {
    return {
      commands: [...this.commands],
      fonts: new Map(this.fonts),
      shadings: this.gradientService.getShadings(),
      patterns: new Map(this.patterns)
    };
  }
};
function computeGlyphRunFromText(metrics, text, fontSize, letterSpacing, css) {
  const glyphIds = [];
  const positions = [];
  const unitsPerEm = metrics.metrics.unitsPerEm;
  let x = 0;
  for (let i = 0; i < text.length; i++) {
    const cp = text.codePointAt(i);
    const gid = metrics.cmap.getGlyphId(cp);
    glyphIds.push(gid);
    positions.push({ x, y: 0 });
    const advanceWidth = metrics.glyphMetrics.get(gid)?.advanceWidth ?? 0;
    const advancePx = advanceWidth / unitsPerEm * fontSize + letterSpacing;
    x += advancePx;
    if (cp > 65535) i++;
  }
  const unifiedFont = {
    metrics: {
      metrics: metrics.metrics,
      glyphMetrics: metrics.glyphMetrics,
      cmap: metrics.cmap,
      headBBox: metrics.headBBox
    },
    program: {
      sourceFormat: "ttf",
      unitsPerEm: metrics.metrics.unitsPerEm,
      glyphCount: metrics.glyphMetrics.size,
      getGlyphOutline: metrics.getGlyphOutline
    },
    css: {
      family: css.family ?? "",
      weight: css.weight,
      style: css.style
    }
  };
  return {
    font: unifiedFont,
    glyphIds,
    positions,
    text,
    fontSize,
    width: x
  };
}

// src/pdf/renderers/image-renderer.ts
var ImageRenderer = class {
  constructor(coordinateTransformer) {
    this.coordinateTransformer = coordinateTransformer;
    this.commands = [];
    this.imageResources = /* @__PURE__ */ new Map();
  }
  // Public helper to register an image resource and get its alias without emitting commands
  registerResource(image) {
    return this.ensureImageResource(image);
  }
  // Register atlas pages so they can be referenced by pageIndex later.
  registerAtlasPages(pages) {
    for (let i = 0; i < pages.length; i++) {
      const page = pages[i];
      const key2 = `atlas:${i}`;
      if (this.imageResources.has(key2)) continue;
      const alias = `Im${this.imageResources.size}`;
      const imageRef = {
        src: `atlas:${i}`,
        width: page.width,
        height: page.height,
        format: "png",
        channels: 4,
        bitsPerComponent: 8,
        data: page.data.buffer
      };
      this.imageResources.set(key2, { alias, image: imageRef });
    }
  }
  // Draw a region (sub-rectangle) from a registered atlas page into the destination rect (px coords).
  drawAtlasRegion(pageIndex, sx, sy, sw, sh, rect) {
    if (rect.width <= 0 || rect.height <= 0) return;
    const key2 = `atlas:${pageIndex}`;
    const res = this.imageResources.get(key2);
    if (!res) return;
    const widthPt = this.coordinateTransformer.convertPxToPt(rect.width);
    const heightPt = this.coordinateTransformer.convertPxToPt(rect.height);
    if (widthPt === 0 || heightPt === 0) return;
    const xPt = this.coordinateTransformer.convertPxToPt(rect.x);
    const localY = rect.y - this.coordinateTransformer.pageOffsetPx;
    const yPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY + rect.height);
    const a = widthPt / sw;
    const d = heightPt / sh;
    const tx = xPt - a * sx;
    const ty = yPt - d * sy;
    const cmds = [
      "q",
      `${formatNumber5(a)} 0 0 ${formatNumber5(d)} ${formatNumber5(tx)} ${formatNumber5(ty)} cm`,
      `/${res.alias} Do`,
      "Q"
    ];
    this.commands.push(...cmds);
  }
  drawImage(image, rect) {
    if (rect.width <= 0 || rect.height <= 0) {
      return;
    }
    const resource = this.ensureImageResource(image);
    const widthPt = this.coordinateTransformer.convertPxToPt(rect.width);
    const heightPt = this.coordinateTransformer.convertPxToPt(rect.height);
    if (widthPt === 0 || heightPt === 0) {
      return;
    }
    const xPt = this.coordinateTransformer.convertPxToPt(rect.x);
    const localY = rect.y - this.coordinateTransformer.pageOffsetPx;
    const yPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY + rect.height);
    this.commands.push(
      "q",
      `${formatNumber5(widthPt)} 0 0 ${formatNumber5(heightPt)} ${formatNumber5(xPt)} ${formatNumber5(yPt)} cm`,
      `/${resource.alias} Do`,
      "Q"
    );
  }
  ensureImageResource(image) {
    const key2 = `${image.src}|${image.data.byteLength ?? 0}`;
    let resource = this.imageResources.get(key2);
    if (!resource) {
      const alias = `Im${this.imageResources.size}`;
      resource = {
        alias,
        image: {
          ...image,
          data: image.data
          // This is actually an ArrayBuffer, not a Uint8Array
        }
      };
      this.imageResources.set(key2, resource);
    }
    return resource;
  }
  getResult() {
    return {
      commands: [...this.commands],
      images: new Map(this.imageResources)
    };
  }
};
function formatNumber5(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return Number.isInteger(value) ? value.toString() : value.toFixed(4).replace(/0+$/, "").replace(/\.$/, "");
}

// src/pdf/renderers/radius-utils.ts
function normalizeRadiiForRect(width, height, radii) {
  const result = {
    topLeft: { ...radii.topLeft },
    topRight: { ...radii.topRight },
    bottomRight: { ...radii.bottomRight },
    bottomLeft: { ...radii.bottomLeft }
  };
  const safeWidth = Math.max(width, 0);
  const safeHeight = Math.max(height, 0);
  if (safeWidth <= 0) {
    result.topLeft.x = 0;
    result.topRight.x = 0;
    result.bottomRight.x = 0;
    result.bottomLeft.x = 0;
  } else {
    const topSum = result.topLeft.x + result.topRight.x;
    if (topSum > safeWidth && topSum > 0) {
      const scale = safeWidth / topSum;
      result.topLeft.x *= scale;
      result.topRight.x *= scale;
    }
    const bottomSum = result.bottomLeft.x + result.bottomRight.x;
    if (bottomSum > safeWidth && bottomSum > 0) {
      const scale = safeWidth / bottomSum;
      result.bottomLeft.x *= scale;
      result.bottomRight.x *= scale;
    }
  }
  if (safeHeight <= 0) {
    result.topLeft.y = 0;
    result.topRight.y = 0;
    result.bottomRight.y = 0;
    result.bottomLeft.y = 0;
  } else {
    const leftSum = result.topLeft.y + result.bottomLeft.y;
    if (leftSum > safeHeight && leftSum > 0) {
      const scale = safeHeight / leftSum;
      result.topLeft.y *= scale;
      result.bottomLeft.y *= scale;
    }
    const rightSum = result.topRight.y + result.bottomRight.y;
    if (rightSum > safeHeight && rightSum > 0) {
      const scale = safeHeight / rightSum;
      result.topRight.y *= scale;
      result.bottomRight.y *= scale;
    }
  }
  return result;
}
function isZeroRadius(radii) {
  return radii.topLeft.x === 0 && radii.topLeft.y === 0 && radii.topRight.x === 0 && radii.topRight.y === 0 && radii.bottomRight.x === 0 && radii.bottomRight.y === 0 && radii.bottomLeft.x === 0 && radii.bottomLeft.y === 0;
}

// src/pdf/renderers/rounded-rect-path.ts
function generateRoundedRectPath(width, height, radii, offsetX, offsetY) {
  const commands = [];
  if (width <= 0 || height <= 0) {
    return commands;
  }
  const tl = radii.topLeft;
  const tr = radii.topRight;
  const br = radii.bottomRight;
  const bl = radii.bottomLeft;
  const k = 0.5522847498307936;
  const moveX = offsetX + tl.x;
  const moveY = offsetY;
  commands.push(`${formatNumber4(moveX)} ${formatNumber4(moveY)} m`);
  commands.push(`${formatNumber4(offsetX + width - tr.x)} ${formatNumber4(offsetY)} l`);
  if (tr.x > 0 || tr.y > 0) {
    const cp1x = offsetX + width - tr.x + k * tr.x;
    const cp1y = offsetY;
    const cp2x = offsetX + width;
    const cp2y = offsetY + tr.y - k * tr.y;
    const endX = offsetX + width;
    const endY = offsetY + tr.y;
    commands.push(
      `${formatNumber4(cp1x)} ${formatNumber4(cp1y)} ${formatNumber4(cp2x)} ${formatNumber4(cp2y)} ${formatNumber4(endX)} ${formatNumber4(endY)} c`
    );
  } else {
    commands.push(`${formatNumber4(offsetX + width)} ${formatNumber4(offsetY)} l`);
  }
  commands.push(`${formatNumber4(offsetX + width)} ${formatNumber4(offsetY + height - br.y)} l`);
  if (br.x > 0 || br.y > 0) {
    const cp1x = offsetX + width;
    const cp1y = offsetY + height - br.y + k * br.y;
    const cp2x = offsetX + width - br.x + k * br.x;
    const cp2y = offsetY + height;
    const endX = offsetX + width - br.x;
    const endY = offsetY + height;
    commands.push(
      `${formatNumber4(cp1x)} ${formatNumber4(cp1y)} ${formatNumber4(cp2x)} ${formatNumber4(cp2y)} ${formatNumber4(endX)} ${formatNumber4(endY)} c`
    );
  } else {
    commands.push(`${formatNumber4(offsetX + width)} ${formatNumber4(offsetY + height)} l`);
  }
  commands.push(`${formatNumber4(offsetX + bl.x)} ${formatNumber4(offsetY + height)} l`);
  if (bl.x > 0 || bl.y > 0) {
    const cp1x = offsetX + bl.x - k * bl.x;
    const cp1y = offsetY + height;
    const cp2x = offsetX;
    const cp2y = offsetY + height - bl.y + k * bl.y;
    const endX = offsetX;
    const endY = offsetY + height - bl.y;
    commands.push(
      `${formatNumber4(cp1x)} ${formatNumber4(cp1y)} ${formatNumber4(cp2x)} ${formatNumber4(cp2y)} ${formatNumber4(endX)} ${formatNumber4(endY)} c`
    );
  } else {
    commands.push(`${formatNumber4(offsetX)} ${formatNumber4(offsetY + height)} l`);
  }
  commands.push(`${formatNumber4(offsetX)} ${formatNumber4(offsetY + tl.y)} l`);
  if (tl.x > 0 || tl.y > 0) {
    const cp1x = offsetX;
    const cp1y = offsetY + tl.y - k * tl.y;
    const cp2x = offsetX + tl.x - k * tl.x;
    const cp2y = offsetY;
    const endX = offsetX + tl.x;
    const endY = offsetY;
    commands.push(
      `${formatNumber4(cp1x)} ${formatNumber4(cp1y)} ${formatNumber4(cp2x)} ${formatNumber4(cp2y)} ${formatNumber4(endX)} ${formatNumber4(endY)} c`
    );
  } else {
    commands.push(`${formatNumber4(offsetX)} ${formatNumber4(offsetY)} l`);
  }
  commands.push("h");
  return commands;
}

// src/pdf/renderers/shape-renderer.ts
var ShapeRenderer = class {
  constructor(coordinateTransformer, graphicsStateManager) {
    this.coordinateTransformer = coordinateTransformer;
    this.graphicsStateManager = graphicsStateManager;
    this.commands = [];
    this.transformContext = null;
    this.gradientService = new GradientService(coordinateTransformer);
  }
  setTransformContext(rect) {
    this.transformContext = rect;
  }
  clearTransformContext() {
    this.transformContext = null;
  }
  drawBoxOutline(rect, color = { r: 0.85, g: 0.85, b: 0.85, a: 1 }) {
    this.strokeRect(rect, color);
  }
  drawFilledBox(rect, color) {
    this.fillRect(rect, color);
  }
  fillRoundedRect(rect, radii, paint) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width === 0 || height === 0) {
      return;
    }
    const gradient = resolveGradientPaint2(paint);
    if (gradient) {
      if (gradient.type === "radial") {
        this.fillRoundedRectWithRadialGradient(rect, radii, gradient);
      } else {
        this.fillRoundedRectWithGradient(rect, radii, gradient);
      }
      return;
    }
    if (typeof paint !== "object" || paint === null) {
      return;
    }
    const adjusted = normalizeRadiiForRect(width, height, radii);
    if (isZeroRadius(adjusted)) {
      this.fillRect(rect, paint);
      return;
    }
    const path = generateRoundedRectPath(width, height, adjusted, 0, 0);
    if (path.length === 0) {
      return;
    }
    const commands = [this.transformForRect(rect), ...path, "f"];
    this.pushFillCommands(paint, commands, true);
  }
  // Allow low-level injection of drawing commands to preserve ordering (used for raster shadows)
  pushRawCommands(commands) {
    if (!Array.isArray(commands) || commands.length === 0) return;
    this.commands.push(...commands);
  }
  fillRoundedRectWithGradient(rect, radii, gradient) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width === 0 || height === 0) {
      return;
    }
    const adjusted = normalizeRadiiForRect(width, height, radii);
    if (isZeroRadius(adjusted)) {
      this.fillRectWithGradient(rect, gradient);
      return;
    }
    const path = generateRoundedRectPath(width, height, adjusted, 0, 0);
    if (path.length === 0) {
      return;
    }
    const shading = this.gradientService.createLinearGradient(gradient, rect);
    this.commands.push("q");
    this.commands.push(this.transformForRect(rect));
    this.commands.push(...path);
    this.commands.push("W n");
    this.commands.push(`/${shading.shadingName} sh`);
    this.commands.push("Q");
  }
  fillRectWithGradient(rect, gradient) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width === 0 || height === 0) {
      return;
    }
    const shading = this.gradientService.createLinearGradient(gradient, rect);
    this.commands.push("q");
    this.commands.push(this.transformForRect(rect));
    this.commands.push(`0 0 ${formatNumber4(width)} ${formatNumber4(height)} re`);
    this.commands.push("W n");
    this.commands.push(`/${shading.shadingName} sh`);
    this.commands.push("Q");
  }
  fillRoundedRectWithRadialGradient(rect, radii, gradient) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width === 0 || height === 0) {
      return;
    }
    const adjusted = normalizeRadiiForRect(width, height, radii);
    if (isZeroRadius(adjusted)) {
      this.fillRectWithRadialGradient(rect, gradient);
      return;
    }
    const path = generateRoundedRectPath(width, height, adjusted, 0, 0);
    if (path.length === 0) {
      return;
    }
    const shading = this.gradientService.createRadialGradient(gradient, rect);
    this.commands.push("q");
    this.commands.push(this.transformForRect(rect));
    this.commands.push(...path);
    this.commands.push("W n");
    this.commands.push(`/${shading.shadingName} sh`);
    this.commands.push("Q");
  }
  fillRectWithRadialGradient(rect, gradient) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width === 0 || height === 0) {
      return;
    }
    const shading = this.gradientService.createRadialGradient(gradient, rect);
    this.commands.push("q");
    this.commands.push(this.transformForRect(rect));
    this.commands.push(`0 0 ${formatNumber4(width)} ${formatNumber4(height)} re`);
    this.commands.push("W n");
    this.commands.push(`/${shading.shadingName} sh`);
    this.commands.push("Q");
  }
  fillRoundedRectDifference(outerRect, outerRadii, innerRect, innerRadii, color) {
    const outerWidth = Math.max(outerRect.width, 0);
    const outerHeight = Math.max(outerRect.height, 0);
    if (outerWidth === 0 || outerHeight === 0) {
      return;
    }
    const outerAdjusted = normalizeRadiiForRect(outerWidth, outerHeight, outerRadii);
    const innerWidth = Math.max(innerRect.width, 0);
    const innerHeight = Math.max(innerRect.height, 0);
    if (innerWidth <= 0 || innerHeight <= 0) {
      this.fillRoundedRect(outerRect, outerAdjusted, color);
      return;
    }
    const pathOuter = generateRoundedRectPath(outerWidth, outerHeight, outerAdjusted, 0, 0);
    if (pathOuter.length === 0) {
      return;
    }
    const innerAdjusted = normalizeRadiiForRect(innerWidth, innerHeight, innerRadii);
    const offsetX = innerRect.x - outerRect.x;
    const offsetY = innerRect.y - outerRect.y;
    const pathInner = generateRoundedRectPath(innerWidth, innerHeight, innerAdjusted, offsetX, offsetY);
    const commands = [this.transformForRect(outerRect), ...pathOuter, ...pathInner, "f*"];
    this.pushFillCommands(color, commands, true);
  }
  fillRect(rect, paint) {
    const gradient = resolveGradientPaint2(paint);
    if (gradient) {
      if (gradient.type === "radial") {
        this.fillRectWithRadialGradient(rect, gradient);
      } else {
        this.fillRectWithGradient(rect, gradient);
      }
      return;
    }
    if (typeof paint !== "object" || paint === null) {
      return;
    }
    const pdfRect = this.rectToPdf(rect);
    if (!pdfRect) {
      return;
    }
    const commands = [`${pdfRect.x} ${pdfRect.y} ${pdfRect.width} ${pdfRect.height} re`, "f"];
    this.pushFillCommands(paint, commands, false);
  }
  strokeRect(rect, color) {
    const pdfRect = this.rectToPdf(rect);
    if (!pdfRect) {
      return;
    }
    this.commands.push(strokeColorCommand(color), `${pdfRect.x} ${pdfRect.y} ${pdfRect.width} ${pdfRect.height} re`, "S");
  }
  strokeRoundedRect(rect, radii, color, lineWidth) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width === 0 || height === 0) {
      return;
    }
    const adjusted = normalizeRadiiForRect(width, height, radii);
    const path = generateRoundedRectPath(width, height, adjusted, 0, 0);
    if (path.length === 0) {
      return;
    }
    this.commands.push("q", strokeColorCommand(color));
    if (lineWidth !== void 0) {
      const strokeWidthPt = this.coordinateTransformer.convertPxToPt(Math.max(lineWidth, 0));
      if (strokeWidthPt > 0) {
        this.commands.push(`${formatNumber4(strokeWidthPt)} w`);
      }
    }
    this.commands.push(this.transformForRect(rect), ...path, "S", "Q");
  }
  fillPolygon(points, color, close = true) {
    if (points.length < 2) {
      return;
    }
    const pdfPoints = this.pointsToPdf(points);
    if (!pdfPoints) {
      return;
    }
    const commands = [];
    commands.push(`${pdfPoints[0].x} ${pdfPoints[0].y} m`);
    for (let index = 1; index < pdfPoints.length; index++) {
      const point = pdfPoints[index];
      commands.push(`${point.x} ${point.y} l`);
    }
    if (close) {
      commands.push("h");
    }
    commands.push("f");
    this.pushFillCommands(color, commands, true);
  }
  strokePolyline(points, color, options = {}) {
    if (points.length < 2) {
      return;
    }
    const pdfPoints = this.pointsToPdf(points);
    if (!pdfPoints) {
      return;
    }
    const commands = [];
    commands.push(`${pdfPoints[0].x} ${pdfPoints[0].y} m`);
    for (let index = 1; index < pdfPoints.length; index++) {
      const point = pdfPoints[index];
      commands.push(`${point.x} ${point.y} l`);
    }
    if (options.close) {
      commands.push("h");
    }
    commands.push("S");
    this.commands.push("q", strokeColorCommand(color));
    this.applyStrokeOptions(options);
    this.commands.push(...commands, "Q");
  }
  fillPath(commands, color, options = {}) {
    if (commands.length === 0) {
      return;
    }
    const pdfCommands = this.pathCommandsToPdf(commands);
    if (!pdfCommands || pdfCommands.length === 0) {
      return;
    }
    const operator = options.fillRule === "evenodd" ? "f*" : "f";
    this.pushFillCommands(color, [...pdfCommands, operator], false);
  }
  beginClipPath(commands, options = {}) {
    if (!commands || commands.length === 0) {
      return false;
    }
    const pdfCommands = this.pathCommandsToPdf(commands);
    if (!pdfCommands || pdfCommands.length === 0) {
      return false;
    }
    const clipOp = options.fillRule === "evenodd" ? "W*" : "W";
    this.commands.push("q", ...pdfCommands, `${clipOp} n`);
    return true;
  }
  endClipPath() {
    this.commands.push("Q");
  }
  // New: fill an arbitrary path with a gradient. We compute a bounding box of the path
  // (in page pixels) and use it as the gradient rectangle when creating the shading.
  // The path itself is converted to PDF commands and used as the clipping path before
  // painting the shading.
  fillPathWithGradient(commands, gradient, _options = {}) {
    if (!commands || commands.length === 0) return;
    const pdfCommands = this.pathCommandsToPdf(commands);
    if (!pdfCommands || pdfCommands.length === 0) return;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (const cmd of commands) {
      if (cmd.type === "moveTo" || cmd.type === "lineTo") {
        minX = Math.min(minX, cmd.x);
        minY = Math.min(minY, cmd.y);
        maxX = Math.max(maxX, cmd.x);
        maxY = Math.max(maxY, cmd.y);
      } else if (cmd.type === "curveTo") {
        minX = Math.min(minX, cmd.x1, cmd.x2, cmd.x);
        minY = Math.min(minY, cmd.y1, cmd.y2, cmd.y);
        maxX = Math.max(maxX, cmd.x1, cmd.x2, cmd.x);
        maxY = Math.max(maxY, cmd.y1, cmd.y2, cmd.y);
      }
    }
    if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
      return;
    }
    const rect = { x: minX, y: minY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
    const shading = gradient.type === "radial" ? this.gradientService.createRadialGradient(gradient, rect) : this.gradientService.createLinearGradient(gradient, rect);
    this.commands.push("q");
    this.commands.push(...pdfCommands);
    this.commands.push("W n");
    this.commands.push(`/${shading.shadingName} sh`);
    this.commands.push("Q");
  }
  strokePath(commands, color, options = {}) {
    if (commands.length === 0) {
      return;
    }
    const pdfCommands = this.pathCommandsToPdf(commands);
    if (!pdfCommands || pdfCommands.length === 0) {
      return;
    }
    this.commands.push("q", strokeColorCommand(color));
    this.applyStrokeOptions(options);
    this.commands.push(...pdfCommands, "S");
    if (options.dash && Array.isArray(options.dash.pattern) && options.dash.pattern.length > 0) {
      this.commands.push("[] 0 d");
    }
    this.commands.push("Q");
  }
  applyStrokeOptions(options) {
    if (options.lineWidth !== void 0) {
      const widthPt = this.coordinateTransformer.convertPxToPt(Math.max(options.lineWidth, 0));
      if (widthPt > 0) {
        this.commands.push(`${formatNumber4(widthPt)} w`);
      }
    }
    const cap = mapLineCap(options.lineCap);
    if (cap !== void 0) {
      this.commands.push(`${cap} J`);
    }
    const join = mapLineJoin(options.lineJoin);
    if (join !== void 0) {
      this.commands.push(`${join} j`);
    }
    const dash = options.dash;
    if (dash && Array.isArray(dash.pattern) && dash.pattern.length > 0) {
      const patternPt = dash.pattern.map((v) => this.coordinateTransformer.convertPxToPt(Math.max(v, 0))).map(formatNumber4);
      const phasePt = formatNumber4(
        this.coordinateTransformer.convertPxToPt(Math.max(dash.phase ?? 0, 0))
      );
      this.commands.push(`[${patternPt.join(" ")}] ${phasePt} d`);
    }
  }
  pushFillCommands(color, commands, wrapWithQ) {
    const alpha = color.a ?? 1;
    const hasAlpha = alpha < 1;
    const baseColor = { r: color.r, g: color.g, b: color.b, a: alpha };
    const needsIsolation = wrapWithQ || hasAlpha;
    this.commands.push(fillColorCommand2(baseColor));
    if (needsIsolation) {
      this.commands.push("q");
    }
    if (hasAlpha) {
      const state = this.graphicsStateManager.ensureFillAlphaState(alpha);
      this.commands.push(`/${state} gs`);
    }
    this.commands.push(...commands);
    if (needsIsolation) {
      this.commands.push("Q");
    }
  }
  // normalizeRadiiForRect and isZeroRadius now imported from radius-utils.ts
  pathCommandsToPdf(commands) {
    const result = [];
    for (const command of commands) {
      switch (command.type) {
        case "moveTo": {
          const point = this.pointToPdf({ x: command.x, y: command.y });
          if (!point) {
            return null;
          }
          result.push(`${point.x} ${point.y} m`);
          break;
        }
        case "lineTo": {
          const point = this.pointToPdf({ x: command.x, y: command.y });
          if (!point) {
            return null;
          }
          result.push(`${point.x} ${point.y} l`);
          break;
        }
        case "curveTo": {
          const cp1 = this.pointToPdf({ x: command.x1, y: command.y1 });
          const cp2 = this.pointToPdf({ x: command.x2, y: command.y2 });
          const end = this.pointToPdf({ x: command.x, y: command.y });
          if (!cp1 || !cp2 || !end) {
            return null;
          }
          result.push(`${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${end.x} ${end.y} c`);
          break;
        }
        case "closePath":
          result.push("h");
          break;
        default:
          return null;
      }
    }
    return result;
  }
  // isZeroRadius now imported from radius-utils.ts
  // generateRoundedRectPath now imported from rounded-rect-path.ts
  transformForRect(rect) {
    if (this.transformContext) {
      const relX = rect.x - this.transformContext.x;
      const relY = rect.y - this.transformContext.y;
      const scaleX2 = this.coordinateTransformer.convertPxToPt(1);
      const scaleY2 = this.coordinateTransformer.convertPxToPt(1);
      const translateX2 = this.coordinateTransformer.convertPxToPt(relX);
      const translateY2 = this.coordinateTransformer.convertPxToPt(-relY);
      return `${formatNumber4(scaleX2)} 0 0 ${formatNumber4(scaleY2)} ${formatNumber4(translateX2)} ${formatNumber4(translateY2)} cm`;
    }
    const scaleX = this.coordinateTransformer.convertPxToPt(1);
    const scaleY = this.coordinateTransformer.convertPxToPt(1);
    const localY = rect.y - this.coordinateTransformer.pageOffsetPx;
    const translateX = this.coordinateTransformer.convertPxToPt(rect.x);
    const translateY = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY);
    return `${formatNumber4(scaleX)} 0 0 ${formatNumber4(-scaleY)} ${formatNumber4(translateX)} ${formatNumber4(translateY)} cm`;
  }
  rectToPdf(rect) {
    return rectToPdf(rect, this.coordinateTransformer, this.transformContext);
  }
  pointToPdf(point) {
    return pointToPdf(point, this.coordinateTransformer, this.transformContext);
  }
  pointsToPdf(points) {
    const result = [];
    for (const point of points) {
      const converted = this.pointToPdf(point);
      if (!converted) {
        return null;
      }
      result.push(converted);
    }
    return result;
  }
  getResult() {
    return {
      commands: [...this.commands],
      shadings: this.gradientService.getShadings()
    };
  }
};
function resolveGradientPaint2(paint) {
  if (isLinearGradientPaint2(paint) || isRadialGradientPaint2(paint)) {
    return paint;
  }
  if (typeof paint === "string") {
    return parseLinearGradient(paint);
  }
  return null;
}
function isLinearGradientPaint2(value) {
  if (typeof value !== "object" || value === null) return false;
  const candidate = value;
  return candidate.type === "linear" && Array.isArray(candidate.stops);
}
function isRadialGradientPaint2(value) {
  if (typeof value !== "object" || value === null) return false;
  const candidate = value;
  return candidate.type === "radial" && typeof candidate.r === "number";
}

// src/pdf/renderers/graphics-state-manager.ts
var GraphicsStateManager = class {
  constructor() {
    this.fillAlphaStates = /* @__PURE__ */ new Map();
    this.graphicsStates = /* @__PURE__ */ new Map();
  }
  ensureFillAlphaState(alpha) {
    const normalized = this.normalizeAlpha(alpha);
    const key2 = normalized.toFixed(4);
    const existing = this.fillAlphaStates.get(key2);
    if (existing) {
      return existing;
    }
    const name = `GS${this.fillAlphaStates.size}`;
    const numeric = Number.parseFloat(key2);
    this.fillAlphaStates.set(key2, name);
    this.graphicsStates.set(name, numeric);
    return name;
  }
  getGraphicsStates() {
    return new Map(this.graphicsStates);
  }
  normalizeAlpha(alpha) {
    if (!Number.isFinite(alpha ?? NaN)) {
      return 1;
    }
    if (alpha === void 0) {
      return 1;
    }
    if (alpha <= 0) {
      return 0;
    }
    if (alpha >= 1) {
      return 1;
    }
    return alpha;
  }
};

// src/pdf/utils/clipping-path-builder.ts
var ClippingPathBuilder = class {
  constructor(coordinateTransformer) {
    this.coordinateTransformer = coordinateTransformer;
  }
  buildClipCommands(rect, radius) {
    if (!rect) {
      return null;
    }
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width === 0 || height === 0) {
      return null;
    }
    if (this.isZeroRadius(radius)) {
      const pdfRect = this.rectToPdf(rect);
      if (!pdfRect) {
        return null;
      }
      return [`${pdfRect.x} ${pdfRect.y} ${pdfRect.width} ${pdfRect.height} re`];
    }
    return this.buildRoundedClipCommands(rect, radius);
  }
  buildRoundedClipCommands(rect, radius) {
    const width = Math.max(rect.width, 0);
    const height = Math.max(rect.height, 0);
    if (width === 0 || height === 0) {
      return null;
    }
    const tl = radius.topLeft;
    const tr = radius.topRight;
    const br = radius.bottomRight;
    const bl = radius.bottomLeft;
    const k = 0.5522847498307936;
    const commands = [];
    const move = this.pointToPdf(rect.x + tl.x, rect.y);
    const lineTop = this.pointToPdf(rect.x + width - tr.x, rect.y);
    if (!move || !lineTop) {
      return null;
    }
    commands.push(`${move.x} ${move.y} m`);
    commands.push(`${lineTop.x} ${lineTop.y} l`);
    if (tr.x > 0 || tr.y > 0) {
      const cp1 = this.pointToPdf(rect.x + width - tr.x + k * tr.x, rect.y);
      const cp2 = this.pointToPdf(rect.x + width, rect.y + tr.y - k * tr.y);
      const end = this.pointToPdf(rect.x + width, rect.y + tr.y);
      if (!cp1 || !cp2 || !end) {
        return null;
      }
      commands.push(`${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${end.x} ${end.y} c`);
    } else {
      const corner = this.pointToPdf(rect.x + width, rect.y);
      if (!corner) {
        return null;
      }
      commands.push(`${corner.x} ${corner.y} l`);
    }
    const rightLine = this.pointToPdf(rect.x + width, rect.y + height - br.y);
    if (!rightLine) {
      return null;
    }
    commands.push(`${rightLine.x} ${rightLine.y} l`);
    if (br.x > 0 || br.y > 0) {
      const cp1 = this.pointToPdf(rect.x + width, rect.y + height - br.y + k * br.y);
      const cp2 = this.pointToPdf(rect.x + width - br.x + k * br.x, rect.y + height);
      const end = this.pointToPdf(rect.x + width - br.x, rect.y + height);
      if (!cp1 || !cp2 || !end) {
        return null;
      }
      commands.push(`${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${end.x} ${end.y} c`);
    } else {
      const corner = this.pointToPdf(rect.x + width, rect.y + height);
      if (!corner) {
        return null;
      }
      commands.push(`${corner.x} ${corner.y} l`);
    }
    const bottomLine = this.pointToPdf(rect.x + bl.x, rect.y + height);
    if (!bottomLine) {
      return null;
    }
    commands.push(`${bottomLine.x} ${bottomLine.y} l`);
    if (bl.x > 0 || bl.y > 0) {
      const cp1 = this.pointToPdf(rect.x + bl.x - k * bl.x, rect.y + height);
      const cp2 = this.pointToPdf(rect.x, rect.y + height - bl.y + k * bl.y);
      const end = this.pointToPdf(rect.x, rect.y + height - bl.y);
      if (!cp1 || !cp2 || !end) {
        return null;
      }
      commands.push(`${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${end.x} ${end.y} c`);
    } else {
      const corner = this.pointToPdf(rect.x, rect.y + height);
      if (!corner) {
        return null;
      }
      commands.push(`${corner.x} ${corner.y} l`);
    }
    const leftLine = this.pointToPdf(rect.x, rect.y + tl.y);
    if (!leftLine) {
      return null;
    }
    commands.push(`${leftLine.x} ${leftLine.y} l`);
    if (tl.x > 0 || tl.y > 0) {
      const cp1 = this.pointToPdf(rect.x, rect.y + tl.y - k * tl.y);
      const cp2 = this.pointToPdf(rect.x + tl.x - k * tl.x, rect.y);
      const end = this.pointToPdf(rect.x + tl.x, rect.y);
      if (!cp1 || !cp2 || !end) {
        return null;
      }
      commands.push(`${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${end.x} ${end.y} c`);
    } else {
      const corner = this.pointToPdf(rect.x, rect.y);
      if (!corner) {
        return null;
      }
      commands.push(`${corner.x} ${corner.y} l`);
    }
    commands.push("h");
    return commands;
  }
  rectToPdf(rect) {
    if (!rect) {
      return null;
    }
    const widthPt = this.coordinateTransformer.convertPxToPt(Math.max(rect.width, 0));
    const heightPt = this.coordinateTransformer.convertPxToPt(Math.max(rect.height, 0));
    if (!Number.isFinite(widthPt) || !Number.isFinite(heightPt) || widthPt === 0 || heightPt === 0) {
      return null;
    }
    const origin = this.pointToPdf(rect.x, rect.y + rect.height);
    if (!origin) {
      return null;
    }
    return {
      x: origin.x,
      y: origin.y,
      width: formatNumber6(widthPt),
      height: formatNumber6(heightPt)
    };
  }
  pointToPdf(xPx, yPx) {
    if (!Number.isFinite(xPx) || !Number.isFinite(yPx)) {
      return null;
    }
    const xPt = this.coordinateTransformer.convertPxToPt(xPx);
    const localY = yPx - this.coordinateTransformer.pageOffsetPx;
    const yPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY);
    if (!Number.isFinite(xPt) || !Number.isFinite(yPt)) {
      return null;
    }
    return {
      x: formatNumber6(xPt),
      y: formatNumber6(yPt)
    };
  }
  isZeroRadius(radius) {
    const epsilon = 1e-6;
    return Math.abs(radius.topLeft.x) <= epsilon && Math.abs(radius.topLeft.y) <= epsilon && Math.abs(radius.topRight.x) <= epsilon && Math.abs(radius.topRight.y) <= epsilon && Math.abs(radius.bottomRight.x) <= epsilon && Math.abs(radius.bottomRight.y) <= epsilon && Math.abs(radius.bottomLeft.x) <= epsilon && Math.abs(radius.bottomLeft.y) <= epsilon;
  }
};
function formatNumber6(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return Number.isInteger(value) ? value.toString() : value.toFixed(4).replace(/0+$/, "").replace(/\.$/, "");
}

// src/pdf/utils/image-matrix-builder.ts
var ImageMatrixBuilder = class {
  constructor(coordinateTransformer) {
    this.coordinateTransformer = coordinateTransformer;
  }
  buildImageMatrix(rect) {
    if (!rect || rect.width <= 0 || rect.height <= 0) {
      return null;
    }
    const widthPt = this.coordinateTransformer.convertPxToPt(rect.width);
    const heightPt = this.coordinateTransformer.convertPxToPt(rect.height);
    if (!Number.isFinite(widthPt) || !Number.isFinite(heightPt) || widthPt === 0 || heightPt === 0) {
      return null;
    }
    const xPt = this.coordinateTransformer.convertPxToPt(rect.x);
    const localY = rect.y - this.coordinateTransformer.pageOffsetPx;
    const yPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY + rect.height);
    if (!Number.isFinite(xPt) || !Number.isFinite(yPt)) {
      return null;
    }
    return `${formatNumber7(widthPt)} 0 0 ${formatNumber7(heightPt)} ${formatNumber7(xPt)} ${formatNumber7(yPt)} cm`;
  }
};
function formatNumber7(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return Number.isInteger(value) ? value.toString() : value.toFixed(4).replace(/0+$/, "").replace(/\.$/, "");
}

// src/pdf/utils/transform-scope-manager.ts
var TransformScopeManager = class {
  constructor(coordinateTransformer, shapeRenderer) {
    this.coordinateTransformer = coordinateTransformer;
    this.shapeRenderer = shapeRenderer;
  }
  beginTransformScope(transform, rect) {
    const pdfMatrix = svgMatrixToPdf(transform);
    if (!pdfMatrix) {
      this.shapeRenderer.pushRawCommands(["q"]);
      return;
    }
    const xPt = this.coordinateTransformer.convertPxToPt(rect.x);
    const localY = rect.y - this.coordinateTransformer.pageOffsetPx;
    const yPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY);
    const originOffsetX = Number.isFinite(rect.width) ? rect.width / 2 : 0;
    const originOffsetY = Number.isFinite(rect.height) ? rect.height / 2 : 0;
    const translateBackX = this.coordinateTransformer.convertPxToPt(-originOffsetX);
    const translateBackY = this.coordinateTransformer.convertPxToPt(originOffsetY);
    const translateForwardX = this.coordinateTransformer.convertPxToPt(originOffsetX);
    const translateForwardY = this.coordinateTransformer.convertPxToPt(-originOffsetY);
    const cmds = [
      "q",
      // Position element on page (applied last in the matrix chain)
      `1 0 0 1 ${formatNumber8(xPt)} ${formatNumber8(yPt)} cm`,
      // Translate back from pivot after applying skew/rotate
      `1 0 0 1 ${formatNumber8(translateForwardX)} ${formatNumber8(translateForwardY)} cm`,
      // Apply the css transform (already converted into PDF space)
      `${formatNumber8(pdfMatrix.a)} ${formatNumber8(pdfMatrix.b)} ${formatNumber8(pdfMatrix.c)} ${formatNumber8(pdfMatrix.d)} 0 0 cm`,
      // Move the local coordinate system so the transform pivot is the center of the box
      `1 0 0 1 ${formatNumber8(translateBackX)} ${formatNumber8(translateBackY)} cm`
    ];
    if (pdfMatrix.b !== 0 || pdfMatrix.c !== 0) {
      cmds.push(`%PAGYRA_TRANSFORM ${formatNumber8(pdfMatrix.a)} ${formatNumber8(pdfMatrix.b)} ${formatNumber8(pdfMatrix.c)} ${formatNumber8(pdfMatrix.d)} ${formatNumber8(pdfMatrix.e)} ${formatNumber8(pdfMatrix.f)}`);
    }
    this.shapeRenderer.pushRawCommands(cmds);
    this.shapeRenderer.setTransformContext(rect);
  }
  endTransformScope() {
    this.shapeRenderer.pushRawCommands(["Q"]);
    this.shapeRenderer.clearTransformContext();
  }
};
function formatNumber8(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return Number.isInteger(value) ? value.toString() : value.toFixed(4).replace(/0+$/, "").replace(/\.$/, "");
}

// src/pdf/utils/glyph-atlas-registrar.ts
init_glyph_atlas();
function registerGlyphAtlasPages(imageRenderer) {
  try {
    const pages = globalGlyphAtlas.getPages();
    if (pages && pages.length > 0) {
      imageRenderer.registerAtlasPages(pages);
    }
  } catch {
  }
}

// src/pdf/utils/image-command-partitioner.ts
function partitionImageCommands(commands, shadowAliases) {
  const preShadowImageCmds = [];
  const postImageCmds = [];
  for (let i = 0; i < commands.length; ) {
    if (commands[i] === "q" && i + 3 < commands.length && commands[i + 3] === "Q") {
      const doLine = commands[i + 2] ?? "";
      const match = doLine.match(/^\/(\w+)\s+Do$/);
      const block = [commands[i], commands[i + 1] ?? "", commands[i + 2] ?? "", commands[i + 3] ?? ""];
      i += 4;
      if (match && shadowAliases.has(match[1])) {
        preShadowImageCmds.push(...block);
      } else {
        postImageCmds.push(...block);
      }
    } else {
      postImageCmds.push(commands[i]);
      i += 1;
    }
  }
  return { preShadow: preShadowImageCmds, post: postImageCmds };
}

// src/pdf/utils/result-combiner.ts
var ResultCombiner = class {
  constructor(textRenderer, imageRenderer, shapeRenderer, graphicsStateManager) {
    this.textRenderer = textRenderer;
    this.imageRenderer = imageRenderer;
    this.shapeRenderer = shapeRenderer;
    this.graphicsStateManager = graphicsStateManager;
  }
  combineResults() {
    const textResult = this.textRenderer.getResult();
    registerGlyphAtlasPages(this.imageRenderer);
    const imageResult = this.imageRenderer.getResult();
    const shapeResult = this.shapeRenderer.getResult();
    const graphicsStates = /* @__PURE__ */ new Map();
    for (const [name, alpha] of this.graphicsStateManager.getGraphicsStates()) {
      graphicsStates.set(name, alpha);
    }
    const shadowAliases = /* @__PURE__ */ new Set();
    for (const [, res] of imageResult.images) {
      if (res.image.src && typeof res.image.src === "string" && res.image.src.startsWith("internal:shadow:")) {
        shadowAliases.add(res.alias);
      }
    }
    const { preShadow, post } = partitionImageCommands(imageResult.commands, shadowAliases);
    const allCommands = [...preShadow, ...shapeResult.commands, ...textResult.commands, ...post];
    const processedImages = [];
    for (const [, resource] of imageResult.images) {
      processedImages.push({
        alias: resource.alias,
        image: {
          src: resource.image.src,
          width: resource.image.width,
          height: resource.image.height,
          format: resource.image.format,
          channels: resource.image.channels,
          bitsPerComponent: resource.image.bitsPerComponent,
          data: new Uint8Array(resource.image.data)
          // Convert ArrayBuffer to Uint8Array
        },
        ref: resource.ref
      });
    }
    const combinedShadings = /* @__PURE__ */ new Map();
    for (const [name, dict] of shapeResult.shadings) {
      combinedShadings.set(name, dict);
    }
    for (const [name, dict] of textResult.shadings) {
      combinedShadings.set(name, dict);
    }
    const combinedPatterns = /* @__PURE__ */ new Map();
    for (const [name, dict] of textResult.patterns ?? []) {
      combinedPatterns.set(name, dict);
    }
    return {
      content: allCommands.join("\n"),
      fonts: textResult.fonts,
      images: processedImages,
      graphicsStates,
      shadings: combinedShadings,
      patterns: combinedPatterns
    };
  }
};

// src/pdf/page-painter.ts
init_glyph_atlas();
var PagePainter = class {
  constructor(pageHeightPt, pxToPt3, fontRegistry, pageOffsetPx = 0, environment) {
    this.clipDepth = 0;
    this.coordinateTransformer = new CoordinateTransformer(pageHeightPt, pxToPt3, pageOffsetPx);
    this.graphicsStateManager = new GraphicsStateManager();
    this.imageRenderer = new ImageRenderer(this.coordinateTransformer);
    this.textRenderer = new TextRenderer(this.coordinateTransformer, fontRegistry, this.imageRenderer, this.graphicsStateManager);
    this.shapeRenderer = new ShapeRenderer(this.coordinateTransformer, this.graphicsStateManager);
    this.clippingPathBuilder = new ClippingPathBuilder(this.coordinateTransformer);
    this.imageMatrixBuilder = new ImageMatrixBuilder(this.coordinateTransformer);
    this.transformScopeManager = new TransformScopeManager(this.coordinateTransformer, this.shapeRenderer);
    this.resultCombiner = new ResultCombiner(this.textRenderer, this.imageRenderer, this.shapeRenderer, this.graphicsStateManager);
    this.environment = environment;
  }
  get pageHeightPx() {
    return this.coordinateTransformer.pageHeightPx;
  }
  drawBoxOutline(box, color = { r: 0.85, g: 0.85, b: 0.85, a: 1 }) {
    this.shapeRenderer.drawBoxOutline(box, color);
  }
  drawFilledBox(box, color) {
    this.shapeRenderer.drawFilledBox(box, color);
  }
  drawImage(image, rect) {
    this.imageRenderer.drawImage(image, rect);
  }
  drawBackgroundImage(image, rect, clipRect, clipRadius) {
    if (!clipRect || clipRect.width <= 0 || clipRect.height <= 0) {
      this.drawImage(image, rect);
      return;
    }
    const clipCommands = this.clippingPathBuilder.buildClipCommands(clipRect, clipRadius);
    if (!clipCommands) {
      this.drawImage(image, rect);
      return;
    }
    const resource = this.imageRenderer.registerResource(image);
    const imageMatrix = this.imageMatrixBuilder.buildImageMatrix(rect);
    if (!imageMatrix) {
      return;
    }
    const commands = ["q", ...clipCommands, "W n", imageMatrix, `/${resource.alias} Do`, "Q"];
    this.shapeRenderer.pushRawCommands(commands);
  }
  // Draw an image immediately into the shape command stream (for shadows)
  drawShadowImage(image, rect) {
    if (rect.width <= 0 || rect.height <= 0) return;
    const res = this.imageRenderer.registerResource(image);
    const widthPt = this.coordinateTransformer.convertPxToPt(rect.width);
    const heightPt = this.coordinateTransformer.convertPxToPt(rect.height);
    if (widthPt === 0 || heightPt === 0) return;
    const xPt = this.coordinateTransformer.convertPxToPt(rect.x);
    const localY = rect.y - this.coordinateTransformer.pageOffsetPx;
    const yPt = this.coordinateTransformer.pageHeightPt - this.coordinateTransformer.convertPxToPt(localY + rect.height);
    const cmds = [
      "q",
      `${formatNumber9(widthPt)} 0 0 ${formatNumber9(heightPt)} ${formatNumber9(xPt)} ${formatNumber9(yPt)} cm`,
      `/${res.alias} Do`,
      "Q"
    ];
    this.shapeRenderer.pushRawCommands(cmds);
  }
  async drawText(text, xPx, yPx, options = { fontSizePt: 10 }) {
    await this.textRenderer.drawText(text, xPx, yPx, options);
  }
  async drawTextRun(run) {
    await this.textRenderer.drawTextRun(run);
  }
  fillRoundedRect(rect, radii, paint) {
    this.shapeRenderer.fillRoundedRect(rect, radii, paint);
  }
  fillRoundedRectDifference(outerRect, outerRadii, innerRect, innerRadii, color) {
    this.shapeRenderer.fillRoundedRectDifference(outerRect, outerRadii, innerRect, innerRadii, color);
  }
  fillRect(rect, paint) {
    this.shapeRenderer.fillRect(rect, paint);
  }
  strokeRect(rect, color) {
    this.shapeRenderer.strokeRect(rect, color);
  }
  strokeRoundedRect(rect, radii, color, lineWidth) {
    this.shapeRenderer.strokeRoundedRect(rect, radii, color, lineWidth);
  }
  fillPolygon(points, color, close = true) {
    this.shapeRenderer.fillPolygon(points, color, close);
  }
  fillPath(commands, color, options = {}) {
    this.shapeRenderer.fillPath(commands, color, options);
  }
  // New: fill an arbitrary path with a gradient (linear or radial). The ShapeRenderer will
  // create a clipping path from the provided commands and paint the shading clipped to that path.
  fillPathWithGradient(commands, gradient, options = {}) {
    this.shapeRenderer.fillPathWithGradient(commands, gradient, options);
  }
  strokePolyline(points, color, options = {}) {
    this.shapeRenderer.strokePolyline(points, color, options);
  }
  strokePath(commands, color, options = {}) {
    this.shapeRenderer.strokePath(commands, color, options);
  }
  beginClipPath(commands, options = {}) {
    if (this.shapeRenderer.beginClipPath(commands, options)) {
      this.clipDepth++;
    }
  }
  endClipPath() {
    if (this.clipDepth <= 0) {
      return;
    }
    this.shapeRenderer.endClipPath();
    this.clipDepth--;
  }
  convertPxToPt(value) {
    return this.coordinateTransformer.convertPxToPt(value);
  }
  beginOpacityScope(opacity) {
    if (opacity >= 1) return;
    const state = this.graphicsStateManager.ensureFillAlphaState(opacity);
    this.shapeRenderer.pushRawCommands(["q", `/${state} gs`]);
  }
  endOpacityScope(opacity) {
    if (opacity >= 1) return;
    this.shapeRenderer.pushRawCommands(["Q"]);
  }
  beginTransformScope(transform, rect) {
    this.transformScopeManager.beginTransformScope(transform, rect);
  }
  endTransformScope() {
    this.transformScopeManager.endTransformScope();
  }
  result() {
    try {
      const pages = globalGlyphAtlas.getPages();
      if (pages && pages.length > 0) {
        this.imageRenderer.registerAtlasPages(pages);
      }
    } catch {
    }
    return this.resultCombiner.combineResults();
  }
};
function formatNumber9(value) {
  if (!Number.isFinite(value)) {
    return "0";
  }
  return Number.isInteger(value) ? value.toString() : value.toFixed(4).replace(/0+$/, "").replace(/\.$/, "");
}

// src/pdf/renderer/page-paint.ts
async function paintLayoutPage({
  pageTree,
  pageNumber,
  totalPages,
  pageSize,
  pxToPt: pxToPt3,
  pageWidthPx,
  pageHeightPx,
  fontRegistry,
  headerFooterLayout,
  tokens,
  headerFooterTextOptions,
  pageBackground,
  margins,
  headerFooterCss,
  environment
}) {
  const painter = new PagePainter(pageSize.heightPt, pxToPt3, fontRegistry, pageTree.pageOffsetY, environment);
  const headerVariant = pickHeaderVariant(headerFooterLayout, pageNumber, totalPages);
  const footerVariant = pickFooterVariant(headerFooterLayout, pageNumber, totalPages);
  paintPageBackground(painter, pageBackground, pageWidthPx, pageHeightPx, pageTree.pageOffsetY);
  const hfContext = margins ? {
    margins,
    pageWidthPx,
    pageHeightPx,
    fontRegistry,
    pageOffsetY: pageTree.pageOffsetY,
    css: headerFooterCss,
    environment
  } : void 0;
  if (headerFooterLayout.layerMode === "under" /* Under */) {
    await paintHeaderFooter(
      painter,
      headerVariant,
      footerVariant,
      tokens,
      pageNumber,
      totalPages,
      headerFooterTextOptions,
      true,
      hfContext
    );
  }
  for (const box of pageTree.paintOrder) {
    await paintBoxAtomic(painter, box);
  }
  if (headerFooterLayout.layerMode === "over" /* Over */) {
    await paintHeaderFooter(
      painter,
      headerVariant,
      footerVariant,
      tokens,
      pageNumber,
      totalPages,
      headerFooterTextOptions,
      false,
      hfContext
    );
  }
  return painter.result();
}

// src/pdf/font/builtin-fonts.browser.ts
async function loadBuiltinFontConfig() {
  return null;
}

// src/pdf/utils/page-resource-registrar.ts
function registerPageResources(doc, result) {
  const xObjects = /* @__PURE__ */ new Map();
  for (const image of result.images) {
    const ref = doc.registerImage(image.image);
    image.ref = ref;
    xObjects.set(image.alias, ref);
  }
  const extGStates = /* @__PURE__ */ new Map();
  for (const [name, alpha] of result.graphicsStates) {
    const ref = doc.registerExtGState(alpha);
    extGStates.set(name, ref);
  }
  const shadings = /* @__PURE__ */ new Map();
  for (const [name, dict] of result.shadings) {
    const ref = doc.registerShading(name, dict);
    shadings.set(name, ref);
  }
  const patterns = /* @__PURE__ */ new Map();
  for (const [name, dict] of result.patterns ?? []) {
    const ref = doc.registerPattern(name, dict);
    patterns.set(name, ref);
  }
  return {
    fonts: result.fonts,
    xObjects,
    extGStates,
    shadings,
    patterns
  };
}

// src/pdf/render.ts
var DEFAULT_PAGE_SIZE2 = { widthPt: 595.28, heightPt: 841.89 };
async function renderPdf(layout, options = {}) {
  const fontConfig = options.fontConfig ?? await loadBuiltinFontConfig();
  const pageSize = options.pageSize ?? derivePageSize(layout);
  const pxToPt3 = createPxToPt(layout.dpiAssumption);
  const ptToPx2 = createPtToPx(layout.dpiAssumption);
  const doc = new PdfDocument(options.metadata ?? {});
  const fontRegistry = initFontSystem(doc, layout.css);
  if (fontConfig) {
    await fontRegistry.initializeEmbedder(fontConfig);
  }
  preflightFontsForPdfa(fontRegistry);
  const pageHeightPx = ptToPx2(pageSize.heightPt) || 1;
  const pageWidthPx = ptToPx2(pageSize.widthPt) || 1;
  const margins = options.margins ?? {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  const baseContentBox = computeBaseContentBox(layout.root, pageSize, pxToPt3);
  const hfContext = initHeaderFooterContext(layout.hf, pageSize, baseContentBox);
  const hfLayout = layoutHeaderFooterTrees(hfContext, pxToPt3);
  const adjustedContentBox = adjustPageBoxForHf(baseContentBox, hfLayout);
  const effectiveContentHeightPx = pageHeightPx - hfLayout.headerHeightPx - hfLayout.footerHeightPx;
  const paginationHeight = effectiveContentHeightPx > 0 ? effectiveContentHeightPx : pageHeightPx;
  const pages = paginateTree(layout.root, { pageHeight: paginationHeight });
  const totalPages = pages.length;
  const tokens = computeHfTokens(layout.hf.placeholders ?? {}, totalPages, options.metadata);
  const pageBackground = resolvePageBackground(layout.root);
  const fontResolver = new FontRegistryResolver(fontRegistry);
  await enrichTreeWithGlyphRuns2(layout.root, fontResolver);
  const headerFooterTextOptions = { fontSizePt: 10, fontFamily: layout.hf.fontFamily };
  for (let index = 0; index < pages.length; index++) {
    const pageTree = pages[index];
    const pageNumber = index + 1;
    const painterResult = await paintLayoutPage({
      pageTree,
      pageNumber,
      totalPages,
      pageSize,
      pxToPt: pxToPt3,
      pageWidthPx,
      pageHeightPx,
      fontRegistry,
      headerFooterLayout: hfLayout,
      tokens,
      headerFooterTextOptions,
      pageBackground,
      margins,
      headerFooterCss: options.headerFooterCss,
      environment: options.environment
    });
    const resources = registerPageResources(doc, painterResult);
    doc.addPage({
      width: pageSize.widthPt,
      height: pageSize.heightPt,
      contents: painterResult.content,
      resources,
      annotations: []
    });
  }
  finalizeFontSubsets(fontRegistry);
  return doc.finalize();
}
function resolvePageBackground(root) {
  if (root.background?.color) {
    return root.background.color;
  }
  for (const child of root.children) {
    if (child.tagName === "body" || child.tagName === "html") {
      const candidate = child.background?.color;
      if (candidate) {
        return candidate;
      }
    }
  }
  return void 0;
}
function createPxToPt(dpi) {
  const safeDpi = dpi > 0 ? dpi : 96;
  const factor = 72 / safeDpi;
  return (px) => px * factor;
}
function createPtToPx(dpi) {
  const safeDpi = dpi > 0 ? dpi : 96;
  const factor = safeDpi / 72;
  return (pt) => pt * factor;
}
function derivePageSize(layout) {
  const widthPt = layout.root.contentBox.width > 0 ? createPxToPt(layout.dpiAssumption)(layout.root.contentBox.width) : DEFAULT_PAGE_SIZE2.widthPt;
  const heightPt = layout.root.contentBox.height > 0 ? createPxToPt(layout.dpiAssumption)(layout.root.contentBox.height) : DEFAULT_PAGE_SIZE2.heightPt;
  return { widthPt, heightPt };
}
function computeBaseContentBox(root, pageSize, pxToPt3) {
  const widthPx = root.contentBox.width > 0 ? root.contentBox.width : pageSize.widthPt / pxToPt3(1);
  const heightPx = root.contentBox.height > 0 ? root.contentBox.height : pageSize.heightPt / pxToPt3(1);
  return {
    x: root.contentBox.x,
    y: root.contentBox.y,
    width: widthPx,
    height: heightPx
  };
}
async function enrichTreeWithGlyphRuns2(root, fontResolver) {
  async function enrichRun(run) {
    log("font", "debug", `Attempting to enrich: "${run.text}", family: ${run.fontFamily}`);
    if (run.glyphs) {
      log("font", "debug", "Already has glyphs, skipping");
      return;
    }
    try {
      const font = await fontResolver.resolve(run.fontFamily, run.fontWeight, run.fontStyle);
      log("font", "debug", "Font resolved for glyph enrichment");
      const letterSpacing = run.letterSpacing ?? 0;
      const glyphRun = computeGlyphRun(font, run.text, run.fontSize, letterSpacing);
      applyWordSpacingToGlyphRun(glyphRun, run.text, run.wordSpacing);
      run.glyphs = glyphRun;
      log("font", "debug", `Enriched "${run.text}" with ${glyphRun.glyphIds.length} glyphs:`, glyphRun.glyphIds);
    } catch (error) {
      log("font", "warn", `Failed to enrich "${run.text}":`, error);
    }
  }
  async function traverse3(box) {
    if (box.textRuns && box.textRuns.length > 0) {
      log("font", "debug", `Found ${box.textRuns.length} text runs in box ${box.tagName || "text"}`);
      for (const run of box.textRuns) {
        await enrichRun(run);
      }
    }
    for (const child of box.children) {
      await traverse3(child);
    }
  }
  log("font", "debug", "Starting enrichment of tree");
  await traverse3(root);
  log("font", "debug", "Finished enrichment");
}

// src/pdf/utils/text-layout-adjuster.ts
function applyTextLayoutAdjustments(root) {
  traverse2(root, (box) => {
    if (box.textAlign !== "justify") return true;
    const allRuns = [];
    collectRunsFromTree(box, allRuns);
    const candidates = allRuns.filter(
      (run) => typeof run.lineIndex === "number"
    );
    if (candidates.length === 0) return false;
    const groups = groupRunsByLineIndex(candidates);
    for (const lineRuns of groups) {
      adjustLinePositions(lineRuns);
    }
    return false;
  });
}
function groupRunsByLineIndex(runs) {
  const map = /* @__PURE__ */ new Map();
  for (const run of runs) {
    const idx = run.lineIndex;
    let group = map.get(idx);
    if (!group) {
      group = [];
      map.set(idx, group);
    }
    group.push(run);
  }
  for (const group of map.values()) {
    group.sort((a, b) => {
      const ax = a.lineMatrix?.e ?? 0;
      const bx = b.lineMatrix?.e ?? 0;
      return ax - bx;
    });
  }
  return Array.from(map.values());
}
function adjustLinePositions(runs) {
  if (runs.length === 0) return;
  let firstContentIndex = 0;
  while (firstContentIndex < runs.length && /^\s+$/.test(runs[firstContentIndex].text)) {
    firstContentIndex++;
  }
  let widthLost = 0;
  for (let i = 0; i < firstContentIndex; i++) {
    widthLost += runs[i].advanceWidth ?? 0;
  }
  let remainingSpaces = 0;
  for (let i = firstContentIndex; i < runs.length; i++) {
    remainingSpaces += runs[i].spacesInRun ?? 0;
  }
  const isLastLine = runs[0].isLastLine ?? false;
  if (!isLastLine && widthLost > 0 && remainingSpaces > 0) {
    const adjustment = widthLost / remainingSpaces;
    for (let i = firstContentIndex; i < runs.length; i++) {
      const run = runs[i];
      if ((run.spacesInRun ?? 0) > 0) {
        run.wordSpacing = (run.wordSpacing ?? 0) + adjustment;
        run.advanceWidth = (run.advanceWidth ?? 0) + run.spacesInRun * adjustment;
      }
    }
  }
  const originals = runs.map((run) => ({
    x: run.lineMatrix?.e ?? 0,
    baseWidth: (run.advanceWidth ?? 0) - (run.spacesInRun ?? 0) * (run.wordSpacing ?? 0),
    fontSize: run.fontSize
  }));
  let currentX = originals[0].x;
  for (let i = 0; i < runs.length; i++) {
    const run = runs[i];
    if (i < firstContentIndex) {
      if (run.lineMatrix) {
        run.lineMatrix.e = currentX;
      }
      run.advanceWidth = 0;
      continue;
    }
    if (run.lineMatrix) {
      run.lineMatrix.e = currentX;
    }
    const advanceWidth = run.advanceWidth ?? 0;
    currentX += advanceWidth;
    if (i < runs.length - 1) {
      const nextOriginal = originals[i + 1];
      const currOriginal = originals[i];
      const gap = nextOriginal.x - (currOriginal.x + currOriginal.baseWidth);
      const threshold = Math.max(currOriginal.fontSize, nextOriginal.fontSize);
      const isStripped = i < firstContentIndex;
      if (gap > threshold || !isStripped && advanceWidth === 0 && gap > 0) {
        currentX += gap;
      }
    }
  }
}
function collectRunsFromTree(box, accumulator) {
  if (box.textRuns) {
    accumulator.push(...box.textRuns);
  }
  for (const child of box.children) {
    collectRunsFromTree(child, accumulator);
  }
}
function traverse2(box, visitor) {
  const continueTraversal = visitor(box);
  if (continueTraversal) {
    for (const child of box.children) {
      traverse2(child, visitor);
    }
  }
}

// src/units/page-utils.ts
var DEFAULT_PAGE_SIZE_PT = { width: 595.28, height: 841.89 };
var DEFAULT_PAGE_MARGINS_PT = { top: 36, right: 36, bottom: 36, left: 36 };
var DEFAULT_PAGE_WIDTH_PX = ptToPx(DEFAULT_PAGE_SIZE_PT.width);
var DEFAULT_PAGE_HEIGHT_PX = ptToPx(DEFAULT_PAGE_SIZE_PT.height);
var DEFAULT_PAGE_MARGINS_PX = {
  top: ptToPx(DEFAULT_PAGE_MARGINS_PT.top),
  right: ptToPx(DEFAULT_PAGE_MARGINS_PT.right),
  bottom: ptToPx(DEFAULT_PAGE_MARGINS_PT.bottom),
  left: ptToPx(DEFAULT_PAGE_MARGINS_PT.left)
};

// src/html-to-pdf.ts
async function renderHtmlToPdf(options) {
  const environment = options.environment ?? new NodeEnvironment(options.assetRootDir ?? options.resourceBaseDir);
  const resolvedFontConfig = options.fontConfig ?? await loadBuiltinFontConfig(environment);
  const preparedOptions = resolvedFontConfig ? { ...options, fontConfig: resolvedFontConfig, environment } : { ...options, environment };
  const prepared = await prepareHtmlRender(preparedOptions);
  return renderPdf(prepared.renderTree, {
    pageSize: prepared.pageSize,
    fontConfig: resolvedFontConfig ?? void 0,
    margins: prepared.margins,
    environment
  });
}
async function prepareHtmlRender(options) {
  const { html, css, viewportWidth, viewportHeight, pageWidth, pageHeight, margins, debug = false, debugLevel, debugCats, headerFooter } = options;
  const normalizedHtml = normalizeHtmlInput(html);
  setViewportSize(viewportWidth, viewportHeight);
  const isNode2 = typeof process !== "undefined" && !!process.versions?.node;
  const resourceBaseDir = options.resourceBaseDir ?? options.assetRootDir ?? "";
  const assetRootDir = options.assetRootDir ?? resourceBaseDir;
  const environment = options.environment ?? new NodeEnvironment(assetRootDir);
  if (debugLevel || debugCats) {
    configureDebug({ level: debugLevel ?? (debug ? "debug" : "info"), cats: debugCats });
  }
  const unitCtx = { viewport: { width: viewportWidth, height: viewportHeight } };
  const units = makeUnitParsers(unitCtx);
  log("html-to-pdf", "debug", `prepareHtmlRender - input html: ${html}`);
  let { document } = parseHTML(normalizedHtml);
  if (needsReparse(document)) {
    document = parseHTML(wrapHtml(html)).document;
  }
  log("html-to-pdf", "debug", `prepareHtmlRender - parsed document body: ${document.body?.innerHTML || "no body"}`);
  log("html-to-pdf", "debug", `prepareHtmlRender - document.documentElement tagName: ${document.documentElement?.tagName}`);
  log("html-to-pdf", "debug", `prepareHtmlRender - document.documentElement innerHTML: ${document.documentElement?.innerHTML}`);
  log("html-to-pdf", "debug", `prepareHtmlRender - document children count: ${document.childNodes.length}`);
  for (let i = 0; i < document.childNodes.length; i++) {
    const child = document.childNodes[i];
    log("html-to-pdf", "debug", `prepareHtmlRender - document child ${i}: ${child.nodeType}, ${child.tagName || "text node"}`);
  }
  log("parse", "debug", "DOM parsed", { hasBody: !!document.body });
  let mergedCss = css || "";
  const styleTags = Array.from(document.querySelectorAll("style"));
  for (const styleTag of styleTags) {
    if (styleTag.textContent) mergedCss += "\n" + styleTag.textContent;
  }
  const linkTags = Array.from(document.querySelectorAll("link")).filter((link) => (link.getAttribute("rel") || "").toLowerCase() === "stylesheet");
  for (const linkTag of linkTags) {
    const href = linkTag.getAttribute("href");
    if (!href) continue;
    const cssText = await loadStylesheetFromHref(href, resourceBaseDir, assetRootDir, environment);
    if (cssText) mergedCss += "\n" + cssText;
  }
  const { styleRules: cssRules, fontFaceRules } = parseCss(mergedCss);
  log("parse", "debug", "CSS rules", { count: cssRules.length, fontFaces: fontFaceRules.length });
  let rootElement = document.body;
  let processChildrenOf = rootElement;
  if (rootElement && rootElement.childNodes.length === 0) {
    const meaningfulChildren = Array.from(document.documentElement.childNodes).filter((node) => {
      return node.nodeType === node.ELEMENT_NODE && node.tagName !== "HEAD";
    });
    if (meaningfulChildren.length > 0) {
      processChildrenOf = document.documentElement;
    }
  } else if (!rootElement) {
    processChildrenOf = document.documentElement;
  }
  const baseParentStyle = new ComputedStyle();
  const htmlElement = document.documentElement;
  const documentElementStyle = htmlElement ? computeStyleForElement(htmlElement, cssRules, baseParentStyle, units, baseParentStyle.fontSize) : baseParentStyle;
  const rootFontSize = documentElementStyle.fontSize;
  let rootStyle;
  if (!processChildrenOf || processChildrenOf === htmlElement) {
    rootStyle = documentElementStyle;
  } else {
    rootStyle = computeStyleForElement(processChildrenOf, cssRules, documentElementStyle, units, rootFontSize);
  }
  if (isInlineDisplay7(rootStyle.display)) {
    rootStyle.display = "block" /* Block */;
  }
  const rootLayout = new LayoutNode(rootStyle, [], { tagName: processChildrenOf?.tagName?.toLowerCase() });
  const conversionContext = { resourceBaseDir, assetRootDir, units, rootFontSize, environment };
  if (processChildrenOf) {
    log("html-to-pdf", "debug", `prepareHtmlRender - processing children of: ${processChildrenOf.tagName}, count: ${processChildrenOf.childNodes.length}`);
    for (const child of Array.from(processChildrenOf.childNodes)) {
      log("html-to-pdf", "debug", `prepareHtmlRender - processing child: ${child.tagName || "text node"}, type: ${child.nodeType}`);
      if (child.nodeType === child.ELEMENT_NODE) {
        const tagName19 = child.tagName.toLowerCase();
        if (tagName19 === "head" || tagName19 === "meta" || tagName19 === "title" || tagName19 === "link" || tagName19 === "script") {
          continue;
        }
      }
      const layoutChild = await convertDomNode(child, cssRules, rootStyle, conversionContext);
      if (layoutChild) rootLayout.appendChild(layoutChild);
    }
  }
  const pdfDoc = new PdfDocument();
  for (const fontFace of fontFaceRules) {
    const fontFamily = fontFace.declarations["font-family"]?.replace(/['"]/g, "");
    const src = fontFace.declarations["src"];
    if (fontFamily && src) {
      const targetUrl = pickFontUrlFromSrc(src);
      if (targetUrl && options.fontConfig) {
        const fontData = await loadFontData(targetUrl, resourceBaseDir, assetRootDir, environment);
        if (fontData) {
          const weightStr = fontFace.declarations["font-weight"] || "400";
          const styleStr = fontFace.declarations["font-style"] || "normal";
          options.fontConfig.fontFaceDefs.push({
            name: fontFamily,
            family: fontFamily,
            src: targetUrl,
            data: fontData,
            weight: parseFontWeight2(weightStr),
            style: normalizeFontStyle(styleStr)
          });
        }
      }
    }
  }
  if (options.fontConfig) {
    for (const face of options.fontConfig.fontFaceDefs) {
      if (!face.data && face.src) {
        const loaded = await loadFontData(face.src, resourceBaseDir, assetRootDir, environment);
        if (loaded) {
          face.data = loaded;
        }
      }
    }
  }
  const fontEmbedder = options.fontConfig ? new FontEmbedder(options.fontConfig, pdfDoc) : null;
  if (fontEmbedder) {
    await fontEmbedder.initialize();
  }
  layoutTree(rootLayout, { width: viewportWidth, height: viewportHeight }, fontEmbedder);
  log("layout", "debug", "Layout complete");
  const renderTree = buildRenderTree(rootLayout, { headerFooter });
  applyTextLayoutAdjustments(renderTree.root);
  const headerHeightPx = headerFooter?.maxHeaderHeightPx ?? 0;
  const footerHeightPx = headerFooter?.maxFooterHeightPx ?? 0;
  applyPageVerticalMarginsWithHf(renderTree.root, {
    pageHeight,
    margins,
    headerHeightPx,
    footerHeightPx
  });
  offsetRenderTree(renderTree.root, margins.left, 0, debug);
  const pageSize = { widthPt: pxToPt(pageWidth), heightPt: pxToPt(pageHeight) };
  return { layoutRoot: rootLayout, renderTree, pageSize, margins };
}
async function loadStylesheetFromHref(href, resourceBaseDir, assetRootDir, environment) {
  const trimmed = href.trim();
  if (!trimmed) return "";
  try {
    if (/^https?:\/\//i.test(trimmed) || trimmed.startsWith("//")) {
      const absoluteHref = trimmed.startsWith("//") ? `https:${trimmed}` : trimmed;
      const response = await fetch(absoluteHref);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const cssText2 = await response.text();
      return rewriteCssUrls(cssText2, absoluteHref);
    }
    const cssPath = environment.resolveLocal ? environment.resolveLocal(trimmed, resourceBaseDir) : resolveLocalPath(trimmed, resourceBaseDir, assetRootDir);
    const cssBuffer = await environment.loader.load(cssPath);
    const cssText = new TextDecoder("utf-8").decode(cssBuffer);
    const baseHref = /^https?:\/\//i.test(cssPath) || cssPath.startsWith("file:") ? cssPath : pathToFileURL(cssPath).toString();
    return rewriteCssUrls(cssText, baseHref);
  } catch (error) {
    log("parse", "warn", "Failed to load stylesheet", { href, error: error instanceof Error ? error.message : String(error) });
    return "";
  }
}
function rewriteCssUrls(cssText, baseHref) {
  let base;
  try {
    base = new URL(baseHref);
  } catch {
    return cssText;
  }
  const urlRegex = /url\(\s*(['"]?)([^'")]+)\1\s*\)/gi;
  return cssText.replace(urlRegex, (match, quote, rawUrl) => {
    const candidate = (rawUrl || "").trim();
    if (!candidate || /^data:/i.test(candidate)) return match;
    if (/^[a-z][a-z0-9+\-.]*:/i.test(candidate)) return match;
    try {
      const resolved = new URL(candidate, base).toString();
      const q = quote || "";
      return `url(${q}${resolved}${q})`;
    } catch {
      return match;
    }
  });
}
function pickFontUrlFromSrc(src) {
  const urlRegex = /url\(\s*(['"]?)([^'")]+)\1\s*\)(?:\s*format\(\s*['"]?([^'")]+)['"]?\s*\))?/gi;
  let fallback = null;
  let preferred = null;
  let match;
  while ((match = urlRegex.exec(src)) !== null) {
    const url = match[2];
    const format = (match[3] || "").toLowerCase();
    if (!fallback) fallback = url;
    if (format === "woff2") {
      preferred = url;
      break;
    }
  }
  return preferred ?? fallback;
}
function parseFontWeight2(weightStr) {
  const normalized = weightStr.trim().toLowerCase();
  if (normalized === "bold") return 700;
  if (normalized === "normal") return 400;
  const parsed = Number.parseInt(normalized, 10);
  return Number.isFinite(parsed) ? parsed : 400;
}
function normalizeFontStyle(styleStr) {
  const normalized = styleStr.trim().toLowerCase();
  return normalized.includes("italic") || normalized.includes("oblique") ? "italic" : "normal";
}
function resolveLocalPath(target, resourceBaseDir, assetRootDir) {
  let result = target;
  if (result.startsWith("file://")) {
    result = fileURLToPath(result);
  } else if (result.startsWith("/")) {
    result = empty_default.resolve(assetRootDir, `.${result}`);
  } else if (!empty_default.isAbsolute(result)) {
    result = empty_default.resolve(resourceBaseDir, result);
  }
  return result;
}
async function loadFontData(src, resourceBaseDir, assetRootDir, environment) {
  const trimmed = src.trim();
  if (!trimmed) return null;
  let target = trimmed;
  try {
    if (target.startsWith("//")) {
      target = `https:${target}`;
    }
    if (/^data:/i.test(target)) {
      const commaIdx = target.indexOf(",");
      if (commaIdx === -1) {
        throw new Error("Invalid data URI");
      }
      const meta = target.slice(5, commaIdx);
      if (!/;base64/i.test(meta)) {
        throw new Error("Only base64-encoded data URIs are supported for fonts");
      }
      const data = decodeBase64ToUint8Array(target.slice(commaIdx + 1));
      const copy = data.slice();
      return copy.buffer;
    }
    if (/^https?:\/\//i.test(target)) {
      const response = await fetch(target);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return await response.arrayBuffer();
    }
    const resolved = environment.resolveLocal ? environment.resolveLocal(target, resourceBaseDir) : resolveLocalPath(target, resourceBaseDir, assetRootDir);
    const fontDataBuffer = await environment.loader.load(resolved);
    return fontDataBuffer;
  } catch (error) {
    log("font", "warn", "Failed to load font data", { src, error: error instanceof Error ? error.message : String(error) });
    return null;
  }
}
function isInlineDisplay7(display) {
  return display === "inline" /* Inline */ || display === "inline-block" /* InlineBlock */ || display === "inline-flex" /* InlineFlex */ || display === "inline-grid" /* InlineGrid */ || display === "inline-table" /* InlineTable */;
}
function normalizeHtmlInput(html) {
  const hasHtmlTag = /<\s*html[\s>]/i.test(html);
  if (hasHtmlTag) {
    return html;
  }
  return wrapHtml(html);
}
function wrapHtml(html) {
  return `<!doctype html><html><head></head><body>${html}</body></html>`;
}
function needsReparse(document) {
  const docEl = document.documentElement?.tagName;
  const docIsHtml = docEl?.toUpperCase() === "HTML";
  if (!docIsHtml) return true;
  if (!document.body) return true;
  return false;
}

// src/browser-entry.ts
async function renderHtmlToPdfBrowser(options) {
  const environment = new BrowserEnvironment();
  setGlobalEnvironment(environment);
  return renderHtmlToPdf({ ...options, environment });
}
export {
  LOG_CATEGORIES,
  renderHtmlToPdfBrowser
};
/*! Bundled license information:

atob/browser-atob.js:
  (*!! Deliberately using an API that's deprecated in node.js because *)
  (*!! this file is for browsers and we expect them to cope with it. *)
  (*!! Discussion: github.com/node-browser-compat/atob/pull/9 *)
*/
//# sourceMappingURL=pagyra-playground-browser.js.map
